var documenterSearchIndex = {"docs":
[{"location":"semilinear/Linear/#OrdinaryDiffEqLinear","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear","text":"Specialized methods for linear and semi-linear differential equations where the system can be written in matrix form du/dt = A(t,u) * u or du/dt = A(t) * u. These methods exploit the linear structure to provide exact solutions or highly accurate integration.","category":"section"},{"location":"semilinear/Linear/#Key-Properties","page":"OrdinaryDiffEqLinear","title":"Key Properties","text":"Linear ODE methods provide:\n\nExact solutions for time-independent linear systems\nGeometric integration preserving Lie group structure\nHigh-order Magnus expansions for time-dependent linear systems\nLie group methods for matrix differential equations\nExcellent stability for a wide range of linear systems\nSpecialized algorithms for different types of linear operators","category":"section"},{"location":"semilinear/Linear/#When-to-Use-Linear-Methods","page":"OrdinaryDiffEqLinear","title":"When to Use Linear Methods","text":"These methods are essential for:\n\nLinear systems du/dt = A * u with constant or time-dependent matrices\nMatrix differential equations on Lie groups (rotation matrices, etc.)\nQuantum dynamics with Hamiltonian evolution\nLinear oscillators and harmonic systems\nTime-dependent linear systems with periodic or smooth coefficients\nGeometric mechanics requiring preservation of group structure","category":"section"},{"location":"semilinear/Linear/#Mathematical-Background","page":"OrdinaryDiffEqLinear","title":"Mathematical Background","text":"For linear systems du/dt = A(t) * u, the exact solution is u(t) = exp(∫A(s)ds) * u₀. Linear methods approximate this matrix exponential using various mathematical techniques like Magnus expansions, Lie group integrators, and specialized exponential methods.","category":"section"},{"location":"semilinear/Linear/#Solver-Selection-Guide","page":"OrdinaryDiffEqLinear","title":"Solver Selection Guide","text":"","category":"section"},{"location":"semilinear/Linear/#Time-and-state-independent-(constant-A)","page":"OrdinaryDiffEqLinear","title":"Time and state-independent (constant A)","text":"LinearExponential: Exact solution for du/dt = A * u with constant matrix A","category":"section"},{"location":"semilinear/Linear/#Time-dependent,-state-independent-(A(t))","page":"OrdinaryDiffEqLinear","title":"Time-dependent, state-independent (A(t))","text":"MagnusMidpoint: Second-order Magnus method\nMagnusLeapfrog: Second-order Magnus leapfrog scheme\nMagnusGauss4: Fourth-order with Gauss quadrature\nMagnusGL4: Fourth-order Gauss-Legendre Magnus method\nMagnusGL6: Sixth-order Gauss-Legendre Magnus method\nMagnusGL8: Eighth-order Gauss-Legendre Magnus method\nMagnusNC6: Sixth-order Newton-Cotes Magnus method\nMagnusNC8: Eighth-order Newton-Cotes Magnus method","category":"section"},{"location":"semilinear/Linear/#State-dependent-(A(u))","page":"OrdinaryDiffEqLinear","title":"State-dependent (A(u))","text":"LieEuler: First-order Lie group method\nRKMK2: Second-order Runge-Kutta-Munthe-Kaas method\nRKMK4: Fourth-order Runge-Kutta-Munthe-Kaas method\nLieRK4: Fourth-order Lie Runge-Kutta method\nCG2: Second-order Crouch-Grossman method\nCG4a: Fourth-order Crouch-Grossman method\nCayleyEuler: First-order method using Cayley transformations","category":"section"},{"location":"semilinear/Linear/#Adaptive-methods","page":"OrdinaryDiffEqLinear","title":"Adaptive methods","text":"MagnusAdapt4: Fourth-order adaptive Magnus method","category":"section"},{"location":"semilinear/Linear/#Time-and-state-dependent-(A(t,u))","page":"OrdinaryDiffEqLinear","title":"Time and state-dependent (A(t,u))","text":"CG3: Third-order Crouch-Grossman method for most general case","category":"section"},{"location":"semilinear/Linear/#Method-Selection-Guidelines","page":"OrdinaryDiffEqLinear","title":"Method Selection Guidelines","text":"For constant linear systems: LinearExponential (exact)\nFor time-dependent systems: Magnus methods based on desired order\nFor matrix Lie groups: Lie group methods (RKMK, LieRK4, CG)\nFor high accuracy: Higher-order Magnus methods (GL6, GL8)\nFor adaptive integration: MagnusAdapt4","category":"section"},{"location":"semilinear/Linear/#Special-Considerations","page":"OrdinaryDiffEqLinear","title":"Special Considerations","text":"These methods require:\n\nProper problem formulation with identified linear structure\nMatrix operator interface for operator-based problems\nUnderstanding of Lie group structure for geometric problems","category":"section"},{"location":"semilinear/Linear/#Installation","page":"OrdinaryDiffEqLinear","title":"Installation","text":"To be able to access the solvers in OrdinaryDiffEqLinear, you must first install them use the Julia package manager:\n\nusing Pkg\nPkg.add(\"OrdinaryDiffEqLinear\")\n\nThis will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.","category":"section"},{"location":"semilinear/Linear/#Example-usage","page":"OrdinaryDiffEqLinear","title":"Example usage","text":"using OrdinaryDiffEqLinear, SciMLOperators\nfunction update_func!(A, u, p, t)\n    A[1, 1] = 0\n    A[2, 1] = sin(u[1])\n    A[1, 2] = -1\n    A[2, 2] = 0\nend\nA0 = ones(2, 2)\nA = MatrixOperator(A0, update_func! = update_func!)\nu0 = ones(2)\ntspan = (0.0, 30.0)\nprob = ODEProblem(A, u0, tspan)\nsol = solve(prob, LieRK4(), dt = 1 / 4)","category":"section"},{"location":"semilinear/Linear/#Full-list-of-solvers","page":"OrdinaryDiffEqLinear","title":"Full list of solvers","text":"","category":"section"},{"location":"semilinear/Linear/#Time-and-State-Independent-Solvers","page":"OrdinaryDiffEqLinear","title":"Time and State-Independent Solvers","text":"","category":"section"},{"location":"semilinear/Linear/#Time-Dependent-and-State-Independent-Solvers","page":"OrdinaryDiffEqLinear","title":"Time-Dependent and State-Independent Solvers","text":"","category":"section"},{"location":"semilinear/Linear/#State-Dependent-Solvers","page":"OrdinaryDiffEqLinear","title":"State-Dependent Solvers","text":"","category":"section"},{"location":"semilinear/Linear/#Time-and-State-Dependent-Operators","page":"OrdinaryDiffEqLinear","title":"Time and State-Dependent Operators","text":"","category":"section"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.LinearExponential","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.LinearExponential","text":"LinearExponential(; krylov = :off,\n                    m = 10,\n                    iop = 0)\n\nSemilinear ODE solver Exact solution formula for linear, time-independent problems.\n\nKeyword Arguments\n\nkrylov:\n:off: cache the operator beforehand. Requires Matrix(A) method defined for the operator A.\n:simple: uses simple Krylov approximations with fixed subspace size m.\n:adaptive: uses adaptive Krylov approximations with internal timestepping.\nm: Controls the size of Krylov subspace if krylov=:simple, and the initial subspace size if krylov=:adaptive.\niop: If not zero, determines the length of the incomplete orthogonalization procedure       Note that if the linear operator/Jacobian is hermitian,       then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@book{strogatz2018nonlinear,     title={Nonlinear dynamics and chaos: with applications to physics, biology, chemistry, and engineering},     author={Strogatz, Steven H},     year={2018},     publisher={CRC press}}\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusMidpoint","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusMidpoint","text":"MagnusMidpoint(; krylov = false,\n                 m = 30,\n                 iop = 0)\n\nSemilinear ODE solver Second order Magnus Midpoint method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nhttps://joshuagoings.com/2017/06/15/magnus/\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusLeapfrog","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusLeapfrog","text":"MagnusLeapfrog(; krylov = false,\n                 m = 30,\n                 iop = 0)\n\nSemilinear ODE solver Second order Magnus Leapfrog method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nhttps://joshuagoings.com/2017/06/15/magnus/\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusGauss4","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusGauss4","text":"MagnusGauss4(; krylov = false,\n               m = 30,\n               iop = 0)\n\nSemilinear ODE solver Fourth order Magnus method approximated using a two stage Gauss quadrature.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{hairer2011solving,   title={Solving differential equations on manifolds},   author={Hairer, Ernst},   journal={Lecture notes},   year={2011} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusNC6","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusNC6","text":"MagnusNC6(; krylov = false,\n            m = 30,\n            iop = 0)\n\nSemilinear ODE solver Sixth order Magnus method approximated using Newton-Cotes quadrature.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{blanes2000improved,   title={Improved high order integrators based on the Magnus expansion},   author={Blanes, Sergio and Casas, Fernando and Ros, Javier},   journal={BIT Numerical Mathematics},   volume={40},   number={3},   pages={434–450},   year={2000},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusGL6","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusGL6","text":"MagnusGL6(; krylov = false,\n            m = 30,\n            iop = 0)\n\nSemilinear ODE solver Sixth order Magnus method approximated using Gauss-Legendre quadrature.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{blanes2000improved,   title={Improved high order integrators based on the Magnus expansion},   author={Blanes, Sergio and Casas, Fernando and Ros, Javier},   journal={BIT Numerical Mathematics},   volume={40},   number={3},   pages={434–450},   year={2000},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusGL8","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusGL8","text":"MagnusGL8(; krylov = false,\n            m = 30,\n            iop = 0)\n\nSemilinear ODE solver Eighth order Magnus method approximated using Newton-Cotes quadrature.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{blanes2000improved,   title={Improved high order integrators based on the Magnus expansion},   author={Blanes, Sergio and Casas, Fernando and Ros, Javier},   journal={BIT Numerical Mathematics},   volume={40},   number={3},   pages={434–450},   year={2000},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusNC8","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusNC8","text":"MagnusNC8(; krylov = false,\n            m = 30,\n            iop = 0)\n\nSemilinear ODE solver Eighth order Magnus method approximated using Gauss-Legendre quadrature.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{blanes2000improved,   title={Improved high order integrators based on the Magnus expansion},   author={Blanes, Sergio and Casas, Fernando and Ros, Javier},   journal={BIT Numerical Mathematics},   volume={40},   number={3},   pages={434–450},   year={2000},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusGL4","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusGL4","text":"MagnusGL4(; krylov = false,\n            m = 30,\n            iop = 0)\n\nSemilinear ODE solver Fourth order Magnus method approximated using Gauss-Legendre quadrature.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{blanes2009magnus,   title={The Magnus expansion and some of its applications},   author={Blanes, Sergio and Casas, Fernando and Oteo, Jose-Angel and Ros, Jos{'e}},   journal={Physics reports},   volume={470},   number={5-6},   pages={151–238},   year={2009},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.LieEuler","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.LieEuler","text":"LieEuler(; krylov = false,\n           m = 30,\n           iop = 0)\n\nSemilinear ODE solver description\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{celledoni2014introduction,   title={An introduction to Lie group integrators–basics, new developments and applications},   author={Celledoni, Elena and Marthinsen, H{\u0007a}kon and Owren, Brynjulf},   journal={Journal of Computational Physics},   volume={257},   pages={1040–1061},   year={2014},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.RKMK2","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.RKMK2","text":"RKMK2(; krylov = false,\n        m = 30,\n        iop = 0)\n\nSemilinear ODE solver Second order Runge–Kutta–Munthe-Kaas method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{celledoni2014introduction,   title={An introduction to Lie group integrators–basics, new developments and applications},   author={Celledoni, Elena and Marthinsen, H{\u0007a}kon and Owren, Brynjulf},   journal={Journal of Computational Physics},   volume={257},   pages={1040–1061},   year={2014},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.RKMK4","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.RKMK4","text":"RKMK4(; krylov = false,\n        m = 30,\n        iop = 0)\n\nSemilinear ODE solver Fourth order Runge–Kutta–Munthe-Kaas method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{celledoni2014introduction,   title={An introduction to Lie group integrators–basics, new developments and applications},   author={Celledoni, Elena and Marthinsen, H{\u0007a}kon and Owren, Brynjulf},   journal={Journal of Computational Physics},   volume={257},   pages={1040–1061},   year={2014},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.LieRK4","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.LieRK4","text":"LieRK4(; krylov = false,\n         m = 30,\n         iop = 0)\n\nSemilinear ODE solver Fourth order Lie Runge-Kutta method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{celledoni2014introduction,   title={An introduction to Lie group integrators–basics, new developments and applications},   author={Celledoni, Elena and Marthinsen, H{\u0007a}kon and Owren, Brynjulf},   journal={Journal of Computational Physics},   volume={257},   pages={1040–1061},   year={2014},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.CG2","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.CG2","text":"CG2(; krylov = false,\n      m = 30,\n      iop = 0)\n\nSemilinear ODE solver Second order Crouch–Grossman method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{celledoni2014introduction,   title={An introduction to Lie group integrators–basics, new developments and applications},   author={Celledoni, Elena and Marthinsen, H{\u0007a}kon and Owren, Brynjulf},   journal={Journal of Computational Physics},   volume={257},   pages={1040–1061},   year={2014},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.CG4a","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.CG4a","text":"CG4a(; krylov = false,\n       m = 30,\n       iop = 0)\n\nSemilinear ODE solver  Fourth order Crouch-Grossman method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{jackiewicz2000construction,   title={Construction of Runge–Kutta methods of Crouch–Grossman type of high order},   author={Jackiewicz, Zdzislaw and Marthinsen, Arne and Owren, Brynjulf},   journal={Advances in Computational Mathematics},   volume={13},   pages={405–415},   year={2000},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusAdapt4","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusAdapt4","text":"MagnusAdapt4()\n\nSemilinear ODE solver Fourth Order Adaptive Magnus method.\n\nKeyword Arguments\n\nReferences\n\n@article{li2008adaptive,     title={Adaptive explicit Magnus numerical method for nonlinear dynamical systems},     author={Li, Wen-cheng and Deng, Zi-chen},     journal={Applied Mathematics and Mechanics},     volume={29},     number={9},     pages={1111–1118},     year={2008},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.CayleyEuler","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.CayleyEuler","text":"CayleyEuler()\n\nSemilinear ODE solver First order method using Cayley transformations.\n\nKeyword Arguments\n\nReferences\n\n@article{iserles2000lie,     title={Lie-group methods},     author={Iserles, Arieh and Munthe-Kaas, Hans Z and Norsett, Syvert P and Zanna, Antonella},     journal={Acta numerica},     volume={9},     pages={215–365},     year={2000},     publisher={Cambridge University Press}}\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.CG3","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.CG3","text":"CG3(; krylov = false,\n      m = 30,\n      iop = 0)\n\nSemilinear ODE solver Third order Crouch-Grossman method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{crouch1993numerical,   title={Numerical integration of ordinary differential equations on manifolds},   author={Crouch, Peter E and Grossman, R},   journal={Journal of Nonlinear Science},   volume={3},   pages={1–33},   year={1993},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/PDIRK/#OrdinaryDiffEqPDIRK","page":"OrdinaryDiffEqPDIRK","title":"OrdinaryDiffEqPDIRK","text":"PDIRK methods are parallel DIRK methods. SDIRK methods, or singly-diagonally implicit methods, have to build and solve a factorize a Jacobian of the form W = I-gammaJ where gamma is dependent on the chosen method. PDIRK methods use multiple different choices of gamma, i.e. W_i = I-gamma_iJ, which are all used in the update process. There are some advantages to this, as no SDIRK method can be a higher order than 5, while DIRK methods generally can have arbitrarily high order and lower error coefficients, leading to lower errors at larger dt sizes. With the right construction of the tableau, these matrices can be factorized and the underlying steps can be computed in parallel, which is why these are the parallel DIRK methods.\n\nwarning: Experimental\nOrdinaryDiffEqPDIRK is experimental, as there are no parallel DIRK tableaus that achieve good performance in the literature.\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqPDIRK\", \"PDIRK44\")","category":"section"},{"location":"implicit/PDIRK/#Full-list-of-solvers","page":"OrdinaryDiffEqPDIRK","title":"Full list of solvers","text":"","category":"section"},{"location":"implicit/PDIRK/#OrdinaryDiffEqPDIRK.PDIRK44","page":"OrdinaryDiffEqPDIRK","title":"OrdinaryDiffEqPDIRK.PDIRK44","text":"PDIRK44(; chunk_size = Val{0}(),\n          autodiff = AutoForwardDiff(),\n          standardtag = Val{true}(),\n          concrete_jac = nothing,\n          diff_type = Val{:forward},\n          linsolve = nothing,\n          precs = DEFAULT_PRECS,\n          nlsolve = NLNewton(),\n          extrapolant = :constant,\n          thread = OrdinaryDiffEq.True())\n\nParallel Diagonally Implicit Runge-Kutta Method. A 2 processor 4th order diagonally non-adaptive implicit method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify PDIRK44(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD,\nextrapolant: TBD,\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n\"@article{iserles1990theory, title={On the theory of parallel Runge—Kutta methods}, author={Iserles, Arieh and Norrsett, SP}, journal={IMA Journal of numerical Analysis}, volume={10}, number={4}, pages={463–488}, year={1990}, publisher={Oxford University Press}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/Extrapolation/#StiffExtrapolation","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation","text":"Solvers based on within method parallelism. These solvers perform well for medium sized systems of ordinary differential equations, of about 20 to 500 equations, at low tolerances.\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqExtrapolation\", \"ImplicitEulerBarycentricExtrapolation\")","category":"section"},{"location":"implicit/Extrapolation/#Full-list-of-solvers","page":"OrdinaryDiffEqExtrapolation","title":"Full list of solvers","text":"","category":"section"},{"location":"implicit/Extrapolation/#OrdinaryDiffEqExtrapolation.ImplicitEulerExtrapolation","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation.ImplicitEulerExtrapolation","text":"ImplicitEulerExtrapolation(; chunk_size = Val{0}(),\n                             autodiff = AutoForwardDiff(),\n                             standardtag = Val{true}(),\n                             concrete_jac = nothing,\n                             diff_type = Val{:forward},\n                             linsolve = nothing,\n                             precs = DEFAULT_PRECS,\n                             max_order = 12,\n                             min_order = 3,\n                             init_order = 5,\n                             thread = OrdinaryDiffEq.False(),\n                             sequence = :harmonic)\n\nParallelized Explicit Extrapolation Method. Extrapolation of implicit Euler method with Romberg sequence. Similar to Hairer's SEULEX.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ImplicitEulerExtrapolation(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nmax_order: maximum order of the adaptive order algorithm.\nmin_order: minimum order of the adaptive order algorithm.\ninit_order: initial order of the adaptive order algorithm.\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nsequence: the step-number sequences, also called the subdividing sequence. Possible values are :harmonic, :romberg or :bulirsch.\n\nReferences\n\n@inproceedings{elrod2022parallelizing,   title={Parallelizing explicit and implicit extrapolation methods for ordinary differential equations},   author={Elrod, Chris and Ma, Yingbo and Althaus, Konstantin and Rackauckas, Christopher and others},   booktitle={2022 IEEE High Performance Extreme Computing Conference (HPEC)},   pages={1–9},   year={2022},   organization={IEEE}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/Extrapolation/#OrdinaryDiffEqExtrapolation.ImplicitDeuflhardExtrapolation","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation.ImplicitDeuflhardExtrapolation","text":"ImplicitDeuflhardExtrapolation(; chunk_size = Val{0}(),\n                                 autodiff = AutoForwardDiff(),\n                                 standardtag = Val{true}(),\n                                 concrete_jac = nothing,\n                                 diff_type = Val{:forward},\n                                 linsolve = nothing,\n                                 precs = DEFAULT_PRECS,\n                                 max_order = 10,\n                                 min_order = 1,\n                                 init_order = 5,\n                                 thread = OrdinaryDiffEq.False(),\n                                 sequence = :harmonic)\n\nParallelized Explicit Extrapolation Method. Midpoint extrapolation using Barycentric coordinates.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ImplicitDeuflhardExtrapolation(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nmax_order: maximum order of the adaptive order algorithm.\nmin_order: minimum order of the adaptive order algorithm.\ninit_order: initial order of the adaptive order algorithm.\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nsequence: the step-number sequences, also called the subdividing sequence. Possible values are :harmonic, :romberg or :bulirsch.\n\nReferences\n\n@inproceedings{elrod2022parallelizing,   title={Parallelizing explicit and implicit extrapolation methods for ordinary differential equations},   author={Elrod, Chris and Ma, Yingbo and Althaus, Konstantin and Rackauckas, Christopher and others},   booktitle={2022 IEEE High Performance Extreme Computing Conference (HPEC)},   pages={1–9},   year={2022},   organization={IEEE}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/Extrapolation/#OrdinaryDiffEqExtrapolation.ImplicitHairerWannerExtrapolation","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation.ImplicitHairerWannerExtrapolation","text":"ImplicitHairerWannerExtrapolation(; chunk_size = Val{0}(),\n                                    autodiff = AutoForwardDiff(),\n                                    standardtag = Val{true}(),\n                                    concrete_jac = nothing,\n                                    diff_type = Val{:forward},\n                                    linsolve = nothing,\n                                    precs = DEFAULT_PRECS,\n                                    max_order = 10,\n                                    min_order = 2,\n                                    init_order = 5,\n                                    thread = OrdinaryDiffEq.False(),\n                                    sequence = :harmonic)\n\nParallelized Explicit Extrapolation Method. Midpoint extrapolation using Barycentric coordinates,     following Hairer's SODEX in the adaptivity behavior.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ImplicitHairerWannerExtrapolation(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nmax_order: maximum order of the adaptive order algorithm.\nmin_order: minimum order of the adaptive order algorithm.\ninit_order: initial order of the adaptive order algorithm.\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nsequence: the step-number sequences, also called the subdividing sequence. Possible values are :harmonic, :romberg or :bulirsch.\n\nReferences\n\n@inproceedings{elrod2022parallelizing,   title={Parallelizing explicit and implicit extrapolation methods for ordinary differential equations},   author={Elrod, Chris and Ma, Yingbo and Althaus, Konstantin and Rackauckas, Christopher and others},   booktitle={2022 IEEE High Performance Extreme Computing Conference (HPEC)},   pages={1–9},   year={2022},   organization={IEEE}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/Extrapolation/#OrdinaryDiffEqExtrapolation.ImplicitEulerBarycentricExtrapolation","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation.ImplicitEulerBarycentricExtrapolation","text":"ImplicitEulerBarycentricExtrapolation(; chunk_size = Val{0}(),\n                                        autodiff = AutoForwardDiff(),\n                                        standardtag = Val{true}(),\n                                        concrete_jac = nothing,\n                                        diff_type = Val{:forward},\n                                        linsolve = nothing,\n                                        precs = DEFAULT_PRECS,\n                                        max_order = 10,\n                                        min_order = 3,\n                                        init_order = 5,\n                                        thread = OrdinaryDiffEq.False(),\n                                        sequence = :harmonic,\n                                        sequence_factor = 2)\n\nParallelized Explicit Extrapolation Method. Euler extrapolation using Barycentric coordinates,     following Hairer's SODEX in the adaptivity behavior.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ImplicitEulerBarycentricExtrapolation(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nmax_order: maximum order of the adaptive order algorithm.\nmin_order: minimum order of the adaptive order algorithm.\ninit_order: initial order of the adaptive order algorithm.\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nsequence: the step-number sequences, also called the subdividing sequence. Possible values are :harmonic, :romberg or :bulirsch.\nsequence_factor: denotes which even multiple of sequence to take while evaluating internal discretizations.\n\nReferences\n\n@inproceedings{elrod2022parallelizing,   title={Parallelizing explicit and implicit extrapolation methods for ordinary differential equations},   author={Elrod, Chris and Ma, Yingbo and Althaus, Konstantin and Rackauckas, Christopher and others},   booktitle={2022 IEEE High Performance Extreme Computing Conference (HPEC)},   pages={1–9},   year={2022},   organization={IEEE}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/FIRK/#OrdinaryDiffEqFIRK","page":"OrdinaryDiffEqFIRK","title":"OrdinaryDiffEqFIRK","text":"Fully Implicit Runge-Kutta (FIRK) methods for stiff differential equations requiring very high accuracy. These methods solve a fully coupled implicit system at each timestep, providing superior accuracy and stability compared to diagonally implicit methods.\n\nwarning: Real Numbers Only\nFIRK methods should only be used for problems defined on real numbers, not complex numbers.","category":"section"},{"location":"implicit/FIRK/#Key-Properties","page":"OrdinaryDiffEqFIRK","title":"Key Properties","text":"FIRK methods provide:\n\nHighest-order implicit methods (excluding extrapolation)\nSuperior accuracy for very low tolerance requirements (≤ 1e-9)\nA-stable and L-stable behavior for stiff problems\nHigher order per stage than SDIRK methods (order 2s+1 for s stages)\nSpecial geometric properties (some methods are symplectic)\nExcellent for small to medium systems with high accuracy requirements","category":"section"},{"location":"implicit/FIRK/#When-to-Use-FIRK-Methods","page":"OrdinaryDiffEqFIRK","title":"When to Use FIRK Methods","text":"These methods are recommended for:\n\nVery low tolerance problems (1e-9 and below) where accuracy is paramount\nSmall to medium stiff systems (< 200 equations)\nProblems requiring highest possible accuracy for implicit methods\nStiff problems where SDIRK order limitations (max order 5) are insufficient\nApplications where computational cost is acceptable for maximum accuracy","category":"section"},{"location":"implicit/FIRK/#Mathematical-Background","page":"OrdinaryDiffEqFIRK","title":"Mathematical Background","text":"RadauIIA methods are based on Gaussian collocation and achieve order 2s+1 for s stages, making them among the highest-order implicit methods available. They represent the ODE analog of Gaussian quadrature. For more details on recent advances in FIRK methods, see our paper: High-Order Adaptive Time Stepping for the Incompressible Navier-Stokes Equations.","category":"section"},{"location":"implicit/FIRK/#Computational-Considerations","page":"OrdinaryDiffEqFIRK","title":"Computational Considerations","text":"","category":"section"},{"location":"implicit/FIRK/#Advantages","page":"OrdinaryDiffEqFIRK","title":"Advantages","text":"Higher accuracy per stage than diagonal methods\nBetter multithreading for small systems due to larger linear algebra operations\nNo order restrictions like SDIRK methods (which max out at order 5)","category":"section"},{"location":"implicit/FIRK/#Disadvantages","page":"OrdinaryDiffEqFIRK","title":"Disadvantages","text":"Limited to real-valued problems - cannot be used for complex number systems\nHigher implementation complexity compared to SDIRK methods","category":"section"},{"location":"implicit/FIRK/#Solver-Selection-Guide","page":"OrdinaryDiffEqFIRK","title":"Solver Selection Guide","text":"","category":"section"},{"location":"implicit/FIRK/#High-accuracy-requirements","page":"OrdinaryDiffEqFIRK","title":"High accuracy requirements","text":"AdaptiveRadau: Recommended - adaptive order method that automatically selects optimal order\nRadauIIA5: 5th-order method, good balance of accuracy and efficiency\nRadauIIA9: 9th-order method for extremely high accuracy requirements\nRadauIIA3: 3rd-order method for moderate accuracy needs","category":"section"},{"location":"implicit/FIRK/#System-size-considerations","page":"OrdinaryDiffEqFIRK","title":"System size considerations","text":"Systems < 200: FIRK methods are competitive due to better multithreading\nSystems > 200: Consider SDIRK or BDF methods instead","category":"section"},{"location":"implicit/FIRK/#Performance-Guidelines","page":"OrdinaryDiffEqFIRK","title":"Performance Guidelines","text":"Best for tolerances ≤ 1e-9 where high accuracy justifies the cost\nMost efficient on small to medium systems where linear algebra cost is manageable\nShould be tested against parallel implicit extrapolation methods which specialize in similar regimes\nCompare with high-order SDIRK methods for borderline cases\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqFIRK\", \"RadauIIA5\")","category":"section"},{"location":"implicit/FIRK/#Full-list-of-solvers","page":"OrdinaryDiffEqFIRK","title":"Full list of solvers","text":"","category":"section"},{"location":"implicit/FIRK/#OrdinaryDiffEqFIRK.RadauIIA3","page":"OrdinaryDiffEqFIRK","title":"OrdinaryDiffEqFIRK.RadauIIA3","text":"RadauIIA3(; chunk_size = Val{0}(),\n            autodiff = AutoForwardDiff(),\n            standardtag = Val{true}(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward},\n            linsolve = nothing,\n            precs = DEFAULT_PRECS,\n            extrapolant = :dense,\n            smooth_est = true,\n            step_limiter! = trivial_limiter!)\n\nFully-Implicit Runge-Kutta Method. An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency. Similar to Hairer's SEULEX.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify RadauIIA3(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nextrapolant: TBD\nsmooth_est: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{hairer1999stiff, title={Stiff differential equations solved by Radau methods}, author={Hairer, Ernst and Wanner, Gerhard}, journal={Journal of Computational and Applied Mathematics}, volume={111}, number={1-2}, pages={93–111}, year={1999}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/FIRK/#OrdinaryDiffEqFIRK.RadauIIA5","page":"OrdinaryDiffEqFIRK","title":"OrdinaryDiffEqFIRK.RadauIIA5","text":"RadauIIA5(; chunk_size = Val{0}(),\n            autodiff = AutoForwardDiff(),\n            standardtag = Val{true}(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward},\n            linsolve = nothing,\n            precs = DEFAULT_PRECS,\n            extrapolant = :dense,\n            smooth_est = true,\n            step_limiter! = trivial_limiter!)\n\nFully-Implicit Runge-Kutta Method. An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency. 5th order method with excellent numerical stability. Good for highly stiff systems, problems requiring high-order implicit integration, systems with complex eigenvalue structures. Best for low tolerance stiff problems (<1e-9).\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify RadauIIA5(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nextrapolant: TBD\nsmooth_est: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{hairer1999stiff, title={Stiff differential equations solved by Radau methods}, author={Hairer, Ernst and Wanner, Gerhard}, journal={Journal of Computational and Applied Mathematics}, volume={111}, number={1-2}, pages={93–111}, year={1999}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/FIRK/#OrdinaryDiffEqFIRK.RadauIIA9","page":"OrdinaryDiffEqFIRK","title":"OrdinaryDiffEqFIRK.RadauIIA9","text":"RadauIIA9(; chunk_size = Val{0}(),\n            autodiff = AutoForwardDiff(),\n            standardtag = Val{true}(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward},\n            linsolve = nothing,\n            precs = DEFAULT_PRECS,\n            extrapolant = :dense,\n            smooth_est = true,\n            step_limiter! = trivial_limiter!)\n\nFully-Implicit Runge-Kutta Method. An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency. Similar to Hairer's SEULEX.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify RadauIIA9(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nextrapolant: TBD\nsmooth_est: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{hairer1999stiff, title={Stiff differential equations solved by Radau methods}, author={Hairer, Ernst and Wanner, Gerhard}, journal={Journal of Computational and Applied Mathematics}, volume={111}, number={1-2}, pages={93–111}, year={1999}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK","text":"Symplectic integrators are specialized methods for solving Hamiltonian systems and second-order differential equations that preserve important geometric properties of the phase space. These methods are essential for long-time integration of conservative mechanical systems.","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#Key-Properties","page":"OrdinaryDiffEqSymplecticRK","title":"Key Properties","text":"Symplectic integrators provide:\n\nExact conservation of symplectic structure in phase space\nBounded energy error over long time periods\nExcellent long-time stability without secular drift\nPreservation of periodic orbits and other geometric structures\nLinear energy drift instead of quadratic (much better than standard methods)","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#When-to-Use-Symplectic-Methods","page":"OrdinaryDiffEqSymplecticRK","title":"When to Use Symplectic Methods","text":"Symplectic integrators are essential for:\n\nHamiltonian systems and conservative mechanical problems\nMolecular dynamics and N-body simulations\nCelestial mechanics and orbital computations\nPlasma physics and charged particle dynamics\nLong-time integration where energy conservation is critical\nOscillatory problems requiring preservation of periodic structure\nClassical mechanics problems with known analytical properties","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#Mathematical-Background","page":"OrdinaryDiffEqSymplecticRK","title":"Mathematical Background","text":"For a Hamiltonian system with energy H(p,q), symplectic integrators preserve the symplectic structure dp ∧ dq. While standard integrators have energy error growing quadratically over time, symplectic methods maintain bounded energy with only linear drift, making them superior for long-time integration.","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#Solver-Selection-Guide","page":"OrdinaryDiffEqSymplecticRK","title":"Solver Selection Guide","text":"","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#First-order-methods","page":"OrdinaryDiffEqSymplecticRK","title":"First-order methods","text":"SymplecticEuler: First-order, simplest symplectic method. Only recommended when the dynamics function f is not differentiable.","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#Second-order-methods","page":"OrdinaryDiffEqSymplecticRK","title":"Second-order methods","text":"McAte2: Optimized second-order McLachlan-Atela method, recommended for most applications\nVelocityVerlet: Second-order, common choice for molecular dynamics but less efficient in terms of accuracy than McAte2\nVerletLeapfrog: Second-order, kick-drift-kick formulation\nLeapfrogDriftKickDrift: Alternative second-order leapfrog\nPseudoVerletLeapfrog: Modified Verlet scheme","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#Third-order-methods","page":"OrdinaryDiffEqSymplecticRK","title":"Third-order methods","text":"Ruth3: Third-order method\nMcAte3: Optimized third-order McLachlan-Atela method","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#Fourth-order-methods","page":"OrdinaryDiffEqSymplecticRK","title":"Fourth-order methods","text":"CandyRoz4: Fourth-order method\nMcAte4: Fourth-order McLachlan-Atela (requires quadratic kinetic energy)\nCalvoSanz4: Optimized fourth-order method\nMcAte42: Alternative fourth-order method (BROKEN)","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#Higher-order-methods","page":"OrdinaryDiffEqSymplecticRK","title":"Higher-order methods","text":"McAte5: Fifth-order McLachlan-Atela method\nYoshida6: Sixth-order method\nKahanLi6: Optimized sixth-order method\nMcAte8: Eighth-order McLachlan-Atela method\nKahanLi8: Optimized eighth-order method\nSofSpa10: Tenth-order method for highest precision","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#Method-Selection-Guidelines","page":"OrdinaryDiffEqSymplecticRK","title":"Method Selection Guidelines","text":"For most applications: McAte2 (second-order, optimal efficiency)\nFor molecular dynamics (common choice): VelocityVerlet (less efficient than McAte2 but widely used)\nFor non-differentiable dynamics: SymplecticEuler (first-order, only when necessary)\nFor computational efficiency: McAte2 or McAte3","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#Important-Note-on-Chaotic-Systems","page":"OrdinaryDiffEqSymplecticRK","title":"Important Note on Chaotic Systems","text":"Most N-body problems (molecular dynamics, astrophysics) are chaotic systems where solutions diverge onto shadow trajectories. In such cases, higher-order methods provide no practical advantage because the true error remains O(1) for sufficiently long integrations - exactly the scenarios where symplectic methods are most needed. The geometric properties preserved by symplectic integrators are more important than high-order accuracy for chaotic systems.\n\nFor more information on chaos and accuracy in numerical integration, see: How Chaotic is Chaos? How Some AI for Science (SciML) Papers are Overstating Accuracy Claims","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#Installation","page":"OrdinaryDiffEqSymplecticRK","title":"Installation","text":"To be able to access the solvers in OrdinaryDiffEqSymplecticRK, you must first install them use the Julia package manager:\n\nusing Pkg\nPkg.add(\"OrdinaryDiffEqSymplecticRK\")\n\nThis will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#Example-usage","page":"OrdinaryDiffEqSymplecticRK","title":"Example usage","text":"using OrdinaryDiffEqSymplecticRK\nfunction HH_acceleration!(dv, v, u, p, t)\n    x, y = u\n    dx, dy = dv\n    dv[1] = -x - 2x * y\n    dv[2] = y^2 - y - x^2\nend\ninitial_positions = [0.0, 0.1]\ninitial_velocities = [0.5, 0.0]\ntspan = (0.0, 1.0)\nprob = SecondOrderODEProblem(HH_acceleration!, initial_velocities, initial_positions, tspan)\nsol = solve(prob, KahanLi8(), dt = 1 / 10)","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#Full-list-of-solvers","page":"OrdinaryDiffEqSymplecticRK","title":"Full list of solvers","text":"","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.SymplecticEuler","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.SymplecticEuler","text":"SymplecticEuler()\n\nSymplectic Runge-Kutta Methods First order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\nhttps://en.wikipedia.org/wiki/Semi-implicitEulermethod\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.VelocityVerlet","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.VelocityVerlet","text":"VelocityVerlet()\n\nSymplectic Runge-Kutta Methods 2nd order explicit symplectic integrator. Requires f_2(t,u) = v, i.e. a second order ODE.\n\nKeyword Arguments\n\nReferences\n\n@article{verlet1967computer, title={Computer\" experiments\" on classical fluids. I. Thermodynamical properties of Lennard-Jones molecules}, author={Verlet, Loup}, journal={Physical review}, volume={159}, number={1}, pages={98}, year={1967}, publisher={APS} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.VerletLeapfrog","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.VerletLeapfrog","text":"VerletLeapfrog()\n\nSymplectic Runge-Kutta Methods 2nd order explicit symplectic integrator. Kick-drift-kick form. Requires only one evaluation of f1 per step.\n\nKeyword Arguments\n\nReferences\n\n@article{monaghan2005, \ttitle = {Smoothed particle hydrodynamics}, \tauthor = {Monaghan, Joseph J.}, \tyear = {2005}, \tjournal = {Reports on Progress in Physics}, \tvolume = {68}, \tnumber = {8}, \tpages = {1703–1759}, \tdoi = {10.1088/0034-4885/68/8/R01}, }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.LeapfrogDriftKickDrift","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.LeapfrogDriftKickDrift","text":"LeapfrogDriftKickDrift()\n\nSymplectic Runge-Kutta Methods 2nd order explicit symplectic integrator. Drift-kick-drift form of VerletLeapfrog designed to work when f1 depends on v. Requires two evaluation of f1 per step.\n\nKeyword Arguments\n\nReferences\n\n@article{monaghan2005, \ttitle = {Smoothed particle hydrodynamics}, \tauthor = {Monaghan, Joseph J.}, \tyear = {2005}, \tjournal = {Reports on Progress in Physics}, \tvolume = {68}, \tnumber = {8}, \tpages = {1703–1759}, \tdoi = {10.1088/0034-4885/68/8/R01}, }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.PseudoVerletLeapfrog","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.PseudoVerletLeapfrog","text":"PseudoVerletLeapfrog()\n\nSymplectic Runge-Kutta Methods 2nd order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{verlet1967computer, title={Computer\" experiments\" on classical fluids. I. Thermodynamical properties of Lennard-Jones molecules}, author={Verlet, Loup}, journal={Physical review}, volume={159}, number={1}, pages={98}, year={1967}, publisher={APS} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.McAte2","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.McAte2","text":"McAte2()\n\nSymplectic Runge-Kutta Methods Optimized efficiency 2nd order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{mclachlan1992accuracy, title={The accuracy of symplectic integrators}, author={McLachlan, Robert I and Atela, Pau}, journal={Nonlinearity}, volume={5}, number={2}, pages={541}, year={1992}, publisher={IOP Publishing} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.Ruth3","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.Ruth3","text":"Ruth3()\n\nSymplectic Runge-Kutta Methods 3rd order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{ruth1983canonical, title={A canonical integration technique}, author={Ruth, Ronald D}, journal={IEEE Trans. Nucl. Sci.}, volume={30}, number={CERN-LEP-TH-83-14}, pages={2669–2671}, year={1983}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.McAte3","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.McAte3","text":"McAte3()\n\nSymplectic Runge-Kutta Methods Optimized efficiency 3rd order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{mclachlan1992accuracy, title={The accuracy of symplectic integrators}, author={McLachlan, Robert I and Atela, Pau}, journal={Nonlinearity}, volume={5}, number={2}, pages={541}, year={1992}, publisher={IOP Publishing} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.CandyRoz4","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.CandyRoz4","text":"CandyRoz4()\n\nSymplectic Runge-Kutta Methods 4th order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{candy1991symplectic, itle={A symplectic integration algorithm for separable Hamiltonian functions}, uthor={Candy, J and Rozmus, W}, ournal={Journal of Computational Physics}, olume={92}, umber={1}, ages={230–256}, ear={1991}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.McAte4","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.McAte4","text":"McAte4()\n\nSymplectic Runge-Kutta Methods 4th order explicit symplectic integrator. Requires quadratic kinetic energy.\n\nKeyword Arguments\n\nReferences\n\n@article{mclachlan1992accuracy, title={The accuracy of symplectic integrators}, author={McLachlan, Robert I and Atela, Pau}, journal={Nonlinearity}, volume={5}, number={2}, pages={541}, year={1992}, publisher={IOP Publishing} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.CalvoSanz4","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.CalvoSanz4","text":"CalvoSanz4()\n\nSymplectic Runge-Kutta Methods Optimized efficiency 4th order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{sanz1993symplectic, title={Symplectic numerical methods for Hamiltonian problems}, author={Sanz-Serna, Jes{'u}s Maria and Calvo, Mari-Paz}, journal={International Journal of Modern Physics C}, volume={4}, number={02}, pages={385–392}, year={1993}, publisher={World Scientific} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.McAte42","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.McAte42","text":"McAte42()\n\nSymplectic Runge-Kutta Methods 4th order explicit symplectic integrator. BROKEN\n\nKeyword Arguments\n\nReferences\n\n@article{mclachlan1992accuracy, title={The accuracy of symplectic integrators}, author={McLachlan, Robert I and Atela, Pau}, journal={Nonlinearity}, volume={5}, number={2}, pages={541}, year={1992}, publisher={IOP Publishing} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.McAte5","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.McAte5","text":"McAte5()\n\nSymplectic Runge-Kutta Methods Optimized efficiency 5th order explicit symplectic integrator. Requires quadratic kinetic energy.\n\nKeyword Arguments\n\nReferences\n\n@article{mclachlan1992accuracy, title={The accuracy of symplectic integrators}, author={McLachlan, Robert I and Atela, Pau}, journal={Nonlinearity}, volume={5}, number={2}, pages={541}, year={1992}, publisher={IOP Publishing} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.Yoshida6","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.Yoshida6","text":"Yoshida6()\n\nSymplectic Runge-Kutta Methods 6th order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{yoshida1990construction, title={Construction of higher order symplectic integrators}, author={Yoshida, Haruo}, journal={Physics letters A}, volume={150}, number={5-7}, pages={262–268}, year={1990}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.KahanLi6","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.KahanLi6","text":"KahanLi6()\n\nSymplectic Runge-Kutta Methods Optimized efficiency 6th order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{yoshida1990construction, title={Construction of higher order symplectic integrators}, author={Yoshida, Haruo}, journal={Physics letters A}, volume={150}, number={5-7}, pages={262–268}, year={1990}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.McAte8","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.McAte8","text":"McAte8()\n\nSymplectic Runge-Kutta Methods 8th order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{mclachlan1995numerical, title={On the numerical integration of ordinary differential equations by symmetric composition methods}, author={McLachlan, Robert I}, journal={SIAM Journal on Scientific Computing}, volume={16}, number={1}, pages={151–168}, year={1995}, publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.KahanLi8","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.KahanLi8","text":"KahanLi8()\n\nSymplectic Runge-Kutta Methods Optimized efficiency 8th order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{kahan1997composition, title={Composition constants for raising the orders of unconventional schemes for ordinary differential equations}, author={Kahan, William and Li, Ren-Cang}, journal={Mathematics of computation}, volume={66}, number={219}, pages={1089–1099}, year={1997}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.SofSpa10","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.SofSpa10","text":"SofSpa10()\n\nSymplectic Runge-Kutta Methods 10th order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{sofroniou2005derivation, title={Derivation of symmetric composition constants for symmetric integrators}, author={Sofroniou, Mark and Spaletta, Giulia}, journal={Optimization Methods and Software}, volume={20}, number={4-5}, pages={597–613}, year={2005}, publisher={Taylor \\& Francis}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/TaylorSeries/#OrdinaryDiffEqTaylorSeries","page":"OrdinaryDiffEqTaylorSeries","title":"OrdinaryDiffEqTaylorSeries","text":"Taylor series methods for ordinary differential equations using automatic differentiation. These methods achieve very high-order accuracy by computing Taylor expansions of the solution using automatic differentiation techniques through TaylorDiff.jl.\n\nwarn: Development Status\nThese methods are still in development and may not be fully optimized or reliable for production use.","category":"section"},{"location":"explicit/TaylorSeries/#Key-Properties","page":"OrdinaryDiffEqTaylorSeries","title":"Key Properties","text":"Taylor series methods provide:\n\nVery high-order accuracy with arbitrary order capability\nAutomatic differentiation for derivative computation\nStep size control through Taylor series truncation\nNatural error estimation from higher-order terms\nExcellent accuracy for smooth problems\nSingle-step methods without requiring history","category":"section"},{"location":"explicit/TaylorSeries/#When-to-Use-Taylor-Series-Methods","page":"OrdinaryDiffEqTaylorSeries","title":"When to Use Taylor Series Methods","text":"These methods are recommended for:\n\nUltra-high precision problems where maximum accuracy is needed\nSmooth problems with well-behaved derivatives\nScientific computing requiring very low error tolerances\nProblems with expensive function evaluations where high-order methods reduce total steps","category":"section"},{"location":"explicit/TaylorSeries/#Mathematical-Background","page":"OrdinaryDiffEqTaylorSeries","title":"Mathematical Background","text":"Taylor series methods compute the solution using Taylor expansions: u(t + h) = u(t) + h*u'(t) + h²/2!*u''(t) + h³/3!*u'''(t) + ...\n\nThe derivatives are computed automatically using automatic differentiation, allowing arbitrary-order methods without manual derivative computation.","category":"section"},{"location":"explicit/TaylorSeries/#Solver-Selection-Guide","page":"OrdinaryDiffEqTaylorSeries","title":"Solver Selection Guide","text":"","category":"section"},{"location":"explicit/TaylorSeries/#Available-Methods","page":"OrdinaryDiffEqTaylorSeries","title":"Available Methods","text":"ExplicitTaylor2: Second-order Taylor series method for moderate accuracy\nExplicitTaylor: Arbitrary-order Taylor series method (specify order with order = Val{p}())","category":"section"},{"location":"explicit/TaylorSeries/#Usage-considerations","page":"OrdinaryDiffEqTaylorSeries","title":"Usage considerations","text":"Smooth problems only: Methods assume the function has many continuous derivatives\nComputational cost: Higher orders require more automatic differentiation computations\nMemory requirements: Higher orders store more derivative information","category":"section"},{"location":"explicit/TaylorSeries/#Performance-Guidelines","page":"OrdinaryDiffEqTaylorSeries","title":"Performance Guidelines","text":"","category":"section"},{"location":"explicit/TaylorSeries/#When-Taylor-series-methods-excel","page":"OrdinaryDiffEqTaylorSeries","title":"When Taylor series methods excel","text":"Very smooth problems where high-order derivatives exist and are well-behaved\nHigh precision requirements beyond standard double precision\nLong-time integration where accumulated error matters\nProblems where function evaluations dominate computational cost","category":"section"},{"location":"explicit/TaylorSeries/#Problem-characteristics","page":"OrdinaryDiffEqTaylorSeries","title":"Problem characteristics","text":"Polynomial and analytic functions work extremely well\nSmooth ODEs from physics simulations\nProblems requiring very low tolerances (< 1e-12)","category":"section"},{"location":"explicit/TaylorSeries/#Limitations-and-Considerations","page":"OrdinaryDiffEqTaylorSeries","title":"Limitations and Considerations","text":"","category":"section"},{"location":"explicit/TaylorSeries/#Method-limitations","page":"OrdinaryDiffEqTaylorSeries","title":"Method limitations","text":"Requires smooth functions - non-smooth problems may cause issues\nMemory overhead for storing multiple derivatives\nLimited to problems where high-order derivatives are meaningful\nAutomatic differentiation compatibility - requires functions compatible with TaylorDiff.jl and Symbolics.jl tracing\nLong compile times due to automatic differentiation and symbolic processing overhead","category":"section"},{"location":"explicit/TaylorSeries/#When-to-consider-alternatives","page":"OrdinaryDiffEqTaylorSeries","title":"When to consider alternatives","text":"Non-smooth problems: Use adaptive Runge-Kutta methods instead\nStiff problems: Taylor methods are explicit and may be inefficient\nLarge systems: Automatic differentiation cost may become prohibitive\nStandard accuracy needs: Lower-order methods are often sufficient","category":"section"},{"location":"explicit/TaylorSeries/#Alternative-Approaches","page":"OrdinaryDiffEqTaylorSeries","title":"Alternative Approaches","text":"Consider these alternatives:\n\nHigh-order Runge-Kutta methods (Feagin, Verner) for good accuracy with less overhead\nExtrapolation methods for high accuracy with standard function evaluations\nAdaptive methods for problems with varying smoothness\nImplicit methods for stiff problems requiring high accuracy","category":"section"},{"location":"explicit/TaylorSeries/#Installation-and-Usage","page":"OrdinaryDiffEqTaylorSeries","title":"Installation and Usage","text":"Taylor series methods require explicit installation of the specialized library:\n\nusing Pkg\nPkg.add(\"OrdinaryDiffEqTaylorSeries\")\n\nThen use the methods with:\n\nusing OrdinaryDiffEqTaylorSeries\n\n# Example: Second-order Taylor method\nfunction f(u, p, t)\n    σ, ρ, β = p\n    du1 = σ * (u[2] - u[1])\n    du2 = u[1] * (ρ - u[3]) - u[2]\n    du3 = u[1] * u[2] - β * u[3]\n    [du1, du2, du3]\nend\n\nu0 = [1.0, 0.0, 0.0]\ntspan = (0.0, 10.0)\np = [10.0, 28.0, 8/3]\nprob = ODEProblem(f, u0, tspan, p)\n\n# Second-order Taylor method\nsol = solve(prob, ExplicitTaylor2())\n\n# Arbitrary-order Taylor method (e.g., 8th order)\nsol = solve(prob, ExplicitTaylor(order = Val{8}()))","category":"section"},{"location":"explicit/TaylorSeries/#Full-list-of-solvers","page":"OrdinaryDiffEqTaylorSeries","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/PRK/#OrdinaryDiffEqPRK","page":"OrdinaryDiffEqPRK","title":"OrdinaryDiffEqPRK","text":"Parallel Runge-Kutta (PRK) methods are explicit solvers specifically designed to exploit parallelism by making multiple independent evaluations of the ODE function f simultaneously. These methods are optimized for parallel computing environments where function evaluations can be distributed across multiple processors.\n\nwarning: Research and Development\nThese methods are currently in research and development and not intended for general use.","category":"section"},{"location":"explicit/PRK/#Key-Properties","page":"OrdinaryDiffEqPRK","title":"Key Properties","text":"PRK methods provide:\n\nExplicit parallelism in function evaluations within each timestep\nFixed processor count optimization for specific parallel architectures\nIndependent stage evaluations that can run simultaneously\nMaintained accuracy while achieving parallel speedup\nSpecialized tableaus designed for parallel efficiency","category":"section"},{"location":"explicit/PRK/#When-to-Use-PRK-Methods","page":"OrdinaryDiffEqPRK","title":"When to Use PRK Methods","text":"These methods are recommended for:\n\nParallel computing environments with multiple processors available\nExpensive function evaluations that benefit from parallelization\nSystems where function evaluation dominates computational cost\nApplications with fixed parallel architecture (e.g., exactly 2 or 5 processors)\nProblems where parallel speedup outweighs method overhead","category":"section"},{"location":"explicit/PRK/#Important-Considerations","page":"OrdinaryDiffEqPRK","title":"Important Considerations","text":"","category":"section"},{"location":"explicit/PRK/#Parallel-Requirements","page":"OrdinaryDiffEqPRK","title":"Parallel Requirements","text":"Requires multiple processors to achieve benefits\nFunction evaluations must be parallelizable (no data dependencies)\nParallel overhead must be less than speedup gains\nFixed processor count optimization may not match available hardware","category":"section"},{"location":"explicit/PRK/#When-NOT-to-Use","page":"OrdinaryDiffEqPRK","title":"When NOT to Use","text":"Sequential computing environments\nCheap function evaluations where parallel overhead dominates\nMemory-bound problems where parallelism doesn't help\nVariable processor availability scenarios\nLarge systems where LU factorization of implicit steps parallelizes efficiently (around 200×200 matrices and larger on modern processors)","category":"section"},{"location":"explicit/PRK/#Mathematical-Background","page":"OrdinaryDiffEqPRK","title":"Mathematical Background","text":"PRK methods rearrange traditional Runge-Kutta tableaus to allow stage evaluations to be computed independently and simultaneously. The specific processor count determines the tableau structure and achievable parallelism.","category":"section"},{"location":"explicit/PRK/#Solver-Selection-Guide","page":"OrdinaryDiffEqPRK","title":"Solver Selection Guide","text":"","category":"section"},{"location":"explicit/PRK/#Available-methods","page":"OrdinaryDiffEqPRK","title":"Available methods","text":"KuttaPRK2p5: Fifth-order method optimized for 2 processors","category":"section"},{"location":"explicit/PRK/#Usage-considerations","page":"OrdinaryDiffEqPRK","title":"Usage considerations","text":"Best with exactly 2 processors for KuttaPRK2p5\nFunction evaluation must support parallel execution\nTest parallel efficiency against sequential high-order methods\nConsider problem-specific parallel architecture","category":"section"},{"location":"explicit/PRK/#Performance-Guidelines","page":"OrdinaryDiffEqPRK","title":"Performance Guidelines","text":"Measure actual speedup vs sequential methods on target hardware\nAccount for parallel overhead in performance comparisons\nConsider memory bandwidth limitations in parallel environments\nCompare against other parallelization strategies (e.g., spatial domain decomposition)","category":"section"},{"location":"explicit/PRK/#Alternative-Parallelization-Approaches","page":"OrdinaryDiffEqPRK","title":"Alternative Parallelization Approaches","text":"For most problems, consider these alternatives:\n\nSpatial domain decomposition for PDE problems\nMultiple trajectory parallelism for Monte Carlo simulations\nVectorized operations within function evaluations\nHigh-order sequential methods with better single-thread performance\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqPRK\", \"KuttaPRK2p5\")","category":"section"},{"location":"explicit/PRK/#Full-list-of-solvers","page":"OrdinaryDiffEqPRK","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/PRK/#OrdinaryDiffEqPRK.KuttaPRK2p5","page":"OrdinaryDiffEqPRK","title":"OrdinaryDiffEqPRK.KuttaPRK2p5","text":"KuttaPRK2p5(; thread = OrdinaryDiffEq.True())\n\nExplicit Runge-Kutta Method A 5 parallel, 2 processor method of 5th order.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{jackson1995potential, title={The potential for parallelism in Runge–Kutta methods. Part 1: RK formulas in standard form}, author={Jackson, Kenneth R and Norsett, Syvert Paul}, journal={SIAM journal on numerical analysis}, volume={32}, number={1}, pages={49–82}, year={1995}, publisher={SIAM}}\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/StabilizedRK/#OrdinaryDiffEqStabilizedRK","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK","text":"Stabilized Runge-Kutta methods are explicit schemes designed to handle moderately stiff problems by extending the stability region through careful tableau construction. These methods use an upper bound on the spectral radius of the Jacobian to achieve much larger stable timesteps than conventional explicit methods. These methods are good for large real eigenvalue problems, but not for problems where the complex eigenvalues are large.","category":"section"},{"location":"semiimplicit/StabilizedRK/#Key-Properties","page":"OrdinaryDiffEqStabilizedRK","title":"Key Properties","text":"Stabilized RK methods provide:\n\nExtended stability regions for moderately stiff problems\nExplicit formulation avoiding nonlinear solvers\nLarge stable timestep sizes compared to standard explicit methods\nAutomatic spectral radius estimation or user-supplied bounds\nEfficient for parabolic PDEs with moderate stiffness\nGood performance on problems with well-separated timescales","category":"section"},{"location":"semiimplicit/StabilizedRK/#When-to-Use-Stabilized-RK-Methods","page":"OrdinaryDiffEqStabilizedRK","title":"When to Use Stabilized RK Methods","text":"These methods are recommended for:\n\nModerately stiff problems where implicit methods are overkill\nParabolic PDEs with diffusion-dominated behavior\nProblems with large spatial grids where implicit methods become expensive\nSystems with well-separated timescales but not extreme stiffness\nCases where explicit is preferred but standard methods are unstable\nLarge-scale problems where linear algebra cost of implicit methods is prohibitive","category":"section"},{"location":"semiimplicit/StabilizedRK/#Mathematical-Background","page":"OrdinaryDiffEqStabilizedRK","title":"Mathematical Background","text":"Stabilized methods achieve extended stability by constructing tableaus with enlarged stability regions, often using Chebyshev polynomials or orthogonal polynomial techniques. The stable timestep is determined by the spectral radius bound rather than the CFL condition. Important: These methods extend stability primarily along the negative real axis, making them effective for large real eigenvalues but ineffective when complex eigenvalues dominate the stiffness.","category":"section"},{"location":"semiimplicit/StabilizedRK/#Spectral-Radius-Estimation","page":"OrdinaryDiffEqStabilizedRK","title":"Spectral Radius Estimation","text":"Users can supply an upper bound on the spectral radius using:\n\neigen_est = (integrator) -> integrator.eigen_est = upper_bound\n\nIf not provided, the methods include automatic estimation procedures.","category":"section"},{"location":"semiimplicit/StabilizedRK/#Solver-Selection-Guide","page":"OrdinaryDiffEqStabilizedRK","title":"Solver Selection Guide","text":"","category":"section"},{"location":"semiimplicit/StabilizedRK/#Recommended-stabilized-methods","page":"OrdinaryDiffEqStabilizedRK","title":"Recommended stabilized methods","text":"ROCK2: Second-order ROW-type stabilized method with extended stability\nROCK4: Fourth-order stabilized method for higher accuracy requirements","category":"section"},{"location":"semiimplicit/StabilizedRK/#Performance-Guidelines","page":"OrdinaryDiffEqStabilizedRK","title":"Performance Guidelines","text":"","category":"section"},{"location":"semiimplicit/StabilizedRK/#When-stabilized-methods-excel","page":"OrdinaryDiffEqStabilizedRK","title":"When stabilized methods excel","text":"Large real eigenvalue problems where stiffness comes from real eigenvalues\nModerate stiffness ratio (10³ to 10⁶) dominated by real eigenvalues\nLarge spatial discretizations where implicit solver cost is high\nVery large systems where stabilized RK methods are more efficient than BDF methods due to no linear algebra requirements\nParabolic PDEs with diffusion-dominated (real eigenvalue) stiffness\nProblems where spectral radius can be estimated reliably","category":"section"},{"location":"semiimplicit/StabilizedRK/#When-to-use-alternatives","page":"OrdinaryDiffEqStabilizedRK","title":"When to use alternatives","text":"Complex eigenvalue dominated problems: Use implicit methods (BDF, SDIRK, Rosenbrock)\nNon-stiff problems: Use standard explicit methods (Tsit5, Verner)","category":"section"},{"location":"semiimplicit/StabilizedRK/#Usage-Considerations","page":"OrdinaryDiffEqStabilizedRK","title":"Usage Considerations","text":"Spectral radius estimation is crucial for performance\nMethod efficiency depends on stiffness ratio\nTest against implicit methods for highly stiff problems\nConsider adaptive spectral radius estimation for varying stiffness\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqStabilizedRK\", \"ROCK4\")","category":"section"},{"location":"semiimplicit/StabilizedRK/#Full-list-of-solvers","page":"OrdinaryDiffEqStabilizedRK","title":"Full list of solvers","text":"","category":"section"},{"location":"semiimplicit/StabilizedRK/#OrdinaryDiffEqStabilizedRK.ROCK2","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK.ROCK2","text":"ROCK2(; min_stages = 0,\n        max_stages = 200,\n        eigen_est = nothing)\n\nStabilized Explicit Method. High stability for real eigenvalues. Second order method. Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.\n\nKeyword Arguments\n\nmin_stages: The minimum degree of the Chebyshev polynomial.\nmax_stages: The maximumdegree of the Chebyshev polynomial.\neigen_est: function of the form   (integrator) -> integrator.eigen_est = upper_bound,   where upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.   If eigen_est is not provided, upper_bound will be estimated using the power iteration.\n\nReferences\n\nAssyr Abdulle, Alexei A. Medovikov. Second Order Chebyshev Methods based on Orthogonal Polynomials. Numerische Mathematik, 90 (1), pp 1-18, 2001. doi: https://dx.doi.org/10.1007/s002110100292\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/StabilizedRK/#OrdinaryDiffEqStabilizedRK.ROCK4","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK.ROCK4","text":"ROCK4(; min_stages = 0,\n        max_stages = 152,\n        eigen_est = nothing)\n\nStabilized Explicit Method. High stability for real eigenvalues. Fourth order method. Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.\n\nKeyword Arguments\n\nmin_stages: The minimum degree of the Chebyshev polynomial.\nmax_stages: The maximumdegree of the Chebyshev polynomial.\neigen_est: function of the form   (integrator) -> integrator.eigen_est = upper_bound,   where upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.   If eigen_est is not provided, upper_bound will be estimated using the power iteration.\n\nReferences\n\nAssyr Abdulle. Fourth Order Chebyshev Methods With Recurrence Relation. 2002 Society for Industrial and Applied Mathematics Journal on Scientific Computing, 23(6), pp 2041-2054, 2001. doi: https://doi.org/10.1137/S1064827500379549\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/StabilizedRK/#OrdinaryDiffEqStabilizedRK.RKC","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK.RKC","text":"RKC(; eigen_est = nothing)\n\nStabilized Explicit Method. Second order method. Exhibits high stability for real eigenvalues.\n\nKeyword Arguments\n\neigen_est: function of the form   (integrator) -> integrator.eigen_est = upper_bound,   where upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.   If eigen_est is not provided, upper_bound will be estimated using the power iteration.\n\nReferences\n\nB. P. Sommeijer, L. F. Shampine, J. G. Verwer. RKC: An Explicit Solver for Parabolic PDEs, Journal of Computational and Applied Mathematics, 88(2), pp 315-326, 1998. doi: https://doi.org/10.1016/S0377-0427(97)00219-7\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/StabilizedRK/#OrdinaryDiffEqStabilizedRK.SERK2","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK.SERK2","text":"SERK2(; controller = :PI\n        eigen_est = nothing)\n\nStabilized Explicit Method. Second order method.\n\nKeyword Arguments\n\ncontroller: TBD\neigen_est: function of the form   (integrator) -> integrator.eigen_est = upper_bound,   where upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.   If eigen_est is not provided, upper_bound will be estimated using the power iteration.\n\nReferences\n\n@article{kleefeld2013serk2v2, title={SERK2v2: A new second-order stabilized explicit Runge-Kutta method for stiff problems}, author={Kleefeld, B and Martin-Vaquero, J}, journal={Numerical Methods for Partial Differential Equations}, volume={29}, number={1}, pages={170–185}, year={2013}, publisher={Wiley Online Library}}\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/StabilizedRK/#OrdinaryDiffEqStabilizedRK.ESERK4","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK.ESERK4","text":"ESERK4(; eigen_est = nothing)\n\nStabilized Explicit Method. Fourth order method. Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.\n\nKeyword Arguments\n\neigen_est: function of the form   (integrator) -> integrator.eigen_est = upper_bound,   where upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.   If eigen_est is not provided, upper_bound will be estimated using the power iteration.\n\nReferences\n\nJ. Martín-Vaquero, B. Kleefeld. Extrapolated stabilized explicit Runge-Kutta methods, Journal of Computational Physics, 326, pp 141-155, 2016. doi: https://doi.org/10.1016/j.jcp.2016.08.042.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/StabilizedRK/#OrdinaryDiffEqStabilizedRK.ESERK5","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK.ESERK5","text":"ESERK5(; eigen_est = nothing)\n\nStabilized Explicit Method. Fifth order method. Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.\n\nKeyword Arguments\n\neigen_est: function of the form   (integrator) -> integrator.eigen_est = upper_bound,   where upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.   If eigen_est is not provided, upper_bound will be estimated using the power iteration.\n\nReferences\n\nJ. Martín-Vaquero, A. Kleefeld. ESERK5: A fifth-order extrapolated stabilized explicit Runge-Kutta method, Journal of Computational and Applied Mathematics, 356, pp 22-36, 2019. doi: https://doi.org/10.1016/j.cam.2019.01.040.\n\n\n\n\n\n","category":"type"},{"location":"misc/#Miscellaneous-Solvers","page":"Miscellaneous Solvers","title":"Miscellaneous Solvers","text":"These are solvers that do not fall clearly into any of the major categories.","category":"section"},{"location":"misc/#OrdinaryDiffEqLowOrderRK.SplitEuler","page":"Miscellaneous Solvers","title":"OrdinaryDiffEqLowOrderRK.SplitEuler","text":"SplitEuler()\n\nSplit Method. 1st order fully explicit method for testing split accuracy\n\nKeyword Arguments\n\nReferences\n\n\n\n\n\n","category":"type"},{"location":"misc/#OrdinaryDiffEqExplicitRK.ExplicitRK","page":"Miscellaneous Solvers","title":"OrdinaryDiffEqExplicitRK.ExplicitRK","text":"ExplicitRK(; tableau = ODE_DEFAULT_TABLEAU)\n\nA generic explicit Runge-Kutta method that allows you to define a custom tableau. The default tableau is Dormand-Prince 4/5. This solver is primarily for research purposes or when you need a specific tableau not already implemented.\n\nParameters\n\ntableau: A DiffEqBase.ExplicitRKTableau object defining the Runge-Kutta tableau.\n\nFor most applications, prefer the named methods like DP5(), Tsit5(), etc.\n\n\n\n\n\n","category":"type"},{"location":"explicit/Tsit5/#OrdinaryDiffEqTsit5","page":"OrdinaryDiffEqTsit5","title":"OrdinaryDiffEqTsit5","text":"The Tsitouras 5/4 method is the recommended default solver for most non-stiff differential equation problems. This method provides an excellent balance of efficiency, reliability, and accuracy.","category":"section"},{"location":"explicit/Tsit5/#Key-Properties","page":"OrdinaryDiffEqTsit5","title":"Key Properties","text":"Tsit5 offers:\n\nFifth-order accuracy with embedded fourth-order error estimation\nExcellent efficiency at default tolerances (1e-6 to 1e-3)\nFSAL (First Same As Last) property for computational efficiency\nHigh-quality interpolation for dense output\nRobust performance across a wide range of problem types\nOptimized coefficients for minimal error in practical applications","category":"section"},{"location":"explicit/Tsit5/#When-to-Use-Tsit5","page":"OrdinaryDiffEqTsit5","title":"When to Use Tsit5","text":"Tsit5 is recommended for:\n\nMost non-stiff problems as the first choice solver\nDefault and higher tolerances (1e-3 to 1e-6)\nGeneral-purpose integration when problem characteristics are unknown\nEducational and research applications as a reliable baseline\nReal-time applications requiring predictable performance\nProblems where simplicity and reliability are preferred over maximum efficiency","category":"section"},{"location":"explicit/Tsit5/#Solver-Selection-Guide","page":"OrdinaryDiffEqTsit5","title":"Solver Selection Guide","text":"","category":"section"},{"location":"explicit/Tsit5/#Primary-recommendation","page":"OrdinaryDiffEqTsit5","title":"Primary recommendation","text":"Tsit5: Use as the default choice for non-stiff problems at standard tolerances","category":"section"},{"location":"explicit/Tsit5/#Automatic-switching","page":"OrdinaryDiffEqTsit5","title":"Automatic switching","text":"AutoTsit5: Automatically switches to a stiff solver when stiffness is detected, making it robust for problems of unknown character","category":"section"},{"location":"explicit/Tsit5/#When-to-Consider-Alternatives","page":"OrdinaryDiffEqTsit5","title":"When to Consider Alternatives","text":"Consider other solvers when:\n\nHigher accuracy needed: Use Verner methods (Vern6, Vern7, Vern8, Vern9) for tolerances below 1e-6\nHigher tolerances: Use BS3 or OwrenZen3 for tolerances above 1e-3\nRobust error control needed: Use BS5 when Tsit5 struggles with error estimation\nEquation is stiff: Use implicit methods (SDIRK, BDF) or semi-implicit methods (Rosenbrock) for stiff problems\nSpecial properties required: Use specialized methods (SSP, symplectic, etc.) for specific problem types\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqTsit5\", \"Tsit5\")","category":"section"},{"location":"explicit/Tsit5/#Full-list-of-solvers","page":"OrdinaryDiffEqTsit5","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/Tsit5/#OrdinaryDiffEqTsit5.Tsit5","page":"OrdinaryDiffEqTsit5","title":"OrdinaryDiffEqTsit5.Tsit5","text":"Tsit5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Tsitouras 5/4 Runge-Kutta method. (free 4th order interpolant). Recommended for most non-stiff problems. Good default choice for unknown stiffness. Highly efficient and generic. Very good performance for most non-stiff ODEs. Recommended as default method for unknown stiffness problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{tsitouras2011runge,     title={Runge–Kutta pairs of order 5 (4) satisfying only the first column simplifying assumption},     author={Tsitouras, Ch},     journal={Computers \\& Mathematics with Applications},     volume={62},     number={2},     pages={770–775},     year={2011},     publisher={Elsevier},     doi={10.1016/j.camwa.2011.06.002}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/Tsit5/#OrdinaryDiffEqTsit5.AutoTsit5","page":"OrdinaryDiffEqTsit5","title":"OrdinaryDiffEqTsit5.AutoTsit5","text":"Automatic switching algorithm that can switch between the (non-stiff) Tsit5() and stiff_alg.\n\nAutoTsit5(stiff_alg; kwargs...)\n\nThis method is equivalent to AutoAlgSwitch(Tsit5(), stiff_alg; kwargs...). To gain access to stiff algorithms you might have to install additional libraries, such as OrdinaryDiffEqRosenbrock.\n\n\n\n\n\n","category":"function"},{"location":"implicit/Nordsieck/#OrdinaryDiffEqNordsieck","page":"OrdinaryDiffEqNordsieck","title":"OrdinaryDiffEqNordsieck","text":"Nordsieck form multistep methods represent an alternative approach to traditional multistep algorithms. Instead of storing past solution values, these methods maintain a vector of scaled derivatives (similar to Taylor series coefficients) to advance the solution. This representation was pioneered in classic codes like LSODE, VODE, and CVODE.\n\nwarning: Research and Development\nThese methods are currently in research and development and not intended for general use.","category":"section"},{"location":"implicit/Nordsieck/#Key-Properties","page":"OrdinaryDiffEqNordsieck","title":"Key Properties","text":"Nordsieck methods provide:\n\nDerivative-based representation instead of solution history\nImproved restartability after discontinuities using derivative information\nVariable order and stepsize capabilities\nAlternative to history-based multistep methods\nResearch and experimental implementations","category":"section"},{"location":"implicit/Nordsieck/#When-to-Use-Nordsieck-Methods","page":"OrdinaryDiffEqNordsieck","title":"When to Use Nordsieck Methods","text":"These methods are recommended for:\n\nResearch applications exploring alternative multistep representations\nProblems with discontinuities where restartability is important\nExperimental comparisons with traditional multistep methods\nDevelopment of discontinuity-aware algorithms","category":"section"},{"location":"implicit/Nordsieck/#Important-Limitations","page":"OrdinaryDiffEqNordsieck","title":"Important Limitations","text":"","category":"section"},{"location":"implicit/Nordsieck/#Experimental-Status","page":"OrdinaryDiffEqNordsieck","title":"Experimental Status","text":"Considered experimental and inferior to modern BDF implementations\nGenerally recommend FBDF instead for production use\nMaintained for research purposes and future development\nNumerical instabilities can arise from higher derivative representations","category":"section"},{"location":"implicit/Nordsieck/#Performance-Considerations","page":"OrdinaryDiffEqNordsieck","title":"Performance Considerations","text":"Less robust than fixed-leading coefficient BDF methods\nHigher computational overhead for derivative maintenance\nPotential stability issues with derivative representations","category":"section"},{"location":"implicit/Nordsieck/#Mathematical-Background","page":"OrdinaryDiffEqNordsieck","title":"Mathematical Background","text":"The Nordsieck form represents the solution using scaled derivatives: y_n = [y, h*y', h²*y''/2!, h³*y'''/3!, ...]\n\nThis representation allows reconstruction of the solution and its derivatives, enabling restarts after discontinuities without losing accuracy.","category":"section"},{"location":"implicit/Nordsieck/#Solver-Selection-Guide","page":"OrdinaryDiffEqNordsieck","title":"Solver Selection Guide","text":"","category":"section"},{"location":"implicit/Nordsieck/#Nordsieck-implementations","page":"OrdinaryDiffEqNordsieck","title":"Nordsieck implementations","text":"AN5: Fifth-order Adams method with fixed leading coefficient\nJVODE: Variable order Adams/BDF method (experimental LSODE-style)\nJVODE_Adams: JVODE configured for Adams methods\nJVODE_BDF: JVODE configured for BDF methods","category":"section"},{"location":"implicit/Nordsieck/#Recommended-alternatives","page":"OrdinaryDiffEqNordsieck","title":"Recommended alternatives","text":"For most applications: Use QNDF or FBDF instead\nFor stiff problems: Prefer modern BDF implementations\nFor research: These methods are appropriate for experimental work","category":"section"},{"location":"implicit/Nordsieck/#Research-and-Development","page":"OrdinaryDiffEqNordsieck","title":"Research and Development","text":"These implementations serve as:\n\nExperimental testbed for Nordsieck form algorithms\nResearch platform for discontinuity-aware methods\nDevelopment basis for future improved BDF implementations\nEducational examples of alternative multistep representations","category":"section"},{"location":"implicit/Nordsieck/#Usage-Guidelines","page":"OrdinaryDiffEqNordsieck","title":"Usage Guidelines","text":"Not recommended for production applications\nUse FBDF or QNDF for reliable multistep integration\nConsider these methods only for research or experimental purposes\nExpect potentially lower performance compared to modern alternatives\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqNordsieck\", \"AN5\")","category":"section"},{"location":"implicit/Nordsieck/#Full-list-of-solvers","page":"OrdinaryDiffEqNordsieck","title":"Full list of solvers","text":"","category":"section"},{"location":"implicit/Nordsieck/#OrdinaryDiffEqNordsieck.AN5","page":"OrdinaryDiffEqNordsieck","title":"OrdinaryDiffEqNordsieck.AN5","text":"AN5()\n\nAdaptive step size Adams explicit Method An adaptive 5th order fixed-leading coefficient Adams method in Nordsieck form.\n\nwarning: Experimental\nAN5 is experimental, the solver VCABM is generally preferred.\n\nKeyword Arguments\n\nReferences\n\n\n\n\n\n","category":"type"},{"location":"implicit/Nordsieck/#OrdinaryDiffEqNordsieck.JVODE","page":"OrdinaryDiffEqNordsieck","title":"OrdinaryDiffEqNordsieck.JVODE","text":"warning: Experimental\nJVODE is experimental, the solver VCABM is generally preferred.\n\n\n\n\n\n","category":"type"},{"location":"implicit/Nordsieck/#OrdinaryDiffEqNordsieck.JVODE_Adams","page":"OrdinaryDiffEqNordsieck","title":"OrdinaryDiffEqNordsieck.JVODE_Adams","text":"warning: Experimental\nJVODE is experimental, the solver VCABM is generally preferred.\n\n\n\n\n\n","category":"function"},{"location":"implicit/Nordsieck/#OrdinaryDiffEqNordsieck.JVODE_BDF","page":"OrdinaryDiffEqNordsieck","title":"OrdinaryDiffEqNordsieck.JVODE_BDF","text":"warning: Experimental\nJVODE is experimental, the solver FBDF is generally preferred.\n\n\n\n\n\n","category":"function"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"BDF (Backward Differentiation Formula) methods for mass matrix differential-algebraic equations (DAEs) and stiff ODEs with singular mass matrices. These methods provide robust, high-order integration for systems with algebraic constraints and mixed differential-algebraic structure.","category":"section"},{"location":"massmatrixdae/BDF/#Key-Properties","page":"OrdinaryDiffEqBDF","title":"Key Properties","text":"Mass matrix BDF methods provide:\n\nDAE capability for index-1 differential-algebraic equations\nMass matrix support for singular and non-diagonal mass matrices\nHigh-order accuracy up to 5th order with good stability\nL-stable behavior for stiff problems with excellent damping\nAutomatic differentiation for efficient Jacobian computation\nVariable order and stepsize adaptation for efficiency","category":"section"},{"location":"massmatrixdae/BDF/#When-to-Use-Mass-Matrix-BDF-Methods","page":"OrdinaryDiffEqBDF","title":"When to Use Mass Matrix BDF Methods","text":"These methods are recommended for:\n\nDifferential-algebraic equations (DAEs) with index-1 structure\nConstrained mechanical systems with holonomic constraints\nElectrical circuit simulation with algebraic loop equations\nChemical reaction networks with conservation constraints\nMultibody dynamics with kinematic constraints\nSemi-explicit DAEs arising from spatial discretizations","category":"section"},{"location":"massmatrixdae/BDF/#Mathematical-Background","page":"OrdinaryDiffEqBDF","title":"Mathematical Background","text":"Mass matrix DAEs have the form: M du/dt = f(u,t)\n\nwhere M is a potentially singular mass matrix. When M is singular, some equations become algebraic constraints rather than differential equations, leading to a DAE system.","category":"section"},{"location":"massmatrixdae/BDF/#Problem-Formulation","page":"OrdinaryDiffEqBDF","title":"Problem Formulation","text":"Use ODEFunction with a mass_matrix:\n\nusing LinearAlgebra: Diagonal\nfunction rober(du, u, p, t)\n    y₁, y₂, y₃ = u\n    k₁, k₂, k₃ = p\n    du[1] = -k₁ * y₁ + k₃ * y₂ * y₃\n    du[2] = k₁ * y₁ - k₃ * y₂ * y₃ - k₂ * y₂^2\n    du[3] = y₁ + y₂ + y₃ - 1\n    nothing\nend\nM = Diagonal([1.0, 1.0, 0])  # Singular mass matrix\nf = ODEFunction(rober, mass_matrix = M)\nprob_mm = ODEProblem(f, [1.0, 0.0, 0.0], (0.0, 1e5), (0.04, 3e7, 1e4))\nsol = solve(prob_mm, FBDF(), reltol = 1e-8, abstol = 1e-8)","category":"section"},{"location":"massmatrixdae/BDF/#Solver-Selection-Guide","page":"OrdinaryDiffEqBDF","title":"Solver Selection Guide","text":"","category":"section"},{"location":"massmatrixdae/BDF/#Recommended-Methods","page":"OrdinaryDiffEqBDF","title":"Recommended Methods","text":"FBDF: Recommended - Fixed leading coefficient BDF with excellent stability\nQNDF: Quasi-constant stepsize Nordsieck BDF with good efficiency\nQBDF: Alternative quasi-constant stepsize BDF formulation","category":"section"},{"location":"massmatrixdae/BDF/#Specific-order-methods","page":"OrdinaryDiffEqBDF","title":"Specific order methods","text":"QNDF1: First-order method for simple problems\nQNDF2: Second-order method balancing accuracy and stability\nQBDF1, QBDF2: Alternative second-order formulations\nABDF2: Adams-type BDF for specific applications\nMEBDF2: Modified extended BDF for enhanced stability","category":"section"},{"location":"massmatrixdae/BDF/#Performance-Guidelines","page":"OrdinaryDiffEqBDF","title":"Performance Guidelines","text":"","category":"section"},{"location":"massmatrixdae/BDF/#When-mass-matrix-BDF-methods-excel","page":"OrdinaryDiffEqBDF","title":"When mass matrix BDF methods excel","text":"Index-1 DAE systems with well-separated differential and algebraic variables\nLarge stiff systems with algebraic constraints\nProblems with conservation laws naturally expressed as constraints\nMultiphysics simulations combining differential and algebraic equations\nSystems where constraints are essential to the physics","category":"section"},{"location":"massmatrixdae/BDF/#Mass-matrix-considerations","page":"OrdinaryDiffEqBDF","title":"Mass matrix considerations","text":"Singular mass matrices require consistent initial conditions\nIndex determination affects solver performance and stability\nConstraint violations may accumulate and require projection\nWell-conditioned problems generally perform better","category":"section"},{"location":"massmatrixdae/BDF/#Important-Considerations","page":"OrdinaryDiffEqBDF","title":"Important Considerations","text":"","category":"section"},{"location":"massmatrixdae/BDF/#Initial-conditions","page":"OrdinaryDiffEqBDF","title":"Initial conditions","text":"Must be consistent with algebraic constraints\nUse initialization procedures if constraints are not satisfied initially\nIndex-1 assumption requires that constraints uniquely determine algebraic variables","category":"section"},{"location":"massmatrixdae/BDF/#Numerical-challenges","page":"OrdinaryDiffEqBDF","title":"Numerical challenges","text":"Constraint drift may occur over long integrations\nIndex higher than 1 not directly supported\nIll-conditioned mass matrices can cause numerical difficulties\nDiscontinuities in constraints require special handling","category":"section"},{"location":"massmatrixdae/BDF/#Alternative-Approaches","page":"OrdinaryDiffEqBDF","title":"Alternative Approaches","text":"Consider these alternatives:\n\nImplicit Runge-Kutta methods for higher accuracy requirements\nRosenbrock methods for moderately stiff DAEs\nProjection methods for constraint preservation\nIndex reduction techniques for higher-index DAEs\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqBDF\", \"FBDF\")","category":"section"},{"location":"massmatrixdae/BDF/#Full-list-of-solvers","page":"OrdinaryDiffEqBDF","title":"Full list of solvers","text":"","category":"section"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.ABDF2-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.ABDF2","text":"ABDF2(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        κ = nothing,\n        tol = nothing,\n        nlsolve = NLNewton(),\n        smooth_est = true,\n        extrapolant = :linear,\n        controller = :Standard,\n        step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order 2 L-stable fixed leading coefficient multistep BDF method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ABDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- κ: TBD\ntol: TBD\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nE. Alberdi Celayaa, J. J. Anza Aguirrezabalab, P. Chatzipantelidisc. Implementation of an Adaptive BDF2 Formula and Comparison with The MATLAB Ode15s. Procedia Computer Science, 29, pp 1014-1026, 2014. doi: https://doi.org/10.1016/j.procs.2014.05.091\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.QNDF-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QNDF","text":"QNDF(; chunk_size = Val{0}(),\n       autodiff = AutoForwardDiff(),\n       standardtag = Val{true}(),\n       concrete_jac = nothing,\n       linsolve = nothing,\n       precs = DEFAULT_PRECS,\n       κ = nothing,\n       tol = nothing,\n       nlsolve = NLNewton(),\n       extrapolant = :linear,\n       kappa =  promote(-0.1850, -1 // 9, -0.0823, -0.0415, 0),\n       controller = :Standard,\n       step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order quasi-constant timestep NDF method. Similar to MATLAB's ode15s. Uses Shampine's accuracy-optimal coefficients. Performance improves with larger, more complex ODEs. Good for medium to highly stiff problems. Recommended for large systems (>1000 ODEs).\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify QNDF(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- κ: TBD\ntol: TBD\nnlsolve: TBD\nextrapolant: TBD\nkappa: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{shampine1997matlab, title={The matlab ode suite}, author={Shampine, Lawrence F and Reichelt, Mark W}, journal={SIAM journal on scientific computing}, volume={18}, number={1}, pages={1–22}, year={1997}, publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.QNDF1-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QNDF1","text":"QNDF1(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        nlsolve = NLNewton(),\n        extrapolant = :linear,\n        kappa = -0.1850,\n        controller = :Standard,\n        step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order 1 quasi-constant timestep L-stable numerical differentiation function method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify QNDF1(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\nkappa: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{shampine1997matlab, title={The matlab ode suite}, author={Shampine, Lawrence F and Reichelt, Mark W}, journal={SIAM journal on scientific computing}, volume={18}, number={1}, pages={1–22}, year={1997}, publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.QNDF2-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QNDF2","text":"QNDF2(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        nlsolve = NLNewton(),\n        extrapolant = :linear,\n        kappa =  -1 // 9,\n        controller = :Standard,\n        step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order 2 quasi-constant timestep L-stable numerical differentiation function (NDF) method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify QNDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\nkappa: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{shampine1997matlab, title={The matlab ode suite}, author={Shampine, Lawrence F and Reichelt, Mark W}, journal={SIAM journal on scientific computing}, volume={18}, number={1}, pages={1–22}, year={1997}, publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.QBDF-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QBDF","text":"QBDF: Multistep Method\n\nAn alias of QNDF with κ=0.\n\n\n\n\n\n","category":"function"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.QBDF1-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QBDF1","text":"QBDF1: Multistep Method\n\nAn alias of QNDF1 with κ=0.\n\n\n\n\n\n","category":"function"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.QBDF2-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QBDF2","text":"QBDF2: Multistep Method\n\nAn alias of QNDF2 with κ=0.\n\n\n\n\n\n","category":"function"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.MEBDF2-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.MEBDF2","text":"MEBDF2(; chunk_size = Val{0}(),\n         autodiff = AutoForwardDiff(),\n         standardtag = Val{true}(),\n         concrete_jac = nothing,\n         linsolve = nothing,\n         precs = DEFAULT_PRECS,\n         nlsolve = NLNewton(),\n         extrapolant = :constant)\n\nMultistep Method. The second order Modified Extended BDF method,     which has improved stability properties over the standard BDF.     Fixed timestep only.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify MEBDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{cash2000modified, title={Modified extended backward differentiation formulae for the numerical solution of stiff initial value problems in ODEs and DAEs}, author={Cash, JR}, journal={Journal of Computational and Applied Mathematics}, volume={125}, number={1-2}, pages={117–130}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.FBDF-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.FBDF","text":"FBDF(; chunk_size = Val{0}(),\n       autodiff = AutoForwardDiff(),\n       standardtag = Val{true}(),\n       concrete_jac = nothing,\n       linsolve = nothing,\n       precs = DEFAULT_PRECS,\n       κ = nothing,\n       tol = nothing,\n       nlsolve = NLNewton(),\n       extrapolant = :linear,\n       controller = :Standard,\n       step_limiter! = trivial_limiter!,\n       max_order::Val{MO} = Val{5}())\n\nMultistep Method. An adaptive order quasi-constant timestep NDF method. Fixed leading coefficient BDF. Utilizes Shampine's accuracy-optimal kappa values as defaults (has a keyword argument for a tuple of kappa coefficients).\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify FBDF(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- κ: TBD\ntol: TBD\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nmax_order: TBD\n\nReferences\n\n@article{shampine2002solving, title={Solving 0= F (t, y (t), y′(t)) in Matlab}, author={Shampine, Lawrence F}, year={2002}, publisher={Walter de Gruyter GmbH \\& Co. KG}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"Backward Differentiation Formula (BDF) methods are multistep implicit methods specifically designed for solving large stiff systems of differential equations. They are the preferred choice for very large systems (>1000 equations) where other implicit methods become computationally expensive.","category":"section"},{"location":"implicit/BDF/#Key-Properties","page":"OrdinaryDiffEqBDF","title":"Key Properties","text":"BDF methods offer:\n\nExcellent efficiency for large systems (>1000 ODEs)\nL-stable behavior for orders 1 and 2 only\nAdaptive order and stepsize control for optimal performance\nAlpha-stability for higher orders (but less stable than L-stable methods for problems with large complex eigenvalues)","category":"section"},{"location":"implicit/BDF/#When-to-Use-BDF-Methods","page":"OrdinaryDiffEqBDF","title":"When to Use BDF Methods","text":"BDF methods are recommended for:\n\nLarge stiff systems with more than 1000 equations\nVery stiff problems where other implicit methods struggle\nLong-time integration of stiff systems\nParabolic PDEs after spatial discretization\nReaction-diffusion systems and chemical kinetics\nCircuit simulation and other engineering applications with large stiff systems","category":"section"},{"location":"implicit/BDF/#Solver-Selection-Guide","page":"OrdinaryDiffEqBDF","title":"Solver Selection Guide","text":"","category":"section"},{"location":"implicit/BDF/#Recommended-methods","page":"OrdinaryDiffEqBDF","title":"Recommended methods","text":"QNDF: Adaptive order quasi-constant timestep BDF, best general choice for large systems\nFBDF: Fixed-leading coefficient BDF, often more efficient than QNDF","category":"section"},{"location":"implicit/BDF/#Performance-Characteristics","page":"OrdinaryDiffEqBDF","title":"Performance Characteristics","text":"Most efficient for systems with >1000 equations\nOutperform Runge-Kutta methods on very large stiff systems\nMemory efficient due to multistep structure\nExcel at very low tolerances (1e-9 and below)\nParticularly effective for problems arising from PDE discretizations","category":"section"},{"location":"implicit/BDF/#Comparison-with-Other-Methods","page":"OrdinaryDiffEqBDF","title":"Comparison with Other Methods","text":"Choose BDF methods over:\n\nRosenbrock methods: When system size > 1000 equations\nSDIRK methods: For very large stiff systems where RK methods become expensive\nExplicit methods: For any stiff problem\n\nChoose other methods over BDF when:\n\nSystem size < 100: Rosenbrock or SDIRK methods often more efficient\nProblems with large complex eigenvalues: Rosenbrock and L-stable SDIRK methods are more stable due to BDF methods only being alpha-stable\nModerate stiffness: SDIRK methods may be more robust\nNon-stiff problems: Use explicit methods like Tsit5\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqBDF\", \"QNDF\")","category":"section"},{"location":"implicit/BDF/#Full-list-of-solvers","page":"OrdinaryDiffEqBDF","title":"Full list of solvers","text":"","category":"section"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.ABDF2","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.ABDF2","text":"ABDF2(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        κ = nothing,\n        tol = nothing,\n        nlsolve = NLNewton(),\n        smooth_est = true,\n        extrapolant = :linear,\n        controller = :Standard,\n        step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order 2 L-stable fixed leading coefficient multistep BDF method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ABDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- κ: TBD\ntol: TBD\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nE. Alberdi Celayaa, J. J. Anza Aguirrezabalab, P. Chatzipantelidisc. Implementation of an Adaptive BDF2 Formula and Comparison with The MATLAB Ode15s. Procedia Computer Science, 29, pp 1014-1026, 2014. doi: https://doi.org/10.1016/j.procs.2014.05.091\n\n\n\n\n\n","category":"type"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.QNDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QNDF","text":"QNDF(; chunk_size = Val{0}(),\n       autodiff = AutoForwardDiff(),\n       standardtag = Val{true}(),\n       concrete_jac = nothing,\n       linsolve = nothing,\n       precs = DEFAULT_PRECS,\n       κ = nothing,\n       tol = nothing,\n       nlsolve = NLNewton(),\n       extrapolant = :linear,\n       kappa =  promote(-0.1850, -1 // 9, -0.0823, -0.0415, 0),\n       controller = :Standard,\n       step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order quasi-constant timestep NDF method. Similar to MATLAB's ode15s. Uses Shampine's accuracy-optimal coefficients. Performance improves with larger, more complex ODEs. Good for medium to highly stiff problems. Recommended for large systems (>1000 ODEs).\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify QNDF(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- κ: TBD\ntol: TBD\nnlsolve: TBD\nextrapolant: TBD\nkappa: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{shampine1997matlab, title={The matlab ode suite}, author={Shampine, Lawrence F and Reichelt, Mark W}, journal={SIAM journal on scientific computing}, volume={18}, number={1}, pages={1–22}, year={1997}, publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.QNDF1","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QNDF1","text":"QNDF1(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        nlsolve = NLNewton(),\n        extrapolant = :linear,\n        kappa = -0.1850,\n        controller = :Standard,\n        step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order 1 quasi-constant timestep L-stable numerical differentiation function method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify QNDF1(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\nkappa: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{shampine1997matlab, title={The matlab ode suite}, author={Shampine, Lawrence F and Reichelt, Mark W}, journal={SIAM journal on scientific computing}, volume={18}, number={1}, pages={1–22}, year={1997}, publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.QNDF2","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QNDF2","text":"QNDF2(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        nlsolve = NLNewton(),\n        extrapolant = :linear,\n        kappa =  -1 // 9,\n        controller = :Standard,\n        step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order 2 quasi-constant timestep L-stable numerical differentiation function (NDF) method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify QNDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\nkappa: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{shampine1997matlab, title={The matlab ode suite}, author={Shampine, Lawrence F and Reichelt, Mark W}, journal={SIAM journal on scientific computing}, volume={18}, number={1}, pages={1–22}, year={1997}, publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.QBDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QBDF","text":"QBDF: Multistep Method\n\nAn alias of QNDF with κ=0.\n\n\n\n\n\n","category":"function"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.QBDF1","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QBDF1","text":"QBDF1: Multistep Method\n\nAn alias of QNDF1 with κ=0.\n\n\n\n\n\n","category":"function"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.QBDF2","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QBDF2","text":"QBDF2: Multistep Method\n\nAn alias of QNDF2 with κ=0.\n\n\n\n\n\n","category":"function"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.MEBDF2","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.MEBDF2","text":"MEBDF2(; chunk_size = Val{0}(),\n         autodiff = AutoForwardDiff(),\n         standardtag = Val{true}(),\n         concrete_jac = nothing,\n         linsolve = nothing,\n         precs = DEFAULT_PRECS,\n         nlsolve = NLNewton(),\n         extrapolant = :constant)\n\nMultistep Method. The second order Modified Extended BDF method,     which has improved stability properties over the standard BDF.     Fixed timestep only.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify MEBDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{cash2000modified, title={Modified extended backward differentiation formulae for the numerical solution of stiff initial value problems in ODEs and DAEs}, author={Cash, JR}, journal={Journal of Computational and Applied Mathematics}, volume={125}, number={1-2}, pages={117–130}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.FBDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.FBDF","text":"FBDF(; chunk_size = Val{0}(),\n       autodiff = AutoForwardDiff(),\n       standardtag = Val{true}(),\n       concrete_jac = nothing,\n       linsolve = nothing,\n       precs = DEFAULT_PRECS,\n       κ = nothing,\n       tol = nothing,\n       nlsolve = NLNewton(),\n       extrapolant = :linear,\n       controller = :Standard,\n       step_limiter! = trivial_limiter!,\n       max_order::Val{MO} = Val{5}())\n\nMultistep Method. An adaptive order quasi-constant timestep NDF method. Fixed leading coefficient BDF. Utilizes Shampine's accuracy-optimal kappa values as defaults (has a keyword argument for a tuple of kappa coefficients).\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify FBDF(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- κ: TBD\ntol: TBD\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nmax_order: TBD\n\nReferences\n\n@article{shampine2002solving, title={Solving 0= F (t, y (t), y′(t)) in Matlab}, author={Shampine, Lawrence F}, year={2002}, publisher={Walter de Gruyter GmbH \\& Co. KG}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/HighOrderRK/#OrdinaryDiffEqHighOrderRK","page":"OrdinaryDiffEqHighOrderRK","title":"OrdinaryDiffEqHighOrderRK","text":"High-order explicit Runge-Kutta methods for non-stiff differential equations requiring high accuracy. These methods provide alternatives to the Verner methods, though OrdinaryDiffEqVerner methods generally perform better at low tolerances and should be preferred in most cases.","category":"section"},{"location":"explicit/HighOrderRK/#Key-Properties","page":"OrdinaryDiffEqHighOrderRK","title":"Key Properties","text":"High-order RK methods provide:\n\nHigh-order accuracy (7th and 8th order) for precise integration\nSpecialized coefficients for specific problem types\nDense output capabilities for some methods\nAlternative approaches to the more commonly used Verner methods","category":"section"},{"location":"explicit/HighOrderRK/#When-to-Use-High-Order-RK-Methods","page":"OrdinaryDiffEqHighOrderRK","title":"When to Use High-Order RK Methods","text":"These methods are recommended when:\n\nVerner methods are not suitable for specific problem characteristics\nSpecialized properties are needed (e.g., phase-fitted methods for oscillatory problems)\nResearch or comparison purposes require different high-order method families\nSpecific applications benefit from particular method properties","category":"section"},{"location":"explicit/HighOrderRK/#Solver-Selection-Guide","page":"OrdinaryDiffEqHighOrderRK","title":"Solver Selection Guide","text":"","category":"section"},{"location":"explicit/HighOrderRK/#General-high-order-integration","page":"OrdinaryDiffEqHighOrderRK","title":"General high-order integration","text":"Use Vern7 or Vern8 instead - they are generally more efficient","category":"section"},{"location":"explicit/HighOrderRK/#Specialized-cases-where-these-methods-may-be-preferred","page":"OrdinaryDiffEqHighOrderRK","title":"Specialized cases where these methods may be preferred","text":"TanYam7: Seventh-order Tanaka-Yamashita method\nTsitPap8: Eighth-order Tsitouras-Papakostas method\nDP8: Eighth-order Dormand-Prince method (Hairer's 8/5/3 implementation)\nPFRK87: Phase-fitted eighth-order method for oscillatory problems","category":"section"},{"location":"explicit/HighOrderRK/#Performance-Notes","page":"OrdinaryDiffEqHighOrderRK","title":"Performance Notes","text":"Verner methods are generally more efficient for most high-accuracy applications\nThese methods are provided for specialized use cases and research purposes\nConsider problem-specific properties when choosing between different high-order families\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqHighOrderRK\", \"DP8\")","category":"section"},{"location":"explicit/HighOrderRK/#Full-list-of-solvers","page":"OrdinaryDiffEqHighOrderRK","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/HighOrderRK/#OrdinaryDiffEqHighOrderRK.TanYam7","page":"OrdinaryDiffEqHighOrderRK","title":"OrdinaryDiffEqHighOrderRK.TanYam7","text":"TanYam7(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Tanaka-Yamashita 7 Runge-Kutta method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nTanaka M., Muramatsu S., Yamashita S., (1992), On the Optimization of Some Nine-Stage     Seventh-order Runge-Kutta Method, Information Processing Society of Japan,     33 (12), pp. 1512-1526.\n\n\n\n\n\n","category":"type"},{"location":"explicit/HighOrderRK/#OrdinaryDiffEqHighOrderRK.TsitPap8","page":"OrdinaryDiffEqHighOrderRK","title":"OrdinaryDiffEqHighOrderRK.TsitPap8","text":"TsitPap8(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Tsitouras-Papakostas 8/7 Runge-Kutta method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{tsitouras1999cheap, title={Cheap error estimation for Runge–Kutta methods}, author={Tsitouras, Ch and Papakostas, SN}, journal={SIAM Journal on Scientific Computing}, volume={20}, number={6}, pages={2067–2088}, year={1999}, publisher={SIAM}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/HighOrderRK/#OrdinaryDiffEqHighOrderRK.DP8","page":"OrdinaryDiffEqHighOrderRK","title":"OrdinaryDiffEqHighOrderRK.DP8","text":"DP8(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Hairer's 8/5/3 adaption of the Dormand-Prince Runge-Kutta method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I.     Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics,     Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"explicit/HighOrderRK/#OrdinaryDiffEqHighOrderRK.PFRK87","page":"OrdinaryDiffEqHighOrderRK","title":"OrdinaryDiffEqHighOrderRK.PFRK87","text":"PFRK87(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False(),\n         omega = 0.0)\n\nExplicit Runge-Kutta Method.  Phase-fitted Runge-Kutta of 8th order.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nomega: a periodicity phase estimate,              when accurate this method results in zero numerical dissipation.\n\nReferences\n\n@article{tsitouras2017phase, title={Phase-fitted Runge–Kutta pairs of orders 8 (7)}, author={Tsitouras, Ch and Famelis, I Th and Simos, TE}, journal={Journal of Computational and Applied Mathematics}, volume={321}, pages={226–231}, year={2017}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK","text":"Singly Diagonally Implicit Runge-Kutta (SDIRK) methods are a family of implicit Runge-Kutta methods designed for solving stiff ordinary differential equations. These methods are particularly effective for problems where explicit methods become unstable due to stiffness.","category":"section"},{"location":"implicit/SDIRK/#Key-Properties","page":"OrdinaryDiffEqSDIRK","title":"Key Properties","text":"SDIRK methods have several important characteristics:\n\nA-stable and L-stable: Can handle highly stiff problems without numerical instability\nStiffly accurate: Many SDIRK methods provide additional numerical stability for stiff problems\nDiagonally implicit structure: The implicit system only requires solving a sequence of nonlinear equations rather than a large coupled system\nGood for moderate to large systems: More efficient than fully implicit RK methods for many problems","category":"section"},{"location":"implicit/SDIRK/#When-to-Use-SDIRK-Methods","page":"OrdinaryDiffEqSDIRK","title":"When to Use SDIRK Methods","text":"SDIRK methods are recommended for:\n\nStiff differential equations where explicit methods fail or require very small timesteps\nProblems requiring good stability properties at moderate to high tolerances\nSystems where Rosenbrock methods (which require Jacobians) are not suitable or available\nIMEX problems using the KenCarp family, which can split stiff and non-stiff terms","category":"section"},{"location":"implicit/SDIRK/#Solver-Selection-Guide","page":"OrdinaryDiffEqSDIRK","title":"Solver Selection Guide","text":"","category":"section"},{"location":"implicit/SDIRK/#High-tolerance-(1e-2)","page":"OrdinaryDiffEqSDIRK","title":"High tolerance (>1e-2)","text":"TRBDF2: Second-order A-B-L-S-stable method, good for oscillatory problems","category":"section"},{"location":"implicit/SDIRK/#Medium-tolerance-(1e-8-to-1e-2)","page":"OrdinaryDiffEqSDIRK","title":"Medium tolerance (1e-8 to 1e-2)","text":"KenCarp4: Fourth-order method with excellent stability, good all-around choice\nKenCarp47: Seventh-stage fourth-order method, enhanced stability\nKvaerno4 or Kvaerno5: High-order stiffly accurate methods","category":"section"},{"location":"implicit/SDIRK/#Low-tolerance-(1e-8)","page":"OrdinaryDiffEqSDIRK","title":"Low tolerance (<1e-8)","text":"Kvaerno5: Fifth-order stiffly accurate method for high accuracy\nKenCarp5: Fifth-order method with splitting capabilities","category":"section"},{"location":"implicit/SDIRK/#Special-Cases","page":"OrdinaryDiffEqSDIRK","title":"Special Cases","text":"ImplicitEuler: First-order method, only recommended for problems with discontinuities or when f is not differentiable\nTrapezoid: Second-order symmetric method, reversible but not symplectic. Good for eliminating damping often seen with L-stable methods\nImplicitMidpoint: Second-order A-stable symplectic method for energy-preserving systems\nSSPSDIRK2: Strong stability preserving variant for problems requiring monotonicity preservation\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqSDIRK\", \"KenCarp4\")","category":"section"},{"location":"implicit/SDIRK/#Full-list-of-solvers","page":"OrdinaryDiffEqSDIRK","title":"Full list of solvers","text":"","category":"section"},{"location":"implicit/SDIRK/#IMEX-SDIRK","page":"OrdinaryDiffEqSDIRK","title":"IMEX SDIRK","text":"","category":"section"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.ImplicitEuler","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.ImplicitEuler","text":"ImplicitEuler(; chunk_size = Val{0}(),\n                autodiff = AutoForwardDiff(),\n                standardtag = Val{true}(),\n                concrete_jac = nothing,\n                diff_type = Val{:forward}(),\n                linsolve = nothing,\n                precs = DEFAULT_PRECS,\n                nlsolve = NLNewton(),\n                extrapolant = :constant,\n                controller = :PI,\n                step_limiter! = trivial_limiter!)\n\nSDIRK Method. A 1st order implicit solver. A-B-L-stable. Adaptive timestepping through a divided differences estimate. Strong-stability preserving (SSP). Good for highly stiff equations.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ImplicitEuler(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@book{wanner1996solving,     title={Solving ordinary differential equations II},     author={Wanner, Gerhard and Hairer, Ernst},     volume={375},     year={1996},     publisher={Springer Berlin Heidelberg New York}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.ImplicitMidpoint","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.ImplicitMidpoint","text":"ImplicitMidpoint(; chunk_size = Val{0}(),\n                   autodiff = AutoForwardDiff(),\n                   standardtag = Val{true}(),\n                   concrete_jac = nothing,\n                   diff_type = Val{:forward}(),\n                   linsolve = nothing,\n                   precs = DEFAULT_PRECS,\n                   nlsolve = NLNewton(),\n                   extrapolant = :linear,\n                   step_limiter! = trivial_limiter!)\n\nSDIRK Method. A second order A-stable symplectic and symmetric implicit solver. Excellent for Hamiltonian systems and highly stiff equations.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ImplicitMidpoint(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@book{wanner1996solving,     title={Solving ordinary differential equations II},     author={Wanner, Gerhard and Hairer, Ernst},     volume={375},     year={1996},     publisher={Springer Berlin Heidelberg New York}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.Trapezoid","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.Trapezoid","text":"Trapezoid(; chunk_size = Val{0}(),\n            autodiff = AutoForwardDiff(),\n            standardtag = Val{true}(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS,\n            nlsolve = NLNewton(),\n            extrapolant = :linear,\n            controller = :PI,\n            step_limiter! = trivial_limiter!)\n\nSDIRK Method. A second order A-stable symmetric ESDIRK method. 'Almost symplectic' without numerical dampening.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Trapezoid(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nAndre Vladimirescu. 1994. The Spice Book. John Wiley & Sons, Inc., New York, NY, USA.\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.TRBDF2","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.TRBDF2","text":"TRBDF2(; chunk_size = Val{0}(),\n         autodiff = AutoForwardDiff(),\n         standardtag = Val{true}(),\n         concrete_jac = nothing,\n         diff_type = Val{:forward}(),\n         linsolve = nothing,\n         precs = DEFAULT_PRECS,\n         nlsolve = NLNewton(),\n         smooth_est = true,\n         extrapolant = :linear,\n         controller = :PI,\n         step_limiter! = trivial_limiter!)\n\nSDIRK Method. A second order A-B-L-S-stable one-step ESDIRK method. Includes stiffness-robust error estimates for accurate adaptive timestepping, smoothed derivatives for highly stiff and oscillatory problems. Good for high tolerances (>1e-2) on stiff problems.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify TRBDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{hosea1996analysis,     title={Analysis and implementation of TR-BDF2},     author={Hosea, ME and Shampine, LF},     journal={Applied Numerical Mathematics},     volume={20},     number={1-2},     pages={21–37},     year={1996},     publisher={Elsevier}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SDIRK2","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SDIRK2","text":"SDIRK2(; chunk_size = Val{0}(),\n         autodiff = AutoForwardDiff(),\n         standardtag = Val{true}(),\n         concrete_jac = nothing,\n         diff_type = Val{:forward}(),\n         linsolve = nothing,\n         precs = DEFAULT_PRECS,\n         nlsolve = NLNewton(),\n         smooth_est = true,\n         extrapolant = :linear,\n         controller = :PI,\n         step_limiter! = trivial_limiter!)\n\nSDIRK Method. SDIRK2: SDIRK Method An A-B-L stable 2nd order SDIRK method\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SDIRK2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{hindmarsh2005sundials,     title={{SUNDIALS}: Suite of nonlinear and differential/algebraic equation solvers},     author={Hindmarsh, Alan C and Brown, Peter N and Grant, Keith E and Lee, Steven L and Serban, Radu and Shumaker, Dan E and Woodward, Carol S},     journal={ACM Transactions on Mathematical Software (TOMS)},     volume={31},     number={3},     pages={363–396},     year={2005},     publisher={ACM}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SDIRK22","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SDIRK22","text":"SDIRK22(; chunk_size = Val{0}(),\n          autodiff = AutoForwardDiff(),\n          standardtag = Val{true}(),\n          concrete_jac = nothing,\n          diff_type = Val{:forward}(),\n          linsolve = nothing,\n          precs = DEFAULT_PRECS,\n          nlsolve = NLNewton(),\n          smooth_est = true,\n          extrapolant = :linear,\n          controller = :PI,\n          step_limiter! = trivial_limiter!)\n\nSDIRK Method. Description TBD\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SDIRK22(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@techreport{kennedy2016diagonally,     title={Diagonally implicit Runge-Kutta methods for ordinary differential equations. A review},     author={Kennedy, Christopher A and Carpenter, Mark H},     year={2016}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SSPSDIRK2","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SSPSDIRK2","text":"SSPSDIRK2(; chunk_size = Val{0}(),\n            autodiff = AutoForwardDiff(),\n            standardtag = Val{true}(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS,\n            nlsolve = NLNewton(),\n            smooth_est = true,\n            extrapolant = :constant,\n            controller = :PI)\n\nSDIRK Method. SSPSDIRK is an SSP-optimized SDIRK method, so it's an implicit SDIRK method for handling stiffness but if the dt is below the SSP coefficient * dt, then the SSP property of the SSP integrators (the other page) is satisfied. As such this is a method which is expected to be good on advection-dominated cases where an explicit SSP integrator would be used, but where reaction equations are sufficient stiff to justify implicit integration.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SSPSDIRK2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{ketcheson2009optimal,     title={Optimal implicit strong stability preserving Runge–Kutta methods},     author={Ketcheson, David I and Macdonald, Colin B and Gottlieb, Sigal},     journal={Applied Numerical Mathematics},     volume={59},     number={2},     pages={373–392},     year={2009},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.Kvaerno3","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.Kvaerno3","text":"Kvaerno3(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           smooth_est = true,\n           extrapolant = :linear,\n           controller = :PI,\n           step_limiter! = trivial_limiter!)\n\nSDIRK Method. An A-L stable stiffly-accurate 3rd order ESDIRK method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Kvaerno3(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{kvaerno2004singly,     title={Singly diagonally implicit Runge–Kutta methods with an explicit first stage},     author={Kv{\\ae}rn{\\o}, Anne},     journal={BIT Numerical Mathematics},     volume={44},     number={3},     pages={489–502},     year={2004},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.KenCarp3","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.KenCarp3","text":"KenCarp3(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           smooth_est = true,\n           extrapolant = :linear,\n           controller = :PI,\n           step_limiter! = trivial_limiter!)\n\nSDIRK Method. An A-L stable stiffly-accurate 3rd order ESDIRK method with splitting.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify KenCarp3(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@book{kennedy2001additive,     title={Additive Runge-Kutta schemes for convection-diffusion-reaction equations},     author={Kennedy, Christopher Alan},     year={2001},     publisher={National Aeronautics and Space Administration, Langley Research Center}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.CFNLIRK3","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.CFNLIRK3","text":"CFNLIRK3(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           extrapolant = :linear)\n\nSDIRK Method. Third order method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify CFNLIRK3(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{calvo2001linearly,     title={Linearly implicit Runge–Kutta methods for advection–reaction–diffusion equations},     author={Calvo, MP and De Frutos, J and Novo, J},     journal={Applied Numerical Mathematics},     volume={37},     number={4},     pages={535–549},     year={2001},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.Cash4","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.Cash4","text":"Cash4(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        diff_type = Val{:forward}(),\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        nlsolve = NLNewton(),\n        smooth_est = true,\n        extrapolant = :linear,\n        controller = :PI,\n        embedding = 3)\n\nSDIRK Method. An A-L stable 4th order SDIRK method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Cash4(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nembedding: TBD\n\nReferences\n\n@article{hindmarsh2005sundials,     title={{SUNDIALS}: Suite of nonlinear and differential/algebraic equation solvers},     author={Hindmarsh, Alan C and Brown, Peter N and Grant, Keith E and Lee, Steven L and Serban, Radu and Shumaker, Dan E and Woodward, Carol S},     journal={ACM Transactions on Mathematical Software (TOMS)},     volume={31},     number={3},     pages={363–396},     year={2005},     publisher={ACM}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SFSDIRK4","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SFSDIRK4","text":"SFSDIRK4(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           extrapolant = :linear)\n\nSDIRK Method. Method of order 4.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SFSDIRK4(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{ferracina2008strong,     title={Strong stability of singly-diagonally-implicit Runge–Kutta methods},     author={Ferracina, Luca and Spijker, MN},     journal={Applied Numerical Mathematics},     volume={58},     number={11},     pages={1675–1686},     year={2008},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SFSDIRK5","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SFSDIRK5","text":"SFSDIRK5(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           extrapolant = :linear)\n\nSDIRK Method. Method of order 5.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SFSDIRK5(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{ferracina2008strong,     title={Strong stability of singly-diagonally-implicit Runge–Kutta methods},     author={Ferracina, Luca and Spijker, MN},     journal={Applied Numerical Mathematics},     volume={58},     number={11},     pages={1675–1686},     year={2008},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SFSDIRK6","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SFSDIRK6","text":"SFSDIRK6(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           extrapolant = :linear)\n\nSDIRK Method. Method of order 6.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SFSDIRK6(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{ferracina2008strong,     title={Strong stability of singly-diagonally-implicit Runge–Kutta methods},     author={Ferracina, Luca and Spijker, MN},     journal={Applied Numerical Mathematics},     volume={58},     number={11},     pages={1675–1686},     year={2008},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SFSDIRK7","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SFSDIRK7","text":"SFSDIRK7(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           extrapolant = :linear)\n\nSDIRK Method. Method of order 7.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SFSDIRK7(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{ferracina2008strong,     title={Strong stability of singly-diagonally-implicit Runge–Kutta methods},     author={Ferracina, Luca and Spijker, MN},     journal={Applied Numerical Mathematics},     volume={58},     number={11},     pages={1675–1686},     year={2008},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SFSDIRK8","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SFSDIRK8","text":"SFSDIRK8(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           extrapolant = :linear)\n\nSDIRK Method. Method of order 8.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SFSDIRK8(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{ferracina2008strong,     title={Strong stability of singly-diagonally-implicit Runge–Kutta methods},     author={Ferracina, Luca and Spijker, MN},     journal={Applied Numerical Mathematics},     volume={58},     number={11},     pages={1675–1686},     year={2008},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.Hairer4","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.Hairer4","text":"Hairer4(; chunk_size = Val{0}(),\n          autodiff = AutoForwardDiff(),\n          standardtag = Val{true}(),\n          concrete_jac = nothing,\n          diff_type = Val{:forward}(),\n          linsolve = nothing,\n          precs = DEFAULT_PRECS,\n          nlsolve = NLNewton(),\n          smooth_est = true,\n          extrapolant = :linear,\n          controller = :PI)\n\nSDIRK Method. An A-L stable 4th order SDIRK method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Hairer4(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and     differential-algebraic problems. Computational mathematics (2nd revised ed.),     Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.Hairer42","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.Hairer42","text":"Hairer42(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           smooth_est = true,\n           extrapolant = :linear,\n           controller = :PI)\n\nSDIRK Method. An A-L stable 4th order SDIRK method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Hairer42(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and     differential-algebraic problems. Computational mathematics (2nd revised ed.),     Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.Kvaerno4","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.Kvaerno4","text":"Kvaerno4(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           smooth_est = true,\n           extrapolant = :linear,\n           controller = :PI,\n           step_limiter! = trivial_limiter!)\n\nSDIRK Method. An A-L stable stiffly-accurate 4th order ESDIRK method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Kvaerno4(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter: TBD\n\nReferences\n\n@article{kvaerno2004singly,     title={Singly diagonally implicit Runge–Kutta methods with an explicit first stage},     author={Kv{\\ae}rn{\\o}, Anne},     journal={BIT Numerical Mathematics},     volume={44},     number={3},     pages={489–502},     year={2004},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.Kvaerno5","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.Kvaerno5","text":"Kvaerno5(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           smooth_est = true,\n           extrapolant = :linear,\n           controller = :PI,\n           step_limiter! = trivial_limiter!)\n\nSDIRK Method. An A-L stable stiffly-accurate 5th order ESDIRK method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Kvaerno5(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter: TBD\n\nReferences\n\n@article{kvaerno2004singly,     title={Singly diagonally implicit Runge–Kutta methods with an explicit first stage},     author={Kv{\\ae}rn{\\o}, Anne},     journal={BIT Numerical Mathematics},     volume={44},     number={3},     pages={489–502},     year={2004},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.KenCarp4","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.KenCarp4","text":"KenCarp4(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           smooth_est = true,\n           extrapolant = :linear,\n           controller = :PI,\n           step_limiter! = trivial_limiter!)\n\nSDIRK Method. An A-L stable stiffly-accurate 4th order ESDIRK method with splitting. Includes splitting capabilities. Recommended for medium tolerance stiff problems (>1e-8).\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify KenCarp4(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter: TBD\n\nReferences\n\n@book{kennedy2001additive,     title={Additive Runge-Kutta schemes for convection-diffusion-reaction equations},     author={Kennedy, Christopher Alan},     year={2001},     publisher={National Aeronautics and Space Administration, Langley Research Center}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.KenCarp47","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.KenCarp47","text":"KenCarp47(; chunk_size = Val{0}(),\n            autodiff = AutoForwardDiff(),\n            standardtag = Val{true}(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS,\n            nlsolve = NLNewton(),\n            smooth_est = true,\n            extrapolant = :linear,\n            controller = :PI)\n\nSDIRK Method. An A-L stable stiffly-accurate 4th order seven-stage ESDIRK method with splitting.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify KenCarp47(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{kennedy2019higher,     title={Higher-order additive Runge–Kutta schemes for ordinary differential equations},     author={Kennedy, Christopher A and Carpenter, Mark H},     journal={Applied Numerical Mathematics},     volume={136},     pages={183–205},     year={2019},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.KenCarp5","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.KenCarp5","text":"KenCarp5(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           smooth_est = true,\n           extrapolant = :linear,\n           controller = :PI,\n           step_limiter! = trivial_limiter!)\n\nSDIRK Method. An A-L stable stiffly-accurate 5th order ESDIRK method with splitting.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify KenCarp5(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter: TBD\n\nReferences\n\n@book{kennedy2001additive,     title={Additive Runge-Kutta schemes for convection-diffusion-reaction equations},     author={Kennedy, Christopher Alan},     year={2001},     publisher={National Aeronautics and Space Administration, Langley Research Center}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.KenCarp58","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.KenCarp58","text":"KenCarp58(; chunk_size = Val{0}(),\n            autodiff = AutoForwardDiff(),\n            standardtag = Val{true}(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS,\n            nlsolve = NLNewton(),\n            smooth_est = true,\n            extrapolant = :linear,\n            controller = :PI)\n\nSDIRK Method. An A-L stable stiffly-accurate 5th order eight-stage ESDIRK method with splitting.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify KenCarp58(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{kennedy2019higher,     title={Higher-order additive Runge–Kutta schemes for ordinary differential equations},     author={Kennedy, Christopher A and Carpenter, Mark H},     journal={Applied Numerical Mathematics},     volume={136},     pages={183–205},     year={2019},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.ESDIRK54I8L2SA","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.ESDIRK54I8L2SA","text":"ESDIRK54I8L2SA(; chunk_size = Val{0}(),\n                 autodiff = AutoForwardDiff(),\n                 standardtag = Val{true}(),\n                 concrete_jac = nothing,\n                 diff_type = Val{:forward}(),\n                 linsolve = nothing,\n                 precs = DEFAULT_PRECS,\n                 nlsolve = NLNewton(),\n                 extrapolant = :linear,\n                 controller = :PI)\n\nSDIRK Method. Optimized ESDIRK tableaus. Updates of the original KenCarp tableau expected to achieve lower error for the same steps in theory, but are still being fully evaluated in context.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ESDIRK54I8L2SA(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{Kennedy2019DiagonallyIR, title={Diagonally implicit Runge–Kutta methods for stiff ODEs}, author={Christopher A. Kennedy and Mark H. Carpenter}, journal={Applied Numerical Mathematics}, year={2019}, volume={146}, pages={221-244} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.ESDIRK436L2SA2","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.ESDIRK436L2SA2","text":"ESDIRK436L2SA2(; chunk_size = Val{0}(),\n                 autodiff = AutoForwardDiff(),\n                 standardtag = Val{true}(),\n                 concrete_jac = nothing,\n                 diff_type = Val{:forward}(),\n                 linsolve = nothing,\n                 precs = DEFAULT_PRECS,\n                 nlsolve = NLNewton(),\n                 extrapolant = :linear,\n                 controller = :PI)\n\nSDIRK Method. Optimized ESDIRK tableaus. Updates of the original KenCarp tableau expected to achieve lower error for the same steps in theory, but are still being fully evaluated in context.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ESDIRK436L2SA2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{Kennedy2019DiagonallyIR, title={Diagonally implicit Runge–Kutta methods for stiff ODEs}, author={Christopher A. Kennedy and Mark H. Carpenter}, journal={Applied Numerical Mathematics}, year={2019}, volume={146}, pages={221-244} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.ESDIRK437L2SA","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.ESDIRK437L2SA","text":"ESDIRK437L2SA(; chunk_size = Val{0}(),\n                autodiff = AutoForwardDiff(),\n                standardtag = Val{true}(),\n                concrete_jac = nothing,\n                diff_type = Val{:forward}(),\n                linsolve = nothing,\n                precs = DEFAULT_PRECS,\n                nlsolve = NLNewton(),\n                extrapolant = :linear,\n                controller = :PI)\n\nSDIRK Method. Optimized ESDIRK tableaus. Updates of the original KenCarp tableau expected to achieve lower error for the same steps in theory, but are still being fully evaluated in context.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ESDIRK437L2SA(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{Kennedy2019DiagonallyIR, title={Diagonally implicit Runge–Kutta methods for stiff ODEs}, author={Christopher A. Kennedy and Mark H. Carpenter}, journal={Applied Numerical Mathematics}, year={2019}, volume={146}, pages={221-244} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.ESDIRK547L2SA2","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.ESDIRK547L2SA2","text":"ESDIRK547L2SA2(; chunk_size = Val{0}(),\n                 autodiff = AutoForwardDiff(),\n                 standardtag = Val{true}(),\n                 concrete_jac = nothing,\n                 diff_type = Val{:forward}(),\n                 linsolve = nothing,\n                 precs = DEFAULT_PRECS,\n                 nlsolve = NLNewton(),\n                 extrapolant = :linear,\n                 controller = :PI)\n\nSDIRK Method. Optimized ESDIRK tableaus. Updates of the original KenCarp tableau expected to achieve lower error for the same steps in theory, but are still being fully evaluated in context.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ESDIRK547L2SA2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{Kennedy2019DiagonallyIR, title={Diagonally implicit Runge–Kutta methods for stiff ODEs}, author={Christopher A. Kennedy and Mark H. Carpenter}, journal={Applied Numerical Mathematics}, year={2019}, volume={146}, pages={221-244} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.ESDIRK659L2SA","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.ESDIRK659L2SA","text":"ESDIRK659L2SA(; chunk_size = Val{0}(),\n                autodiff = AutoForwardDiff(),\n                standardtag = Val{true}(),\n                concrete_jac = nothing,\n                diff_type = Val{:forward}(),\n                linsolve = nothing,\n                precs = DEFAULT_PRECS,\n                nlsolve = NLNewton(),\n                extrapolant = :linear,\n                controller = :PI)\n\nSDIRK Method. Optimized ESDIRK tableaus. Updates of the original KenCarp tableau expected to achieve lower error for the same steps in theory, but are still being fully evaluated in context. Currently has STABILITY ISSUES, causing it to fail the adaptive tests. Check issue https://github.com/SciML/OrdinaryDiffEq.jl/issues/1933 for more details.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ESDIRK659L2SA(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{Kennedy2019DiagonallyIR, title={Diagonally implicit Runge–Kutta methods for stiff ODEs}, author={Christopher A. Kennedy and Mark H. Carpenter}, journal={Applied Numerical Mathematics}, year={2019}, volume={146}, pages={221-244} }\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK","text":"Exponential Runge-Kutta methods are specialized integrators for semi-linear differential equations of the form du/dt = Au + f(u,t), where A is a linear operator (often representing diffusion or dispersion) and f represents nonlinear terms. These methods are particularly effective for stiff linear parts combined with non-stiff nonlinear terms. Important: The nonlinear term f(u,t) must be non-stiff for these methods to be effective.","category":"section"},{"location":"semiimplicit/ExponentialRK/#Key-Properties","page":"OrdinaryDiffEqExponentialRK","title":"Key Properties","text":"Exponential RK methods provide:\n\nExact treatment of linear parts using matrix exponential functions\nHigh-order accuracy for both linear and nonlinear components\nExcellent stability properties for problems with stiff linear operators\nEfficient handling of semi-linear PDEs after spatial discretization\nReduced timestep restrictions compared to traditional explicit methods\nPreservation of qualitative behavior for many physical systems","category":"section"},{"location":"semiimplicit/ExponentialRK/#When-to-Use-Exponential-RK-Methods","page":"OrdinaryDiffEqExponentialRK","title":"When to Use Exponential RK Methods","text":"These methods are recommended for:\n\nSemi-linear PDEs with stiff diffusion/dispersion and moderate non-stiff nonlinearity\nReaction-diffusion systems with fast diffusion and slower non-stiff reactions\nNonlinear Schrödinger equations and other dispersive wave equations with non-stiff nonlinear terms\nPattern formation problems (Turing patterns, phase field models) where nonlinearity is non-stiff\nQuantum dynamics with linear Hamiltonian and non-stiff nonlinear interactions\nProblems with strong linear damping or oscillatory linear parts combined with non-stiff nonlinear terms\nSpatially discretized PDEs where the linear part dominates stiffness but the nonlinear part remains non-stiff","category":"section"},{"location":"semiimplicit/ExponentialRK/#Mathematical-Background","page":"OrdinaryDiffEqExponentialRK","title":"Mathematical Background","text":"For problems du/dt = Au + f(u,t), exponential methods compute the exact solution of the linear part Au using exp(A*dt) and treat the nonlinear part f(u,t) with Runge-Kutta-like stages. This approach is particularly effective when A represents well-understood physics (diffusion, dispersion, linear oscillations).","category":"section"},{"location":"semiimplicit/ExponentialRK/#Solver-Selection-Guide","page":"OrdinaryDiffEqExponentialRK","title":"Solver Selection Guide","text":"","category":"section"},{"location":"semiimplicit/ExponentialRK/#Basic-exponential-time-differencing-(ETD)","page":"OrdinaryDiffEqExponentialRK","title":"Basic exponential time differencing (ETD)","text":"LawsonEuler: First-order exponential Euler method\nNorsettEuler / ETD1: Alternative first-order scheme\nETDRK2: Second-order exponential RK\nETDRK3: Third-order exponential RK\nETDRK4: Fourth-order exponential RK, popular choice\nETD2: Second-order exponential time differencing (in development)","category":"section"},{"location":"semiimplicit/ExponentialRK/#High-order-specialized-methods","page":"OrdinaryDiffEqExponentialRK","title":"High-order specialized methods","text":"HochOst4: Fourth-order exponential RK with enhanced stability\nExp4: Fourth-order EPIRK scheme","category":"section"},{"location":"semiimplicit/ExponentialRK/#Adaptive-exponential-Rosenbrock","page":"OrdinaryDiffEqExponentialRK","title":"Adaptive exponential Rosenbrock","text":"Exprb32: Third-order adaptive method with error control\nExprb43: Fourth-order adaptive method","category":"section"},{"location":"semiimplicit/ExponentialRK/#EPIRK-(Exponential-Propagation-Iterative-RK)-methods","page":"OrdinaryDiffEqExponentialRK","title":"EPIRK (Exponential Propagation Iterative RK) methods","text":"EPIRK4s3A: Fourth-order with stiff order 4\nEPIRK4s3B: Alternative fourth-order variant\nEPIRK5s3: Fifth-order method (note: marked as broken)\nEXPRB53s3: Fifth-order with stiff order 5\nEPIRK5P1, EPIRK5P2: Fifth-order variants","category":"section"},{"location":"semiimplicit/ExponentialRK/#Performance-Recommendations","page":"OrdinaryDiffEqExponentialRK","title":"Performance Recommendations","text":"For most semi-linear problems: ETDRK4\nFor adaptive stepsize: Exprb43\nFor high stiffness in linear part: EPIRK4s3A or EPIRK4s3B\nFor maximum accuracy: EXPRB53s3","category":"section"},{"location":"semiimplicit/ExponentialRK/#Implementation-Requirements","page":"OrdinaryDiffEqExponentialRK","title":"Implementation Requirements","text":"These methods require:\n\nComputation of matrix exponentials exp(A*dt) and related functions\nKrylov subspace methods for large systems (automatic in most cases)\nProper problem formulation with identified linear and nonlinear parts","category":"section"},{"location":"semiimplicit/ExponentialRK/#Installation","page":"OrdinaryDiffEqExponentialRK","title":"Installation","text":"To be able to access the solvers in OrdinaryDiffEqLinear, you must first install them use the Julia package manager:\n\nusing Pkg\nPkg.add(\"OrdinaryDiffEqExponentialRK\")\n\nThis will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.","category":"section"},{"location":"semiimplicit/ExponentialRK/#Example-usage","page":"OrdinaryDiffEqExponentialRK","title":"Example usage","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqExponentialRK\", \"EPIRK5s3\")","category":"section"},{"location":"semiimplicit/ExponentialRK/#Full-list-of-solvers","page":"OrdinaryDiffEqExponentialRK","title":"Full list of solvers","text":"","category":"section"},{"location":"semiimplicit/ExponentialRK/#Adaptive-Exponential-Rosenbrock-Methods","page":"OrdinaryDiffEqExponentialRK","title":"Adaptive Exponential Rosenbrock Methods","text":"","category":"section"},{"location":"semiimplicit/ExponentialRK/#Exponential-Propagation-Iterative-Runge-Kutta-Methods-(EPIRK)","page":"OrdinaryDiffEqExponentialRK","title":"Exponential Propagation Iterative Runge-Kutta Methods (EPIRK)","text":"","category":"section"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.LawsonEuler-semiimplicit-ExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.LawsonEuler","text":"LawsonEuler(; krylov = false,\n              m = 30,\n              iop = 0)\n\nSemilinear ODE solver First order exponential Euler scheme (fixed timestepping)\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.NorsettEuler-semiimplicit-ExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.NorsettEuler","text":"NorsettEuler(; krylov = false,\n               m = 30,\n               iop = 0)\n\nSemilinear ODE solver First order exponential-RK scheme. Alias: ETD1\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETD2-semiimplicit-ExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETD2","text":"ETD2: Exponential Runge-Kutta Method Second order Exponential Time Differencing method (in development).\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETDRK2-semiimplicit-ExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETDRK2","text":"ETDRK2(; krylov = false,\n         m = 30,\n         iop = 0)\n\nSemilinear ODE solver 2nd order exponential-RK scheme.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETDRK3-semiimplicit-ExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETDRK3","text":"ETDRK3(; krylov = false,\n         m = 30,\n         iop = 0)\n\nSemilinear ODE solver 3rd order exponential-RK scheme.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETDRK4-semiimplicit-ExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETDRK4","text":"ETDRK4(; krylov = false,\n         m = 30,\n         iop = 0)\n\nSemilinear ODE solver 4th order exponential-RK scheme (fixed timestepping)\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.HochOst4-semiimplicit-ExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.HochOst4","text":"HochOst4(; krylov = false,\n           m = 30,\n           iop = 0)\n\nSemilinear ODE solver 4th order exponential-RK scheme with stiff order 4.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.Exprb32","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.Exprb32","text":"Exprb32(; m = 30,\n          iop = 0)\n\nSemilinear ODE solver 3rd order adaptive Exponential-Rosenbrock scheme.\n\nKeyword Arguments\n\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).   Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, M., & Ostermann, A. (2010). Exponential integrators. Acta Numerica, 19, 209-286. (https://doi.org/10.1017/S0962492910000048)\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.Exprb43","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.Exprb43","text":"Exprb43(; m = 30,\n          iop = 0)\n\nSemilinear ODE solver 4th order adaptive Exponential-Rosenbrock scheme.\n\nKeyword Arguments\n\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).   Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, M., & Ostermann, A. (2010). Exponential integrators. Acta Numerica, 19, 209-286. (https://doi.org/10.1017/S0962492910000048)\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock","text":"Rosenbrock methods are semi-implicit Runge-Kutta methods designed for small to medium-sized stiff systems of differential equations. These methods combine the stability properties of implicit methods with computational efficiency by using approximate Jacobians. They work particularly well for strict tolerance requirements.","category":"section"},{"location":"semiimplicit/Rosenbrock/#Key-Properties","page":"OrdinaryDiffEqRosenbrock","title":"Key Properties","text":"Rosenbrock methods provide:\n\nExcellent efficiency for small to medium systems (<1000 ODEs)\nL-stable and A-stable variants for stiff problems\nW-method structure making them robust to inaccurate Jacobians\nAutomatic differentiation compatibility for Jacobian computation\nHigh-order accuracy with embedded error estimation\nExcellent performance for strict tolerance requirements\nStiffly accurate variants for enhanced stability","category":"section"},{"location":"semiimplicit/Rosenbrock/#When-to-Use-Rosenbrock-Methods","page":"OrdinaryDiffEqRosenbrock","title":"When to Use Rosenbrock Methods","text":"Rosenbrock methods are recommended for:\n\nSmall to medium stiff systems (10 to 1000 equations)\nProblems where Jacobians are available or can be computed efficiently\nMedium tolerance requirements (1e-8 to 1e-2)\nStiff ODEs arising from reaction kinetics and chemical systems\nModerately stiff PDEs after spatial discretization\nProblems requiring reliable error control for stiff systems","category":"section"},{"location":"semiimplicit/Rosenbrock/#Solver-Selection-Guide","page":"OrdinaryDiffEqRosenbrock","title":"Solver Selection Guide","text":"","category":"section"},{"location":"semiimplicit/Rosenbrock/#Low-tolerance-(1e-2)","page":"OrdinaryDiffEqRosenbrock","title":"Low tolerance (>1e-2)","text":"Rosenbrock23: Second/third-order method, recommended for low tolerance requirements","category":"section"},{"location":"semiimplicit/Rosenbrock/#Medium-tolerance-(1e-8-to-1e-2)","page":"OrdinaryDiffEqRosenbrock","title":"Medium tolerance (1e-8 to 1e-2)","text":"Rodas5P: Fifth-order method, most efficient for many problems\nRodas4P: Fourth-order method, more reliable than Rodas5P\nRodas5Pe: Enhanced fifth-order variant with stiffly accurate embedded estimate for better adaptivity on highly stiff equations\nRodas5Pr: Fifth-order variant with residual test for robust error estimation that guarantees accuracy on interpolation","category":"section"},{"location":"semiimplicit/Rosenbrock/#Performance-Guidelines","page":"OrdinaryDiffEqRosenbrock","title":"Performance Guidelines","text":"Rodas5P: Best overall efficiency at medium tolerances\nRodas4P: Most reliable when Rodas5P fails\nRosenbrock23: Fastest at high tolerances (>1e-2)","category":"section"},{"location":"semiimplicit/Rosenbrock/#When-to-Choose-Alternatives","page":"OrdinaryDiffEqRosenbrock","title":"When to Choose Alternatives","text":"Consider other methods when:\n\nSystem size > 1000: Use BDF methods (QNDF, FBDF)\nMatrix-free methods: If using Krylov solvers for the linear solver (matrix-free methods), SDIRK or BDF methods are preferred","category":"section"},{"location":"semiimplicit/Rosenbrock/#Advantages-of-Rosenbrock-Methods","page":"OrdinaryDiffEqRosenbrock","title":"Advantages of Rosenbrock Methods","text":"Very low tolerances: Rosenbrock23 performs well even at very low tolerances\nVery high stiffness: Rosenbrock methods are often more stable than SDIRK or BDF methods because other methods can diverge due to bad initial guesses for the Newton method (leading to nonlinear solver divergence)\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqRosenbrock\", \"Rodas5P\")","category":"section"},{"location":"semiimplicit/Rosenbrock/#Full-list-of-solvers","page":"OrdinaryDiffEqRosenbrock","title":"Full list of solvers","text":"","category":"section"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rosenbrock23","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rosenbrock23","text":"Rosenbrock23(; chunk_size = Val{0}(),\n               standardtag = Val{true}(),\n               autodiff = AutoForwardDiff(),\n               concrete_jac = nothing,\n               diff_type = Val{:forward}(),\n               linsolve = nothing,\n               precs = DEFAULT_PRECS,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  An Order 2/3 L-Stable Rosenbrock-W method which is good for very stiff equations with oscillations at low tolerances. 2nd order stiff-aware interpolation.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rosenbrock23(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nShampine L.F. and Reichelt M., (1997) The MATLAB ODE Suite, SIAM Journal of Scientific Computing, 18 (1), pp. 1-22.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rosenbrock32","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rosenbrock32","text":"Rosenbrock32(; chunk_size = Val{0}(),\n               standardtag = Val{true}(),\n               autodiff = AutoForwardDiff(),\n               concrete_jac = nothing,\n               diff_type = Val{:forward}(),\n               linsolve = nothing,\n               precs = DEFAULT_PRECS,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  An Order 3/2 A-Stable Rosenbrock-W method which is good for mildly stiff equations without oscillations at low tolerances. Note that this method is prone to instability in the presence of oscillations, so use with caution. 2nd order stiff-aware interpolation.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rosenbrock32(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nShampine L.F. and Reichelt M., (1997) The MATLAB ODE Suite, SIAM Journal of Scientific Computing, 18 (1), pp. 1-22.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3P","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3P","text":"ROS3P(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n            ForwardDiff default function-specific tags. For more information, see\n            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n            Defaults to `Val{true}()`.\n        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n            to specify whether to use automatic differentiation via\n            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n            `nothing`, which means it will be chosen true/false depending on circumstances\n            of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n          `ROS3P(linsolve = KLUFactorization()`).\n           When `nothing` is passed, uses `DefaultLinearSolver`.\n        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n          can be used as a left or right preconditioner.\n          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n          function where the arguments are defined as:\n            - `W`: the current Jacobian of the nonlinear system. Specified as either\n                ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                representation of the operator. Users can construct the W-matrix on demand\n                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                the `jac_prototype`.\n            - `du`: the current ODE derivative\n            - `u`: the current ODE state\n            - `p`: the ODE parameters\n            - `t`: the current ODE time\n            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                the last call to `precs`. It is recommended that this is checked to only\n                update the preconditioner when `newW == true`.\n            - `Plprev`: the previous `Pl`.\n            - `Prprev`: the previous `Pr`.\n            - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                Solver-dependent and subject to change.\n          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n          To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n          which is not used. Additionally, `precs` must supply the dispatch:\n          ```julia\n          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n          ```\n          which is used in the solver setup phase to construct the integrator\n          type with the preconditioners `(Pl,Pr)`.\n          The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n          is defined as:\n          ```julia\n          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n          ```\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method. Keeps high accuracy on discretizations of nonlinear parabolic PDEs.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nLang, J. & Verwer, ROS3P—An Accurate Third-Order Rosenbrock Solver Designed for Parabolic Problems J. BIT Numerical Mathematics (2001) 41: 731. doi:10.1023/A:1021900219772\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas3","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas3","text":"Rodas3(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Rodas3(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSandu, Verwer, Van Loon, Carmichael, Potra, Dabdub, Seinfeld, Benchmarking stiff ode solvers for atmospheric chemistry problems-I.  implicit vs explicit, Atmospheric Environment, 31(19), 3151-3166, 1997.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas23W","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas23W","text":"Rodas23W(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  An Order 2/3 L-Stable Rosenbrock-W method for stiff ODEs and DAEs in mass matrix form. 2nd order stiff-aware interpolation and additional error test for interpolation.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas23W(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G., Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024. Proceedings of the JuliaCon Conferences. https://proceedings.juliacon.org/papers/eb04326e1de8fa819a3595b376508a40\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas3P","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas3P","text":"Rodas3P(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `Rodas3P(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant and additional error test for interpolation. Keeps accuracy on discretizations of linear parabolic PDEs.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G., Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024. Proceedings of the JuliaCon Conferences. https://proceedings.juliacon.org/papers/eb04326e1de8fa819a3595b376508a40\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas4","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas4","text":"Rodas4(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Rodas4(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas42","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas42","text":"Rodas42(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `Rodas42(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas4P","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas4P","text":"Rodas4P(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `Rodas4P(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems (as opposed to lower if not corrected).\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach, G., Rentrop, P., An adaptive method of lines approach for modelling flow and transport in rivers.  Adaptive method of lines , Wouver, A. Vande, Sauces, Ph., Schiesser, W.E. (ed.),S. 181-205,Chapman & Hall/CRC, 2001,\nSteinebach, G., Order-reduction of ROW-methods for DAEs and method of lines  applications.  Preprint-Nr. 1741, FB Mathematik, TH Darmstadt, 1995.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas4P2","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas4P2","text":"Rodas4P2(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems. It is an improvement of Rodas4P and in case of inexact Jacobians a second order W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas4P2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G., Improvement of Rosenbrock-Wanner Method RODASP, In: Reis T., Grundel S., Schöps S. (eds)  Progress in Differential-Algebraic Equations II. Differential-Algebraic Equations Forum. Springer, Cham., 165-184, 2020.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5","text":"Rodas5(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Rodas5(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 5th order A-stable stiffly stable Rosenbrock method with a stiff-aware 4th order interpolant.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nDi Marzo G. RODAS5(4) – Méthodes de Rosenbrock d'ordre 5(4) adaptées aux problèmes différentiels-algébriques. MSc mathematics thesis, Faculty of Science, University of Geneva, Switzerland.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5P","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5P","text":"Rodas5P(; chunk_size = Val{0}(),\n          standardtag = Val{true}(),\n          autodiff = AutoForwardDiff(),\n          concrete_jac = nothing,\n          diff_type = Val{:forward}(),\n          linsolve = nothing,\n          precs = DEFAULT_PRECS,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 5th order A-stable stiffly stable Rosenbrock method with a stiff-aware 4th order interpolant. Has improved stability in the adaptive time stepping embedding.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas5P(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G. Construction of Rosenbrock–Wanner method Rodas5P and numerical benchmarks within the Julia Differential Equations package. In: BIT Numerical Mathematics, 63(2), 2023. doi:10.1007/s10543-023-00967-x\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5Pe","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5Pe","text":"Rodas5Pe(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  Variant of Rodas5P with modified embedded scheme.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas5Pe(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G. Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024. Proceedings of the JuliaCon Conferences. https://proceedings.juliacon.org/papers/eb04326e1de8fa819a3595b376508a40\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5Pr","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5Pr","text":"Rodas5Pr(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  Variant of Rodas5P with additional residual control.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas5Pr(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G. Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024. Proceedings of the JuliaCon Conferences. https://proceedings.juliacon.org/papers/eb04326e1de8fa819a3595b376508a40\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.RosenbrockW6S4OS","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.RosenbrockW6S4OS","text":"RosenbrockW6S4OS(; chunk_size = Val{0}(),\n                   standardtag = Val{true}(),\n                   autodiff = AutoForwardDiff(),\n                   concrete_jac = nothing,\n                   diff_type = Val{:forward}(),\n                   linsolve = nothing,\n                   precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method (fixed step only).\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify RosenbrockW6S4OS(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nhttps://doi.org/10.1016/j.cam.2009.09.017\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS2","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS2","text":"ROS2(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n           ForwardDiff default function-specific tags. For more information, see\n           [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n           Defaults to `Val{true}()`.\n       - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n           to specify whether to use automatic differentiation via\n           [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n           differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n           Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n           `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n           To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n           `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n       - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n           `nothing`, which means it will be chosen true/false depending on circumstances\n           of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n       - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n         For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n         `ROS2(linsolve = KLUFactorization()`).\n          When `nothing` is passed, uses `DefaultLinearSolver`.\n       - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n         can be used as a left or right preconditioner.\n         Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n         function where the arguments are defined as:\n           - `W`: the current Jacobian of the nonlinear system. Specified as either\n               ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n               commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n               representation of the operator. Users can construct the W-matrix on demand\n               by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n               the `jac_prototype`.\n           - `du`: the current ODE derivative\n           - `u`: the current ODE state\n           - `p`: the ODE parameters\n           - `t`: the current ODE time\n           - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n               the last call to `precs`. It is recommended that this is checked to only\n               update the preconditioner when `newW == true`.\n           - `Plprev`: the previous `Pl`.\n           - `Prprev`: the previous `Pr`.\n           - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n               Solver-dependent and subject to change.\n         The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n         To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n         which is not used. Additionally, `precs` must supply the dispatch:\n         ```julia\n         Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n         ```\n         which is used in the solver setup phase to construct the integrator\n         type with the preconditioners `(Pl,Pr)`.\n         The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n         is defined as:\n         ```julia\n         DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n         ```)\n\nRosenbrock-Wanner Method.  A 2nd order L-stable Rosenbrock method with 2 internal stages.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nJ. G. Verwer et al. (1999): A second-order Rosenbrock method applied to photochemical dispersion problems https://doi.org/10.1137/S1064827597326651\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS2PR","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS2PR","text":"ROS2PR(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `ROS2PR(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```)\n\nRosenbrock-Wanner Method.  2nd order stiffly accurate Rosenbrock method with 3 internal stages with (Rinf=0). For problems with medium stiffness the convergence behaviour is very poor and it is recommended to use ROS2S instead.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS2S","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS2S","text":"ROS2S(; chunk_size = Val{0}(),\n        standardtag = Val{true}(),\n        autodiff = AutoForwardDiff(),\n        concrete_jac = nothing,\n        diff_type = Val{:forward}(),\n        linsolve = nothing,\n        precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  2nd order stiffly accurate Rosenbrock-Wanner W-method with 3 internal stages with B_PR consistent of order 2 with (Rinf=0).\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS2S(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3","text":"ROS3(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n           ForwardDiff default function-specific tags. For more information, see\n           [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n           Defaults to `Val{true}()`.\n       - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n           to specify whether to use automatic differentiation via\n           [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n           differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n           Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n           `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n           To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n           `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n       - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n           `nothing`, which means it will be chosen true/false depending on circumstances\n           of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n       - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n         For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n         `ROS3(linsolve = KLUFactorization()`).\n          When `nothing` is passed, uses `DefaultLinearSolver`.\n       - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n         can be used as a left or right preconditioner.\n         Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n         function where the arguments are defined as:\n           - `W`: the current Jacobian of the nonlinear system. Specified as either\n               ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n               commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n               representation of the operator. Users can construct the W-matrix on demand\n               by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n               the `jac_prototype`.\n           - `du`: the current ODE derivative\n           - `u`: the current ODE state\n           - `p`: the ODE parameters\n           - `t`: the current ODE time\n           - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n               the last call to `precs`. It is recommended that this is checked to only\n               update the preconditioner when `newW == true`.\n           - `Plprev`: the previous `Pl`.\n           - `Prprev`: the previous `Pr`.\n           - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n               Solver-dependent and subject to change.\n         The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n         To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n         which is not used. Additionally, `precs` must supply the dispatch:\n         ```julia\n         Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n         ```\n         which is used in the solver setup phase to construct the integrator\n         type with the preconditioners `(Pl,Pr)`.\n         The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n         is defined as:\n         ```julia\n         DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n         ```)\n\nRosenbrock-Wanner Method.  3rd order L-stable Rosenbrock method with 3 internal stages with an embedded strongly A-stable 2nd order method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3PR","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3PR","text":"ROS3PR(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `ROS3PR(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```)\n\nRosenbrock-Wanner Method.  3nd order stiffly accurate Rosenbrock method with 3 internal stages with B_PR consistent of order 3, which is strongly A-stable with Rinf~=-0.73.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Scholz4_7","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Scholz4_7","text":"Scholz4_7(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n                ForwardDiff default function-specific tags. For more information, see\n                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n                Defaults to `Val{true}()`.\n            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n                to specify whether to use automatic differentiation via\n                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n                `nothing`, which means it will be chosen true/false depending on circumstances\n                of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n              `Scholz4_7(linsolve = KLUFactorization()`).\n               When `nothing` is passed, uses `DefaultLinearSolver`.\n            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n              can be used as a left or right preconditioner.\n              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n              function where the arguments are defined as:\n                - `W`: the current Jacobian of the nonlinear system. Specified as either\n                    ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                    representation of the operator. Users can construct the W-matrix on demand\n                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                    the `jac_prototype`.\n                - `du`: the current ODE derivative\n                - `u`: the current ODE state\n                - `p`: the ODE parameters\n                - `t`: the current ODE time\n                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                    the last call to `precs`. It is recommended that this is checked to only\n                    update the preconditioner when `newW == true`.\n                - `Plprev`: the previous `Pl`.\n                - `Prprev`: the previous `Pr`.\n                - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                    Solver-dependent and subject to change.\n              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n              To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n              which is not used. Additionally, `precs` must supply the dispatch:\n              ```julia\n              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n              ```\n              which is used in the solver setup phase to construct the integrator\n              type with the preconditioners `(Pl,Pr)`.\n              The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n              is defined as:\n              ```julia\n              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n              ```)\n\nRosenbrock-Wanner Method.  3nd order stiffly accurate Rosenbrock method with 3 internal stages with B_PR consistent of order 3, which is strongly A-stable with Rinf~=-0.73. Convergence with order 4 for the stiff case, but has a poor accuracy.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW1a","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW1a","text":"ROS34PW1a(; chunk_size = Val{0}(),\n            standardtag = Val{true}(),\n            autodiff = AutoForwardDiff(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW1a(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nRang, Joachim and Angermann, L (2005): New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1. BIT Numerical Mathematics, 45, 761–787.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW1b","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW1b","text":"ROS34PW1b(; chunk_size = Val{0}(),\n            standardtag = Val{true}(),\n            autodiff = AutoForwardDiff(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW1b(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nRang, Joachim and Angermann, L (2005): New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1. BIT Numerical Mathematics, 45, 761–787.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW2","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW2","text":"ROS34PW2(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order stiffy accurate Rosenbrock-W method for PDAEs.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nRang, Joachim and Angermann, L (2005): New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1. BIT Numerical Mathematics, 45, 761–787.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW3","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW3","text":"ROS34PW3(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order strongly A-stable (Rinf~0.63) Rosenbrock-W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW3(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nRang, Joachim and Angermann, L (2005): New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1. BIT Numerical Mathematics, 45, 761–787.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PRw","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PRw","text":"ROS34PRw(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  3rd order stiffly accurate Rosenbrock-Wanner W-method with 4 internal stages, B_PR consistent of order 2. The order of convergence decreases if medium stiff problems are considered.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PRw(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nJoachim Rang, Improved traditional Rosenbrock–Wanner methods for stiff ODEs and DAEs, Journal of Computational and Applied Mathematics, https://doi.org/10.1016/j.cam.2015.03.010\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3PRL","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3PRL","text":"ROS3PRL(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `ROS3PRL(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```)\n\nRosenbrock-Wanner Method.  3rd order stiffly accurate Rosenbrock method with 4 internal stages, B_PR consistent of order 2 with Rinf=0. The order of convergence decreases if medium stiff problems are considered, but it has good results for very stiff cases.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3PRL2","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3PRL2","text":"ROS3PRL2(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n               ForwardDiff default function-specific tags. For more information, see\n               [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n               Defaults to `Val{true}()`.\n           - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n               to specify whether to use automatic differentiation via\n               [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n               differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n               Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n               `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n               To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n               `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n           - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n               `nothing`, which means it will be chosen true/false depending on circumstances\n               of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n           - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n             For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n             `ROS3PRL2(linsolve = KLUFactorization()`).\n              When `nothing` is passed, uses `DefaultLinearSolver`.\n           - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n             can be used as a left or right preconditioner.\n             Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n             function where the arguments are defined as:\n               - `W`: the current Jacobian of the nonlinear system. Specified as either\n                   ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                   commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                   representation of the operator. Users can construct the W-matrix on demand\n                   by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                   the `jac_prototype`.\n               - `du`: the current ODE derivative\n               - `u`: the current ODE state\n               - `p`: the ODE parameters\n               - `t`: the current ODE time\n               - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                   the last call to `precs`. It is recommended that this is checked to only\n                   update the preconditioner when `newW == true`.\n               - `Plprev`: the previous `Pl`.\n               - `Prprev`: the previous `Pr`.\n               - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                   Solver-dependent and subject to change.\n             The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n             To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n             which is not used. Additionally, `precs` must supply the dispatch:\n             ```julia\n             Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n             ```\n             which is used in the solver setup phase to construct the integrator\n             type with the preconditioners `(Pl,Pr)`.\n             The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n             is defined as:\n             ```julia\n             DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n             ```)\n\nRosenbrock-Wanner Method.  3rd order stiffly accurate Rosenbrock method with 4 internal stages, B_PR consistent of order 3. The order of convergence does NOT decreases if medium stiff problems are considered as it does for ROS3PRL.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROK4a","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROK4a","text":"ROK4a(; chunk_size = Val{0}(),\n        standardtag = Val{true}(),\n        autodiff = AutoForwardDiff(),\n        concrete_jac = nothing,\n        diff_type = Val{:forward}(),\n        linsolve = nothing,\n        precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  4rd order L-stable Rosenbrock-Krylov method with 4 internal stages, with a 3rd order embedded method which is strongly A-stable with Rinf~=0.55. (when using exact Jacobians)\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROK4a(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nTranquilli, Paul and Sandu, Adrian (2014): Rosenbrock–Krylov Methods for Large Systems of Differential Equations https://doi.org/10.1137/130923336\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.RosShamp4","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.RosShamp4","text":"RosShamp4(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n                ForwardDiff default function-specific tags. For more information, see\n                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n                Defaults to `Val{true}()`.\n            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n                to specify whether to use automatic differentiation via\n                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n                `nothing`, which means it will be chosen true/false depending on circumstances\n                of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n              `RosShamp4(linsolve = KLUFactorization()`).\n               When `nothing` is passed, uses `DefaultLinearSolver`.\n            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n              can be used as a left or right preconditioner.\n              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n              function where the arguments are defined as:\n                - `W`: the current Jacobian of the nonlinear system. Specified as either\n                    ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                    representation of the operator. Users can construct the W-matrix on demand\n                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                    the `jac_prototype`.\n                - `du`: the current ODE derivative\n                - `u`: the current ODE state\n                - `p`: the ODE parameters\n                - `t`: the current ODE time\n                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                    the last call to `precs`. It is recommended that this is checked to only\n                    update the preconditioner when `newW == true`.\n                - `Plprev`: the previous `Pl`.\n                - `Prprev`: the previous `Pr`.\n                - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                    Solver-dependent and subject to change.\n              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n              To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n              which is not used. Additionally, `precs` must supply the dispatch:\n              ```julia\n              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n              ```\n              which is used in the solver setup phase to construct the integrator\n              type with the preconditioners `(Pl,Pr)`.\n              The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n              is defined as:\n              ```julia\n              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n              ```)\n\nRosenbrock-Wanner Method.  An A-stable 4th order Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nL. F. Shampine, Implementation of Rosenbrock Methods, ACM Transactions on Mathematical Software (TOMS), 8: 2, 93-113. doi:10.1145/355993.355994\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Veldd4","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Veldd4","text":"Veldd4(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Veldd4(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```)\n\nRosenbrock-Wanner Method.  A 4th order D-stable Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nvan Veldhuizen, D-stability and Kaps-Rentrop-methods, M. Computing (1984) 32: 229. doi:10.1007/BF02243574\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Velds4","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Velds4","text":"Velds4(; chunk_size = Val{0}(),\n         standardtag = Val{true}(),\n         autodiff = AutoForwardDiff(),\n         concrete_jac = nothing,\n         diff_type = Val{:forward}(),\n         linsolve = nothing,\n         precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order A-stable Rosenbrock method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Velds4(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nvan Veldhuizen, D-stability and Kaps-Rentrop-methods, M. Computing (1984) 32: 229. doi:10.1007/BF02243574\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.GRK4T","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.GRK4T","text":"GRK4T(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n            ForwardDiff default function-specific tags. For more information, see\n            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n            Defaults to `Val{true}()`.\n        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n            to specify whether to use automatic differentiation via\n            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n            `nothing`, which means it will be chosen true/false depending on circumstances\n            of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n          `GRK4T(linsolve = KLUFactorization()`).\n           When `nothing` is passed, uses `DefaultLinearSolver`.\n        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n          can be used as a left or right preconditioner.\n          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n          function where the arguments are defined as:\n            - `W`: the current Jacobian of the nonlinear system. Specified as either\n                ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                representation of the operator. Users can construct the W-matrix on demand\n                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                the `jac_prototype`.\n            - `du`: the current ODE derivative\n            - `u`: the current ODE state\n            - `p`: the ODE parameters\n            - `t`: the current ODE time\n            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                the last call to `precs`. It is recommended that this is checked to only\n                update the preconditioner when `newW == true`.\n            - `Plprev`: the previous `Pl`.\n            - `Prprev`: the previous `Pr`.\n            - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                Solver-dependent and subject to change.\n          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n          To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n          which is not used. Additionally, `precs` must supply the dispatch:\n          ```julia\n          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n          ```\n          which is used in the solver setup phase to construct the integrator\n          type with the preconditioners `(Pl,Pr)`.\n          The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n          is defined as:\n          ```julia\n          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n          ```)\n\nRosenbrock-Wanner Method.  An efficient 4th order Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nKaps, P. & Rentrop, Generalized Runge-Kutta methods of order four with stepsize control for stiff ordinary differential equations. P. Numer. Math. (1979) 33: 55. doi:10.1007/BF01396495\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.GRK4A","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.GRK4A","text":"GRK4A(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n            ForwardDiff default function-specific tags. For more information, see\n            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n            Defaults to `Val{true}()`.\n        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n            to specify whether to use automatic differentiation via\n            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n            `nothing`, which means it will be chosen true/false depending on circumstances\n            of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n          `GRK4A(linsolve = KLUFactorization()`).\n           When `nothing` is passed, uses `DefaultLinearSolver`.\n        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n          can be used as a left or right preconditioner.\n          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n          function where the arguments are defined as:\n            - `W`: the current Jacobian of the nonlinear system. Specified as either\n                ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                representation of the operator. Users can construct the W-matrix on demand\n                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                the `jac_prototype`.\n            - `du`: the current ODE derivative\n            - `u`: the current ODE state\n            - `p`: the ODE parameters\n            - `t`: the current ODE time\n            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                the last call to `precs`. It is recommended that this is checked to only\n                update the preconditioner when `newW == true`.\n            - `Plprev`: the previous `Pl`.\n            - `Prprev`: the previous `Pr`.\n            - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                Solver-dependent and subject to change.\n          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n          To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n          which is not used. Additionally, `precs` must supply the dispatch:\n          ```julia\n          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n          ```\n          which is used in the solver setup phase to construct the integrator\n          type with the preconditioners `(Pl,Pr)`.\n          The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n          is defined as:\n          ```julia\n          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n          ```)\n\nRosenbrock-Wanner Method.  An A-stable 4th order Rosenbrock method. Essentially \"anti-L-stable\" but efficient.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nKaps, P. & Rentrop, Generalized Runge-Kutta methods of order four with stepsize control for stiff ordinary differential equations. P. Numer. Math. (1979) 33: 55. doi:10.1007/BF01396495\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Ros4LStab","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Ros4LStab","text":"Ros4LStab(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n                ForwardDiff default function-specific tags. For more information, see\n                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n                Defaults to `Val{true}()`.\n            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n                to specify whether to use automatic differentiation via\n                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n                `nothing`, which means it will be chosen true/false depending on circumstances\n                of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n              `Ros4LStab(linsolve = KLUFactorization()`).\n               When `nothing` is passed, uses `DefaultLinearSolver`.\n            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n              can be used as a left or right preconditioner.\n              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n              function where the arguments are defined as:\n                - `W`: the current Jacobian of the nonlinear system. Specified as either\n                    ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                    representation of the operator. Users can construct the W-matrix on demand\n                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                    the `jac_prototype`.\n                - `du`: the current ODE derivative\n                - `u`: the current ODE state\n                - `p`: the ODE parameters\n                - `t`: the current ODE time\n                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                    the last call to `precs`. It is recommended that this is checked to only\n                    update the preconditioner when `newW == true`.\n                - `Plprev`: the previous `Pl`.\n                - `Prprev`: the previous `Pr`.\n                - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                    Solver-dependent and subject to change.\n              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n              To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n              which is not used. Additionally, `precs` must supply the dispatch:\n              ```julia\n              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n              ```\n              which is used in the solver setup phase to construct the integrator\n              type with the preconditioners `(Pl,Pr)`.\n              The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n              is defined as:\n              ```julia\n              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n              ```)\n\nRosenbrock-Wanner Method.  A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"fullyimplicitdae/BDF/#OrdinaryDiffEqBDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"BDF (Backward Differentiation Formula) methods for fully implicit differential-algebraic equations (DAEs) in the form F(du/dt, u, t) = 0. These methods provide robust integration for index-1 DAE systems with fully implicit formulations.\n\nwarn: Performance Consideration\nDFBDF and family have not been made fully efficient yet, and thus Sundials.jl IDA is recommended for production use.","category":"section"},{"location":"fullyimplicitdae/BDF/#Key-Properties","page":"OrdinaryDiffEqBDF","title":"Key Properties","text":"Fully implicit DAE BDF methods provide:\n\nGeneral DAE capability for F(du/dt, u, t) = 0 formulations\nIndex-1 DAE support for properly formulated DAE systems\nRobust nonlinear solver integration for implicit equation systems\nHigh-order accuracy with excellent stability properties\nLarge stiff system capability with efficient linear algebra","category":"section"},{"location":"fullyimplicitdae/BDF/#When-to-Use-Fully-Implicit-DAE-BDF-Methods","page":"OrdinaryDiffEqBDF","title":"When to Use Fully Implicit DAE BDF Methods","text":"These methods are recommended for:\n\nFully implicit DAE systems where F(du/dt, u, t) = 0 cannot be easily rearranged\nIndex-1 DAE problems that cannot be easily rearranged to semi-explicit form\nMultibody dynamics with complex kinematic constraints\nElectrical circuits with ideal components and algebraic loops\nChemical engineering with equilibrium and conservation constraints\nLarge-scale DAE systems requiring robust implicit integration","category":"section"},{"location":"fullyimplicitdae/BDF/#Mathematical-Background","page":"OrdinaryDiffEqBDF","title":"Mathematical Background","text":"Fully implicit DAEs have the general form: F(du/dt, u, t) = 0\n\nUnlike semi-explicit forms, these cannot be written as du/dt = f(u,t) even after constraint elimination. BDF methods discretize the time derivative using backward differences and solve the resulting nonlinear system at each timestep.","category":"section"},{"location":"fullyimplicitdae/BDF/#Problem-Formulation","page":"OrdinaryDiffEqBDF","title":"Problem Formulation","text":"Use DAEProblem with implicit function specification:\n\nfunction f2(out, du, u, p, t)\n    out[1] = -0.04u[1] + 1e4 * u[2] * u[3] - du[1]\n    out[2] = +0.04u[1] - 3e7 * u[2]^2 - 1e4 * u[2] * u[3] - du[2]\n    out[3] = u[1] + u[2] + u[3] - 1.0\nend\nu₀ = [1.0, 0, 0]\ndu₀ = [-0.04, 0.04, 0.0]\ntspan = (0.0, 100000.0)\ndifferential_vars = [true, true, false]\nprob = DAEProblem(f2, du₀, u₀, tspan, differential_vars = differential_vars)\nsol = solve(prob, DFBDF())","category":"section"},{"location":"fullyimplicitdae/BDF/#Solver-Selection-Guide","page":"OrdinaryDiffEqBDF","title":"Solver Selection Guide","text":"","category":"section"},{"location":"fullyimplicitdae/BDF/#Recommended-DAE-Methods","page":"OrdinaryDiffEqBDF","title":"Recommended DAE Methods","text":"DFBDF: Recommended - Variable-order BDF for general DAE systems\nDImplicitEuler: For non-smooth problems with discontinuities","category":"section"},{"location":"fullyimplicitdae/BDF/#Method-characteristics","page":"OrdinaryDiffEqBDF","title":"Method characteristics","text":"DFBDF: Most robust and efficient for general smooth DAE problems\nDImplicitEuler: Best choice for problems with discontinuities, events, or non-smooth behavior","category":"section"},{"location":"fullyimplicitdae/BDF/#Performance-Guidelines","page":"OrdinaryDiffEqBDF","title":"Performance Guidelines","text":"","category":"section"},{"location":"fullyimplicitdae/BDF/#When-fully-implicit-DAE-BDF-methods-excel","page":"OrdinaryDiffEqBDF","title":"When fully implicit DAE BDF methods excel","text":"Index-1 DAE systems with complex implicit structure\nComplex constraint structures with multiple algebraic relationships\nLarge-scale problems where specialized DAE methods are essential\nMultiphysics simulations with mixed differential-algebraic structure\nProblems where semi-explicit formulation is impractical","category":"section"},{"location":"fullyimplicitdae/BDF/#Index-considerations","page":"OrdinaryDiffEqBDF","title":"Index considerations","text":"Index-1 formulation required: Problems should be written in index-1 form\nCompare with mass matrix methods: For some index-1 problems, mass matrix formulation may be more efficient\nHigher-index problems: Should be reduced to index-1 form before using these methods","category":"section"},{"location":"fullyimplicitdae/BDF/#Important-DAE-Requirements","page":"OrdinaryDiffEqBDF","title":"Important DAE Requirements","text":"","category":"section"},{"location":"fullyimplicitdae/BDF/#Initial-conditions","page":"OrdinaryDiffEqBDF","title":"Initial conditions","text":"Both u₀ and du₀ must be provided and consistent with constraints\ndifferential_vars specification helps identify algebraic variables\nConsistent initialization is crucial for index-1 DAE problems","category":"section"},{"location":"fullyimplicitdae/BDF/#Function-specification","page":"OrdinaryDiffEqBDF","title":"Function specification","text":"Residual form: F(du/dt, u, t) = 0 with F returning zero for satisfied equations\nProper scaling: Ensure equations are well-conditioned numerically\nJacobian availability: Analytical Jacobians improve performance when available","category":"section"},{"location":"fullyimplicitdae/BDF/#Alternative-Approaches","page":"OrdinaryDiffEqBDF","title":"Alternative Approaches","text":"Consider these alternatives:\n\nMass matrix DAE methods for index-1 problems with M du/dt = f(u,t) structure\nIndex reduction techniques using ModelingToolkit.jl to convert problems to index-1 form if needed\nConstraint stabilization methods for drift control\nProjection methods for manifold preservation\n\nFor more details on DAE formulations and alternative approaches, see this blog post on Neural DAEs.\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqBDF\", \"DFBDF\")","category":"section"},{"location":"fullyimplicitdae/BDF/#Full-list-of-solvers","page":"OrdinaryDiffEqBDF","title":"Full list of solvers","text":"","category":"section"},{"location":"fullyimplicitdae/BDF/#DAE","page":"OrdinaryDiffEqBDF","title":"DAE","text":"","category":"section"},{"location":"fullyimplicitdae/BDF/#OrdinaryDiffEqBDF.DImplicitEuler","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.DImplicitEuler","text":"DImplicitEuler(; chunk_size = Val{0}(),\n                 autodiff = AutoForwardDiff(),\n                 standardtag = Val{true}(),\n                 concrete_jac = nothing,\n                 linsolve = nothing,\n                 precs = DEFAULT_PRECS,\n                 nlsolve = NLNewton(),\n                 extrapolant = :constant,\n                 controller = :Standard)\n\nMultistep Method. 1st order A-L and stiffly stable adaptive implicit Euler. Implicit Euler for implicit DAE form. It uses an apriori error estimator for adaptivity based on a finite differencing approximation from SPICE.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify DImplicitEuler(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n\n\n\n\n","category":"type"},{"location":"fullyimplicitdae/BDF/#OrdinaryDiffEqBDF.DABDF2","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.DABDF2","text":"DABDF2(; chunk_size = Val{0}(),\n         autodiff = AutoForwardDiff(),\n         standardtag = Val{true}(),\n         concrete_jac = nothing,\n         linsolve = nothing,\n         precs = DEFAULT_PRECS,\n         nlsolve = NLNewton(),\n         extrapolant = :constant,\n         controller = :Standard)\n\nMultistep Method. 2nd order A-L stable adaptive BDF method. Fully implicit implementation of BDF2.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify DABDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{celaya2014implementation, title={Implementation of an Adaptive BDF2 Formula and Comparison with the MATLAB Ode15s}, author={Celaya, E Alberdi and Aguirrezabala, JJ Anza and Chatzipantelidis, Panagiotis}, journal={Procedia Computer Science}, volume={29}, pages={1014–1026}, year={2014}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"fullyimplicitdae/BDF/#OrdinaryDiffEqBDF.DFBDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.DFBDF","text":"DFBDF(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        κ = nothing,\n        tol = nothing,\n        nlsolve = NLNewton(),\n        extrapolant = :linear,\n        controller = :Standard,\n        max_order::Val{MO} = Val{5}())\n\nMultistep Method. Fixed-leading coefficient adaptive-order adaptive-time BDF method. Fully implicit implementation of FBDF based on Shampine's\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify DFBDF(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- κ: TBD\ntol: TBD\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\nmax_order: TBD\n\nReferences\n\n@article{shampine2002solving, title={Solving 0= F (t, y (t), y′(t)) in Matlab}, author={Shampine, Lawrence F}, year={2002}, publisher={Walter de Gruyter GmbH and Co. KG} }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK","text":"Low-order explicit Runge-Kutta methods for non-stiff differential equations. Most of the time, you should use Tsit5, which is the most common and efficient low-order RK method. The alternative methods provided here are for special circumstances where Tsit5 is not suitable.","category":"section"},{"location":"explicit/LowOrderRK/#Key-Properties","page":"OrdinaryDiffEqLowOrderRK","title":"Key Properties","text":"Low-order explicit RK methods offer:\n\nComputational efficiency at higher tolerances (>1e-6)\nRobust error control for difficult non-stiff problems\nSpecialized interpolation properties for applications requiring dense output\nLower-order derivatives requirements for non-smooth functions\nGood performance for specific problem types","category":"section"},{"location":"explicit/LowOrderRK/#When-to-Use-Alternative-Low-Order-RK-Methods","page":"OrdinaryDiffEqLowOrderRK","title":"When to Use Alternative Low-Order RK Methods","text":"Choose these methods instead of Tsit5 when:\n\nODE function f is not differentiable to 5th order - use lower-order methods (the more discontinuous, the lower the order needed)\nHeavy use of interpolations - OwrenZen methods have superior interpolation convergence\nDelay differential equations - OwrenZen methods are most efficient (see SciMLBenchmarks)\nVery high tolerances (>1e-3) - BS3 is more efficient than Tsit5\nQuadratic polynomial ODEs - SIR54 is optimized for these systems\nEducational purposes - simpler methods for understanding algorithms","category":"section"},{"location":"explicit/LowOrderRK/#Solver-Selection-Guide","page":"OrdinaryDiffEqLowOrderRK","title":"Solver Selection Guide","text":"","category":"section"},{"location":"explicit/LowOrderRK/#Primary-recommendation","page":"OrdinaryDiffEqLowOrderRK","title":"Primary recommendation","text":"For most problems, use Tsit5 instead of these methods.","category":"section"},{"location":"explicit/LowOrderRK/#High-tolerances-(1e-3)","page":"OrdinaryDiffEqLowOrderRK","title":"High tolerances (>1e-3)","text":"BS3: Third-order Bogacki-Shampine method, most efficient for very high tolerances","category":"section"},{"location":"explicit/LowOrderRK/#Superior-interpolation-needs","page":"OrdinaryDiffEqLowOrderRK","title":"Superior interpolation needs","text":"OwrenZen3: Third-order with excellent interpolation convergence\nOwrenZen5: Fifth-order with excellent interpolation, optimal for DDEs\nOwrenZen4: Fourth-order interpolation-optimized method","category":"section"},{"location":"explicit/LowOrderRK/#Non-smooth-or-discontinuous-ODEs","page":"OrdinaryDiffEqLowOrderRK","title":"Non-smooth or discontinuous ODEs","text":"BS3: Third-order for mildly non-smooth functions\nHeun: Second-order for more discontinuous functions (not generally recommended)\nEuler: First-order for highly discontinuous problems","category":"section"},{"location":"explicit/LowOrderRK/#Robust-error-control-alternatives","page":"OrdinaryDiffEqLowOrderRK","title":"Robust error control alternatives","text":"BS5: Fifth-order with very robust error estimation\nDP5: Fifth-order Dormand-Prince method, classical alternative to Tsit5","category":"section"},{"location":"explicit/LowOrderRK/#Specialized-applications","page":"OrdinaryDiffEqLowOrderRK","title":"Specialized applications","text":"RK4: Fourth-order with special residual error control, good for DDEs. Note: Uses adaptive timestepping by default - set adaptive=false in solve() for traditional fixed-step RK4\nSIR54: Fifth-order optimized for ODEs defined by quadratic polynomials (e.g., SIR-type epidemiological models)\nStepanov5: Fifth-order method with enhanced stability properties and optimized error constants\nRalston: Second-order with optimized error constants","category":"section"},{"location":"explicit/LowOrderRK/#Periodic-and-oscillatory-problems","page":"OrdinaryDiffEqLowOrderRK","title":"Periodic and oscillatory problems","text":"Anas5: Fifth-order optimized for periodic problems with minimal phase error\nFRK65: Sixth-order zero dissipation method for oscillatory problems","category":"section"},{"location":"explicit/LowOrderRK/#Advanced-specialized-methods","page":"OrdinaryDiffEqLowOrderRK","title":"Advanced specialized methods","text":"RKO65: Sixth-order optimized method\nMSRK5, MSRK6: Multi-stage methods for specific applications\nPSRK4p7q6, PSRK3p5q4, PSRK3p6q5: Pseudo-symplectic methods\nAlshina2, Alshina3, Alshina6: Methods with optimized parameters\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqLowOrderRK\", \"BS3\")","category":"section"},{"location":"explicit/LowOrderRK/#Full-list-of-solvers","page":"OrdinaryDiffEqLowOrderRK","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Euler","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Euler","text":"Euler()\n\nExplicit Runge-Kutta Method. The canonical forward Euler method. Fixed timestep only.\n\nKeyword Arguments\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I. Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics, Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Heun","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Heun","text":"Heun(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n       step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n       thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  The second order Heun's method. Uses embedded Euler method for adaptivity.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I. Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics, Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Ralston","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Ralston","text":"Ralston(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  The optimized second order midpoint method. Uses embedded Euler method for adaptivity.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I. Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics, Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Midpoint","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Midpoint","text":"Midpoint(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  The second order midpoint method. Uses embedded Euler method for adaptivity.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I. Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics, Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.RK4","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.RK4","text":"RK4(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  The canonical Runge-Kutta Order 4 method. Uses a defect control for adaptive stepping using maximum error over the whole interval. Classic fourth-order method. Good for medium accuracy calculations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{shampine2005solving,       title={Solving ODEs and DDEs with residual control},       author={Shampine, LF},       journal={Applied Numerical Mathematics},       volume={52},       number={1},       pages={113–127},       year={2005},       publisher={Elsevier}       }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.BS3","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.BS3","text":"BS3(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Bogacki-Shampine 3/2 method. Third-order adaptive method using embedded Euler method for adaptivity. Recommended for non-stiff problems at moderate tolerances.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{bogacki19893,     title={A 3 (2) pair of Runge-Kutta formulas},     author={Bogacki, Przemyslaw and Shampine, Lawrence F},     journal={Applied Mathematics Letters},     volume={2},     number={4},     pages={321–325},     year={1989},     publisher={Elsevier}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.OwrenZen3","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.OwrenZen3","text":"OwrenZen3(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Owren-Zennaro optimized interpolation 3/2 method (free 3rd order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{owren1992derivation,     title={Derivation of efficient, continuous, explicit Runge–Kutta methods},     author={Owren, Brynjulf and Zennaro, Marino},     journal={SIAM journal on scientific and statistical computing},     volume={13},     number={6},     pages={1488–1501},     year={1992},     publisher={SIAM}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.OwrenZen4","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.OwrenZen4","text":"OwrenZen4(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Owren-Zennaro optimized interpolation 4/3 method (free 4th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{owren1992derivation,     title={Derivation of efficient, continuous, explicit Runge–Kutta methods},     author={Owren, Brynjulf and Zennaro, Marino},     journal={SIAM journal on scientific and statistical computing},     volume={13},     number={6},     pages={1488–1501},     year={1992},     publisher={SIAM}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.OwrenZen5","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.OwrenZen5","text":"OwrenZen5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Owren-Zennaro optimized interpolation 5/4 method (free 5th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{owren1992derivation,     title={Derivation of efficient, continuous, explicit Runge–Kutta methods},     author={Owren, Brynjulf and Zennaro, Marino},     journal={SIAM journal on scientific and statistical computing},     volume={13},     number={6},     pages={1488–1501},     year={1992},     publisher={SIAM}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.BS5","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.BS5","text":"BS5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      thread = OrdinaryDiffEq.False(),\n      lazy = true)\n\nExplicit Runge-Kutta Method.  Bogacki-Shampine 5/4 Runge-Kutta method. (lazy 5th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nlazy: determines if the lazy interpolant is used.\n\nReferences\n\n@article{bogacki1996efficient,     title={An efficient runge-kutta (4, 5) pair},     author={Bogacki, P and Shampine, Lawrence F},     journal={Computers \\& Mathematics with Applications},     volume={32},     number={6},     pages={15–28},     year={1996},     publisher={Elsevier}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.DP5","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.DP5","text":"DP5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Dormand-Prince's 5/4 Runge-Kutta method. (free 4th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{dormand1980family,     title={A family of embedded Runge-Kutta formulae},     author={Dormand, John R and Prince, Peter J},     journal={Journal of computational and applied mathematics},     volume={6},     number={1},     pages={19–26},     year={1980},     publisher={Elsevier}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Anas5","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Anas5","text":"Anas5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False(),\n        w = 1)\n\nExplicit Runge-Kutta Method.  4th order Runge-Kutta method designed for periodic problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nw: a periodicity estimate, which when accurate the method becomes 5th order\n\n(and is otherwise 4th order with less error for better estimates).\n\nReferences\n\n@article{anastassi2005optimized, title={An optimized Runge–Kutta method for the solution of orbital problems}, author={Anastassi, ZA and Simos, TE}, journal={Journal of Computational and Applied Mathematics}, volume={175}, number={1}, pages={1–9}, year={2005}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.RKO65","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.RKO65","text":"RKO65(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Tsitouras' Runge-Kutta-Oliver 6 stage 5th order method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nTsitouras, Ch. \"Explicit Runge–Kutta methods for starting integration of     Lane–Emden problem.\" Applied Mathematics and Computation 354 (2019): 353-364.     doi: https://doi.org/10.1016/j.amc.2019.02.047\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.FRK65","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.FRK65","text":"FRK65(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False(),\n        omega = 0.0)\n\nExplicit Runge-Kutta Method.  Zero Dissipation Runge-Kutta of 6th order.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nomega: a periodicity phase estimate,\n\nwhen accurate this method results in zero numerical dissipation.\n\nReferences\n\n@article{medvedev2018fitted, title={Fitted modifications of Runge-Kutta pairs of orders 6 (5)}, author={Medvedev, Maxim A and Simos, TE and Tsitouras, Ch}, journal={Mathematical Methods in the Applied Sciences}, volume={41}, number={16}, pages={6184–6194}, year={2018}, publisher={Wiley Online Library}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.RKM","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.RKM","text":"RKM(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Method designed to have good stability properties when applied to pseudospectral discretizations of hyperbolic partial differential equaitons.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{mead1999optimal,   title={Optimal Runge–Kutta methods for first order pseudospectral operators},   author={Mead, JL and Renaut, RA},   journal={Journal of Computational Physics},   volume={152},   number={1},   pages={404–419},   year={1999},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.MSRK5","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.MSRK5","text":"MSRK5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  5th order method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nMisha Stepanov - https://arxiv.org/pdf/2202.08443.pdf : Figure 3.\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.MSRK6","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.MSRK6","text":"MSRK6(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  6th order method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nMisha Stepanov - https://arxiv.org/pdf/2202.08443.pdf : Table4\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.PSRK4p7q6","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.PSRK4p7q6","text":"PSRK4p7q6(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  6-stage Pseudo-Symplectic method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Aubry1998,     author = {A. Aubry and P. Chartier},     journal = {BIT Numer. Math.},     title =  {Pseudo-symplectic {R}unge-{K}utta methods},     volume = {38},     PAGES = {439-461},     year = {1998},     },     @article{Capuano2017,     title = {Explicit {R}unge–{K}utta schemes for incompressible flow with improved energy-conservation properties},     journal = {J. Comput. Phys.},     volume = {328},     pages = {86-94},     year = {2017},     issn = {0021-9991},     doi = {https://doi.org/10.1016/j.jcp.2016.10.040},     author = {F. Capuano and G. Coppola and L. Rández and L. {de Luca}},}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.PSRK3p5q4","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.PSRK3p5q4","text":"PSRK3p5q4(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  4-stage Pseudo-Symplectic method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Aubry1998,     author = {A. Aubry and P. Chartier},     journal = {BIT Numer. Math.},     title =  {Pseudo-symplectic {R}unge-{K}utta methods},     year = {1998},     },     @article{Capuano2017,     title = {Explicit {R}unge–{K}utta schemes for incompressible flow with improved energy-conservation properties},     journal = {J. Comput. Phys.},     year = {2017},     author = {F. Capuano and G. Coppola and L. Rández and L. {de Luca}},}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.PSRK3p6q5","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.PSRK3p6q5","text":"PSRK3p6q5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  5-stage Pseudo-Symplectic method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Aubry1998,     author = {A. Aubry and P. Chartier},     journal = {BIT Numer. Math.},     title =  {Pseudo-symplectic {R}unge-{K}utta methods},     year = {1998},     },     @article{Capuano2017,     title = {Explicit {R}unge–{K}utta schemes for incompressible flow with improved energy-conservation properties},     journal = {J. Comput. Phys.},     year = {2017},     author = {F. Capuano and G. Coppola and L. Rández and L. {de Luca}},}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Stepanov5","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Stepanov5","text":"Stepanov5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  5th order method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Stepanov2021Embedded5,     title={Embedded (4, 5) pairs of explicit 7-stage Runge–Kutta methods with FSAL property},     author={Misha Stepanov},     journal={Calcolo},     year={2021},     volume={59}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.SIR54","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.SIR54","text":"SIR54(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  5th order method suited for SIR-type epidemic models.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Kovalnogov2020RungeKuttaPS,     title={Runge–Kutta pairs suited for SIR‐type epidemic models},     author={Vladislav N. Kovalnogov and Theodore E. Simos and Ch. Tsitouras},     journal={Mathematical Methods in the Applied Sciences},     year={2020},     volume={44},     pages={5210 - 5216}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Alshina2","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Alshina2","text":"Alshina2(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  2nd order, 2-stage Method with optimal parameters.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Alshina2008,     doi = {10.1134/s0965542508030068},     url = {https://doi.org/10.1134/s0965542508030068},     year = {2008},     month = mar,     publisher = {Pleiades Publishing Ltd},     volume = {48},     number = {3},     pages = {395–405},     author = {E. A. Alshina and E. M. Zaks and N. N. Kalitkin},     title = {Optimal first- to sixth-order accurate Runge-Kutta schemes},     journal = {Computational Mathematics and Mathematical Physics}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Alshina3","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Alshina3","text":"Alshina3(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  3rd order, 3-stage Method with optimal parameters.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Alshina2008,     doi = {10.1134/s0965542508030068},     url = {https://doi.org/10.1134/s0965542508030068},     year = {2008},     month = mar,     publisher = {Pleiades Publishing Ltd},     volume = {48},     number = {3},     pages = {395–405},     author = {E. A. Alshina and E. M. Zaks and N. N. Kalitkin},     title = {Optimal first- to sixth-order accurate Runge-Kutta schemes},     journal = {Computational Mathematics and Mathematical Physics}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Alshina6","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Alshina6","text":"Alshina6(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  6th order, 7-stage Method with optimal parameters.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Alshina2008,     doi = {10.1134/s0965542508030068},     url = {https://doi.org/10.1134/s0965542508030068},     year = {2008},     month = mar,     publisher = {Pleiades Publishing Ltd},     volume = {48},     number = {3},     pages = {395–405},     author = {E. A. Alshina and E. M. Zaks and N. N. Kalitkin},     title = {Optimal first- to sixth-order accurate Runge-Kutta schemes},     journal = {Computational Mathematics and Mathematical Physics}     }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK","text":"Methods for semi-linear differential equations.","category":"section"},{"location":"semilinear/ExponentialRK/#Installation","page":"OrdinaryDiffEqExponentialRK","title":"Installation","text":"To be able to access the solvers in OrdinaryDiffEqLinear, you must first install them use the Julia package manager:\n\nusing Pkg\nPkg.add(\"OrdinaryDiffEqExponentialRK\")\n\nThis will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.","category":"section"},{"location":"semilinear/ExponentialRK/#Example-usage","page":"OrdinaryDiffEqExponentialRK","title":"Example usage","text":"using OrdinaryDiffEqExponentialRK, SciMLOperators\nA = [2.0 -1.0; -1.0 2.0]\nlinnonlin_f1 = MatrixOperator(A)\nlinnonlin_f2 = (du, u, p, t) -> du .= 1.01 .* u\nlinnonlin_fun_iip = SplitFunction(linnonlin_f1, linnonlin_f2)\ntspan = (0.0, 1.0)\nu0 = [0.1, 0.1]\nprob = SplitODEProblem(linnonlin_fun_iip, u0, tspan)\nsol = solve(prob, ETDRK4(), dt = 1 / 4)","category":"section"},{"location":"semilinear/ExponentialRK/#Full-list-of-solvers","page":"OrdinaryDiffEqExponentialRK","title":"Full list of solvers","text":"","category":"section"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK.LawsonEuler","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.LawsonEuler","text":"LawsonEuler(; krylov = false,\n              m = 30,\n              iop = 0)\n\nSemilinear ODE solver First order exponential Euler scheme (fixed timestepping)\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK.NorsettEuler","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.NorsettEuler","text":"NorsettEuler(; krylov = false,\n               m = 30,\n               iop = 0)\n\nSemilinear ODE solver First order exponential-RK scheme. Alias: ETD1\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETD2","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETD2","text":"ETD2: Exponential Runge-Kutta Method Second order Exponential Time Differencing method (in development).\n\n\n\n\n\n","category":"type"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETDRK2","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETDRK2","text":"ETDRK2(; krylov = false,\n         m = 30,\n         iop = 0)\n\nSemilinear ODE solver 2nd order exponential-RK scheme.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETDRK3","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETDRK3","text":"ETDRK3(; krylov = false,\n         m = 30,\n         iop = 0)\n\nSemilinear ODE solver 3rd order exponential-RK scheme.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETDRK4","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETDRK4","text":"ETDRK4(; krylov = false,\n         m = 30,\n         iop = 0)\n\nSemilinear ODE solver 4th order exponential-RK scheme (fixed timestepping)\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK.HochOst4","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.HochOst4","text":"HochOst4(; krylov = false,\n           m = 30,\n           iop = 0)\n\nSemilinear ODE solver 4th order exponential-RK scheme with stiff order 4.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton","text":"Adams-Bashforth and Adams-Moulton multistep methods for non-stiff differential equations. Note that Runge-Kutta methods generally come out as more efficient in benchmarks, except when the ODE function f is expensive to evaluate or the problem is very smooth. These methods can achieve high accuracy with fewer function evaluations per step than Runge-Kutta methods in those specific cases.","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#Key-Properties","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Key Properties","text":"Adams-Bashforth-Moulton methods provide:\n\nReduced function evaluations compared to Runge-Kutta methods\nHigh efficiency for expensive-to-evaluate functions\nMultistep structure using information from previous timesteps\nVariable step and order capabilities for adaptive integration\nPredictor-corrector variants for enhanced accuracy and stability\nGood stability properties for non-stiff problems","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#When-to-Use-Adams-Bashforth-Moulton-Methods","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"When to Use Adams-Bashforth-Moulton Methods","text":"These methods are recommended for:\n\nExpensive function evaluations where minimizing calls to f is critical\nNon-stiff smooth problems with regular solution behavior\nLong-time integration where efficiency over many steps matters\nProblems with expensive Jacobian computations that cannot use implicit methods efficiently\nScientific computing applications with computationally intensive right-hand sides\nSystems where startup cost of multistep methods is amortized over long integration","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#Method-Types","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Method Types","text":"","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#Explicit-Adams-Bashforth-(AB)","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Explicit Adams-Bashforth (AB)","text":"Pure explicit multistep methods using only past information:\n\nLower computational cost per step\nLess stability than predictor-corrector variants\nGood for mildly stiff problems","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#Predictor-Corrector-Adams-Bashforth-Moulton-(ABM)","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Predictor-Corrector Adams-Bashforth-Moulton (ABM)","text":"Implicit corrector step for enhanced accuracy:\n\nBetter accuracy than pure explicit methods\nImproved stability properties\nSlightly higher cost but often worth it","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#Solver-Selection-Guide","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Solver Selection Guide","text":"","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#Primary-recommendation","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Primary recommendation","text":"VCABM: Main recommendation - adaptive order variable-step Adams-Bashforth-Moulton, best overall choice for Adams methods","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#Variable-step-predictor-corrector-methods","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Variable-step predictor-corrector methods","text":"VCABM3: Third-order variable-step Adams-Bashforth-Moulton\nVCABM4: Fourth-order variable-step Adams-Bashforth-Moulton\nVCABM5: Fifth-order variable-step Adams-Bashforth-Moulton","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#Variable-step-Adams-Bashforth-methods","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Variable-step Adams-Bashforth methods","text":"VCAB3: Third-order variable-step Adams-Bashforth\nVCAB4: Fourth-order variable-step Adams-Bashforth\nVCAB5: Fifth-order variable-step Adams-Bashforth","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#Fixed-step-predictor-corrector-methods","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Fixed-step predictor-corrector methods","text":"ABM32: Third-order Adams-Bashforth-Moulton\nABM43: Fourth-order Adams-Bashforth-Moulton\nABM54: Fifth-order Adams-Bashforth-Moulton","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#Fixed-step-explicit-methods","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Fixed-step explicit methods","text":"AB3: Third-order Adams-Bashforth\nAB4: Fourth-order Adams-Bashforth\nAB5: Fifth-order Adams-Bashforth","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#Performance-Considerations","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Performance Considerations","text":"Most efficient when function evaluation dominates computational cost\nStartup phase requires initial steps from single-step method\nMemory efficient compared to high-order Runge-Kutta methods\nBest for smooth problems - avoid for problems with discontinuities\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqAdamsBashforthMoulton\", \"VCABM\")","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#Full-list-of-solvers","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#Explicit-Multistep-Methods","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Explicit Multistep Methods","text":"","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#Predictor-Corrector-Methods","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Predictor-Corrector Methods","text":"","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.AB3","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.AB3","text":"AB3(; thread = OrdinaryDiffEq.False())\n\nAdams-Bashforth Explicit Method The 3-step third order multistep method.         Ralston's Second Order Method is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.AB4","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.AB4","text":"AB4(; thread = OrdinaryDiffEq.False())\n\nAdams-Bashforth Explicit Method The 4-step fourth order multistep method.     Runge-Kutta method of order 4 is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.AB5","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.AB5","text":"AB5(; thread = OrdinaryDiffEq.False())\n\nAdams-Bashforth Explicit Method The 5-step fifth order multistep method.     Ralston's 3rd order Runge-Kutta method is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.ABM32","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.ABM32","text":"ABM32(; thread = OrdinaryDiffEq.False())\n\nAdams-Bashforth Explicit Method It is third order method.     In ABM32, AB3 works as predictor and Adams Moulton 2-steps method works as Corrector.     Ralston's Second Order Method is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.ABM43","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.ABM43","text":"ABM43(; thread = OrdinaryDiffEq.False())\n\nAdams-Bashforth Explicit Method It is fourth order method.     In ABM43, AB4 works as predictor and Adams Moulton 3-steps method works as Corrector.     Runge-Kutta method of order 4 is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.ABM54","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.ABM54","text":"ABM54(; thread = OrdinaryDiffEq.False())\n\nAdams-Bashforth Explicit Method It is fifth order method.     In ABM54, AB5 works as predictor and Adams Moulton 4-steps method works as Corrector.     Runge-Kutta method of order 4 is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.VCAB3","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.VCAB3","text":"VCAB3(; thread = OrdinaryDiffEq.False())\n\nAdams explicit Method The 3rd order Adams method.     Bogacki-Shampine 3/2 method is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.VCAB4","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.VCAB4","text":"VCAB4(; thread = OrdinaryDiffEq.False())\n\nAdams explicit Method The 4th order Adams method.     Runge-Kutta 4 is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.VCAB5","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.VCAB5","text":"VCAB5(; thread = OrdinaryDiffEq.False())\n\nAdams explicit Method The 5th order Adams method.     Runge-Kutta 4 is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.VCABM3","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.VCABM3","text":"VCABM3(; thread = OrdinaryDiffEq.False())\n\nAdams explicit Method The 3rd order Adams-Moulton method.     Bogacki-Shampine 3/2 method is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.VCABM4","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.VCABM4","text":"VCABM4(; thread = OrdinaryDiffEq.False())\n\nAdams explicit Method The 4th order Adams-Moulton method.     Runge-Kutta 4 is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.VCABM5","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.VCABM5","text":"VCABM5(; thread = OrdinaryDiffEq.False())\n\nAdams explicit Method The 5th order Adams-Moulton method.     Runge-Kutta 4 is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.VCABM","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.VCABM","text":"VCABM(; thread = OrdinaryDiffEq.False())\n\nadaptive order Adams explicit Method An adaptive order adaptive time Adams Moulton method.     It uses an order adaptivity algorithm is derived from Shampine's DDEABM.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN","text":"Runge-Kutta-Nyström (RKN) methods for solving second-order differential equations of the form d²u/dt² = f(u, du/dt, t). These methods are specifically designed for second-order ODEs and can be more efficient than converting to first-order systems when the problem has this natural structure.","category":"section"},{"location":"dynamicalodeexplicit/RKN/#Key-Properties","page":"OrdinaryDiffEqRKN","title":"Key Properties","text":"RKN methods provide:\n\nDirect integration of second-order ODEs without conversion to first-order systems\nEfficient handling of problems where velocity dependence is minimal or absent\nSpecialized variants for different types of second-order problems\nHigh-order accuracy with methods up to 12th order available\nTrigonometrically-fitted variants for oscillatory problems\nImproved efficiency for second-order problems compared to first-order conversions","category":"section"},{"location":"dynamicalodeexplicit/RKN/#When-to-Use-RKN-Methods","page":"OrdinaryDiffEqRKN","title":"When to Use RKN Methods","text":"These methods are recommended for:\n\nSecond-order differential equations with natural d²u/dt² = f(u, du/dt, t) structure\nClassical mechanics problems (Newton's equations of motion)\nOscillatory second-order systems (springs, pendulums, wave equations)\nProblems where velocity dependence is weak or absent\nCelestial mechanics and orbital dynamics\nVibration analysis and structural dynamics\nWave propagation problems in their natural second-order form","category":"section"},{"location":"dynamicalodeexplicit/RKN/#Problem-Types","page":"OrdinaryDiffEqRKN","title":"Problem Types","text":"","category":"section"},{"location":"dynamicalodeexplicit/RKN/#Velocity-independent-problems:-du/dt-f(u,-t)","page":"OrdinaryDiffEqRKN","title":"Velocity-independent problems: d²u/dt² = f(u, t)","text":"When the acceleration depends only on position (and possibly time):\n\nMore efficient specialized methods available\nClassical examples: gravitational problems, springs with F = -kx","category":"section"},{"location":"dynamicalodeexplicit/RKN/#Velocity-dependent-problems:-du/dt-f(u,-du/dt,-t)","page":"OrdinaryDiffEqRKN","title":"Velocity-dependent problems: d²u/dt² = f(u, du/dt, t)","text":"When acceleration depends on both position and velocity:\n\nGeneral RKN methods handle the full dependence\nExamples: damped oscillators, air resistance problems","category":"section"},{"location":"dynamicalodeexplicit/RKN/#Solver-Selection-Guide","page":"OrdinaryDiffEqRKN","title":"Solver Selection Guide","text":"","category":"section"},{"location":"dynamicalodeexplicit/RKN/#General-purpose-RKN-methods","page":"OrdinaryDiffEqRKN","title":"General-purpose RKN methods","text":"Nystrom4: Fourth-order method for general second-order ODEs\nIRKN3, IRKN4: Improved Runge-Kutta-Nyström methods","category":"section"},{"location":"dynamicalodeexplicit/RKN/#Velocity-independent-specialized-methods","page":"OrdinaryDiffEqRKN","title":"Velocity-independent specialized methods","text":"Nystrom4VelocityIndependent: Fourth-order for d²u/dt² = f(u, t)\nNystrom5VelocityIndependent: Fifth-order for d²u/dt² = f(u, t)","category":"section"},{"location":"dynamicalodeexplicit/RKN/#Velocity-dependent-methods","page":"OrdinaryDiffEqRKN","title":"Velocity-dependent methods","text":"FineRKN4: Fourth-order allowing velocity dependence\nFineRKN5: Fifth-order allowing velocity dependence","category":"section"},{"location":"dynamicalodeexplicit/RKN/#High-order-Dormand-Prince-variants","page":"OrdinaryDiffEqRKN","title":"High-order Dormand-Prince variants","text":"DPRKN4: Fourth-order Dormand-Prince RKN\nDPRKN5: Fifth-order Dormand-Prince RKN\nDPRKN6: Sixth-order with free interpolant\nDPRKN6FM: Sixth-order with optimized error coefficients\nDPRKN8: Eighth-order for high accuracy\nDPRKN12: Twelfth-order for extreme precision","category":"section"},{"location":"dynamicalodeexplicit/RKN/#Trigonometrically-fitted-methods-for-oscillatory-problems","page":"OrdinaryDiffEqRKN","title":"Trigonometrically-fitted methods for oscillatory problems","text":"ERKN4: Embedded 4(3) pair for periodic problems\nERKN5: Embedded 5(4) pair for periodic problems\nERKN7: Higher-order embedded pair for oscillatory systems","category":"section"},{"location":"dynamicalodeexplicit/RKN/#Specialized-methods","page":"OrdinaryDiffEqRKN","title":"Specialized methods","text":"RKN4: Fourth-order for linear inhomogeneous second-order IVPs","category":"section"},{"location":"dynamicalodeexplicit/RKN/#Advantages-Over-First-Order-Conversion","page":"OrdinaryDiffEqRKN","title":"Advantages Over First-Order Conversion","text":"Natural problem structure: Preserves the physical meaning of the equations\nSpecialized optimizations: Methods can exploit second-order structure\n\nTo be able to access the solvers in OrdinaryDiffEqRKN, you must first install them use the Julia package manager:\n\nusing Pkg\nPkg.add(\"OrdinaryDiffEqRKN\")\n\nThis will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.","category":"section"},{"location":"dynamicalodeexplicit/RKN/#Example-usage","page":"OrdinaryDiffEqRKN","title":"Example usage","text":"using OrdinaryDiffEqOrdinaryDiffEqRKN\nfunction HH_acceleration!(dv, v, u, p, t)\n    x, y = u\n    dx, dy = dv\n    dv[1] = -x - 2x * y\n    dv[2] = y^2 - y - x^2\nend\ninitial_positions = [0.0, 0.1]\ninitial_velocities = [0.5, 0.0]\ntspan = (0.0, 1.0)\nprob = SecondOrderODEProblem(HH_acceleration!, initial_velocities, initial_positions, tspan)\nsol = solve(prob, Nystrom4(), dt = 1 / 10)","category":"section"},{"location":"dynamicalodeexplicit/RKN/#Full-list-of-solvers","page":"OrdinaryDiffEqRKN","title":"Full list of solvers","text":"","category":"section"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.IRKN3","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.IRKN3","text":"IRKN3()\n\nImproved Runge-Kutta-Nyström method Method of order three, which minimizes the amount of evaluated functions in each step. Fixed time steps only. Second order ODE should not depend on the first derivative.\n\nKeyword Arguments\n\nReferences\n\n@article{rabiei2012numerical,     title={Numerical Solution of Second-Order Ordinary Differential Equations by Improved Runge-Kutta Nystrom Method},     author={Rabiei, Faranak and Ismail, Fudziah and Norazak, S and Emadi, Saeid},     publisher={Citeseer}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.IRKN4","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.IRKN4","text":"IRKN4()\n\nImproved Runge-Kutta-Nyström method Improves Runge-Kutta-Nyström method of order four,     which minimizes the amount of evaluated functions in each step.     Fixed time steps only.     Second order ODE should not be dependent on the first derivative.     Recommended for smooth problems with expensive functions to evaluate.\n\nKeyword Arguments\n\nReferences\n\n@article{rabiei2012numerical,     title={Numerical Solution of Second-Order Ordinary Differential Equations by Improved Runge-Kutta Nystrom Method},     author={Rabiei, Faranak and Ismail, Fudziah and Norazak, S and Emadi, Saeid},     publisher={Citeseer}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.Nystrom4","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.Nystrom4","text":"Nystrom4()\n\nImproved Runge-Kutta-Nyström method 4th order explicit Runge-Kutta-Nyström method. Allows acceleration to depend on velocity.\n\nKeyword Arguments\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I.     Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics,     Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.Nystrom4VelocityIndependent","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.Nystrom4VelocityIndependent","text":"Nystrom4VelocityIndependent()\n\nImproved Runge-Kutta-Nyström method A 4th order explicit method. Used directly on second order ODEs, where the acceleration is independent from velocity (ODE Problem is not dependent on the first derivative).\n\nKeyword Arguments\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I.     Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics,     Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.Nystrom5VelocityIndependent","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.Nystrom5VelocityIndependent","text":"Nystrom5VelocityIndependent()\n\nImproved Runge-Kutta-Nyström method A 5th order explicit method. Used directly on second order ODEs, where the acceleration is independent from velocity (ODE Problem is not dependent on the first derivative).\n\nKeyword Arguments\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I.     Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics,     Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.FineRKN4","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.FineRKN4","text":"FineRKN4()\n\nImproved Runge-Kutta-Nyström method A 4th order explicit method which can be applied directly to second order ODEs. In particular, this method allows the acceleration equation to depend on the velocity.\n\nKeyword Arguments\n\nReferences\n\n@article{fine1987low,     title={Low order practical {R}unge-{K}utta-{N}ystr{\"o}m methods},     author={Fine, Jerry Michael},     journal={Computing},     volume={38},     number={4},     pages={281–297},     year={1987},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.FineRKN5","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.FineRKN5","text":"FineRKN5()\n\nImproved Runge-Kutta-Nyström method A 5th order explicit method which can be applied directly to second order ODEs. In particular, this method allows the acceleration equation to depend on the velocity.\n\nKeyword Arguments\n\nReferences\n\n@article{fine1987low,     title={Low order practical {R}unge-{K}utta-{N}ystr{\"o}m methods},     author={Fine, Jerry Michael},     journal={Computing},     volume={38},     number={4},     pages={281–297},     year={1987},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.DPRKN4","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.DPRKN4","text":"DPRKN4()\n\nImproved Runge-Kutta-Nyström method 4th order explicit method.     The second order ODE should not depend on the first derivative.\n\nKeyword Arguments\n\nReferences\n\n@article{Dormand1987FamiliesOR,     title={Families of Runge-Kutta-Nystrom Formulae},     author={J. R. Dormand and Moawwad E. A. El-Mikkawy and P. J. Prince},     journal={Ima Journal of Numerical Analysis},     year={1987},     volume={7},     pages={235-250}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.DPRKN5","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.DPRKN5","text":"DPRKN5()\n\nImproved Runge-Kutta-Nyström method 5th order explicit method.     The second order ODE should not depend on the first derivative.\n\nKeyword Arguments\n\nReferences\n\n@article{Bettis1973ARN,     title={A Runge-Kutta Nystrom algorithm},     author={Dale G. Bettis},     journal={Celestial mechanics},     year={1973},     volume={8},     pages={229-233},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.DPRKN6","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.DPRKN6","text":"DPRKN6()\n\nImproved Runge-Kutta-Nyström method 6th order explicit method. The second order ODE should not depend on the first derivative. Free 6th order interpolant\n\nKeyword Arguments\n\nReferences\n\n@article{Dormand1987FamiliesOR,     title={Families of Runge-Kutta-Nystrom Formulae},     author={J. R. Dormand and Moawwad E. A. El-Mikkawy and P. J. Prince},     journal={Ima Journal of Numerical Analysis},     year={1987},     volume={7},     pages={235-250}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.DPRKN6FM","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.DPRKN6FM","text":"DPRKN6FM()\n\nImproved Runge-Kutta-Nyström method 6th order explicit method.     The second order ODE should not depend on the first derivative.     Compared to DPRKN6, this method has smaller truncation error coefficients     which leads to performance gain when only the main solution points are considered.\n\nKeyword Arguments\n\nReferences\n\n@article{Dormand1987FamiliesOR,     title={Families of Runge-Kutta-Nystrom Formulae},     author={J. R. Dormand and Moawwad E. A. El-Mikkawy and P. J. Prince},     journal={Ima Journal of Numerical Analysis},     year={1987},     volume={7},     pages={235-250}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.DPRKN8","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.DPRKN8","text":"DPRKN8()\n\nImproved Runge-Kutta-Nyström method 8th order explicit method.     The second order ODE should not depend on the first derivative.     Not as efficient as DPRKN12 when high accuracy is needed,     however this solver is competitive with DPRKN6 at lax tolerances and,     depending on the problem, might be a good option between performance and accuracy.\n\nKeyword Arguments\n\nReferences\n\n@article{dormand1987high,     title={High-order embedded Runge-Kutta-Nystrom formulae},     author={Dormand, JR and El-Mikkawy, MEA and Prince, PJ},     journal={IMA Journal of Numerical Analysis},     volume={7},     number={4},     pages={423–430},     year={1987},     publisher={Oxford University Press}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.DPRKN12","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.DPRKN12","text":"DPRKN12()\n\nImproved Runge-Kutta-Nyström method 12th order explicit method.     The second order ODE should not depend on the first derivative.     Most efficient when high accuracy is needed.\n\nKeyword Arguments\n\nReferences\n\n@article{dormand1987high,     title={High-order embedded Runge-Kutta-Nystrom formulae},     author={Dormand, JR and El-Mikkawy, MEA and Prince, PJ},     journal={IMA Journal of Numerical Analysis},     volume={7},     number={4},     pages={423–430},     year={1987},     publisher={Oxford University Press}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.ERKN4","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.ERKN4","text":"ERKN4()\n\nImproved Runge-Kutta-Nyström method Embedded 4(3) pair of explicit methods.     Integrates the periodic properties of the harmonic oscillator exactly.     The second order ODE should not depend on the first derivative.     Uses adaptive step size control. This method is extra efficient on periodic problems.\n\nKeyword Arguments\n\nReferences\n\n@article{demba2017embedded,     title={An Embedded 4 (3) Pair of Explicit Trigonometrically-Fitted Runge-Kutta-Nystr{\"o}m Method for Solving Periodic Initial Value Problems},     author={Demba, MA and Senu, N and Ismail, F},     journal={Applied Mathematical Sciences},     volume={11},     number={17},     pages={819–838},     year={2017}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.ERKN5","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.ERKN5","text":"ERKN5()\n\nImproved Runge-Kutta-Nyström method Embedded 5(4) pair of explicit methods.     Integrates the periodic properties of the harmonic oscillator exactly.     The second order ODE should not depend on the first derivative.     Uses adaptive step size control. This method is extra efficient on periodic problems.\n\nKeyword Arguments\n\nReferences\n\n@article{demba20165,     title={A 5 (4) Embedded Pair of Explicit Trigonometrically-Fitted Runge–Kutta–Nystr{\"o}m Methods for the Numerical Solution of Oscillatory Initial Value     Problems},     author={Demba, Musa A and Senu, Norazak and Ismail, Fudziah},     journal={Mathematical and Computational Applications},     volume={21},     number={4},     pages={46},     year={2016},     publisher={Multidisciplinary Digital Publishing Institute}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.ERKN7","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.ERKN7","text":"ERKN7()\n\nImproved Runge-Kutta-Nyström method Embedded pair of explicit methods.     Integrates the periodic properties of the harmonic oscillator exactly.     The second order ODE should not depend on the first derivative.     Uses adaptive step size control. This method is extra efficient on periodic problems.\n\nKeyword Arguments\n\nReferences\n\n@article{SimosOnHO,     title={On high order Runge-Kutta-Nystr{\"o}m pairs},     author={Theodore E. Simos and Ch. Tsitouras},     journal={J. Comput. Appl. Math.},     volume={400},     pages={113753}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.RKN4","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.RKN4","text":"RKN4()\n\nImproved Runge-Kutta-Nyström method 3 stage fourth order method to solve second order linear inhomogeneous IVPs. Does not include an adaptive method. Solves for for d-dimensional differential systems of second order linear inhomogeneous equations.\n\nwarning: Warning\n\n\nThis method is only fourth order for these systems, the method is second order otherwise!\n\nKeyword Arguments\n\nReferences\n\n@article{MONTIJANO2024115533,     title = {Explicit Runge–Kutta–Nyström methods for the numerical solution of second order linear inhomogeneous IVPs},     author = {J.I. Montijano and L. Rández and M. Calvo},     journal = {Journal of Computational and Applied Mathematics},     volume = {438},     pages = {115533},     year = {2024},}\n\n\n\n\n\n","category":"type"},{"location":"explicit/QPRK/#OrdinaryDiffEqQPRK","page":"OrdinaryDiffEqQPRK","title":"OrdinaryDiffEqQPRK","text":"Quadruple-precision parallel Runge-Kutta (QPRK) methods are high-order explicit solvers specifically designed for ultra-high precision computations using quad-precision arithmetic (Float128). These methods combine parallel evaluation capabilities with coefficients optimized for extended precision arithmetic. Note: These methods are still under-benchmarked and need more research.","category":"section"},{"location":"explicit/QPRK/#Key-Properties","page":"OrdinaryDiffEqQPRK","title":"Key Properties","text":"QPRK methods provide:\n\nUltra-high-order accuracy (9th order) for maximum precision\nQuadruple-precision optimization specifically designed for Float128\nParallel function evaluations for computational efficiency\nExtreme precision capabilities for very demanding applications\nOptimized coefficients for extended precision arithmetic","category":"section"},{"location":"explicit/QPRK/#When-to-Use-QPRK-Methods","page":"OrdinaryDiffEqQPRK","title":"When to Use QPRK Methods","text":"These methods are recommended for:\n\nUltra-high precision requirements demanding Float128 arithmetic\nExtremely low tolerances (< 1e-20) where standard precision fails\nScientific applications requiring maximum possible accuracy\nParallel computing environments with quad-precision support\nResearch applications exploring limits of numerical precision\nLong-time integration where error accumulation must be minimized to extreme levels","category":"section"},{"location":"explicit/QPRK/#Important-Requirements","page":"OrdinaryDiffEqQPRK","title":"Important Requirements","text":"","category":"section"},{"location":"explicit/QPRK/#Precision-Requirements","page":"OrdinaryDiffEqQPRK","title":"Precision Requirements","text":"Must use Float128 or higher precision number types\nAll problem components should support extended precision\nTolerances should match the precision capabilities (< 1e-20)","category":"section"},{"location":"explicit/QPRK/#Computational-Considerations","page":"OrdinaryDiffEqQPRK","title":"Computational Considerations","text":"Slower than standard precision methods due to extended precision arithmetic\nHigher memory usage due to extended precision\nLimited hardware support for quad-precision operations","category":"section"},{"location":"explicit/QPRK/#Mathematical-Background","page":"OrdinaryDiffEqQPRK","title":"Mathematical Background","text":"QPRK methods use tableaus with coefficients computed in extended precision to maintain accuracy throughout the ultra-high precision computation. The parallel structure allows independent function evaluations to be computed simultaneously.","category":"section"},{"location":"explicit/QPRK/#Solver-Selection-Guide","page":"OrdinaryDiffEqQPRK","title":"Solver Selection Guide","text":"","category":"section"},{"location":"explicit/QPRK/#Available-methods","page":"OrdinaryDiffEqQPRK","title":"Available methods","text":"QPRK98: Ninth-order method optimized for quad-precision arithmetic with parallel evaluation","category":"section"},{"location":"explicit/QPRK/#Usage-guidelines","page":"OrdinaryDiffEqQPRK","title":"Usage guidelines","text":"Essential to use Float128 for the state vector and parameters\nConsider MultiFloats.jl for higher precision number types\nSet very low tolerances (e.g., 1e-25) to utilize full precision\nTest against alternatives like Feagin methods with BigFloat","category":"section"},{"location":"explicit/QPRK/#Performance-Considerations","page":"OrdinaryDiffEqQPRK","title":"Performance Considerations","text":"Slower than standard precision methods due to extended precision arithmetic\nMemory intensive due to extended precision storage\nHardware dependent - some architectures lack efficient quad-precision support","category":"section"},{"location":"explicit/QPRK/#Alternative-High-Precision-Methods","page":"OrdinaryDiffEqQPRK","title":"Alternative High-Precision Methods","text":"For ultra-high precision, also consider:\n\nFeagin methods with BigFloat for arbitrary precision\nArbitrary precision extrapolation methods\nVerner methods with BigFloat for slightly lower but efficient precision\nTaylor series methods with automatic differentiation for extreme precision","category":"section"},{"location":"explicit/QPRK/#Usage-Example","page":"OrdinaryDiffEqQPRK","title":"Usage Example","text":"using OrdinaryDiffEqQPRK\n# Ensure using Float128 for ultra-high precision\nu0 = Float128[1.0, 0.0]\ntspan = (Float128(0.0), Float128(10.0))\nprob = ODEProblem(f, u0, tspan)\nsol = solve(prob, QPRK98(), abstol = 1e-25, reltol = 1e-25)\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqQPRK\", \"QPRK98\")","category":"section"},{"location":"explicit/QPRK/#Full-list-of-solvers","page":"OrdinaryDiffEqQPRK","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/QPRK/#OrdinaryDiffEqQPRK.QPRK98","page":"OrdinaryDiffEqQPRK","title":"OrdinaryDiffEqQPRK.QPRK98","text":"QPRK98(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Runge–Kutta pairs of orders 9(8) for use in quadruple precision computations\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nKovalnogov VN, Fedorov RV, Karpukhina TV, Simos TE, Tsitouras C. Runge–Kutta pairs      of orders 9 (8) for use in quadruple precision computations. Numerical Algorithms, 2023.      doi: https://doi.org/10.1007/s11075-023-01632-8\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock","text":"Rosenbrock methods for mass matrix differential-algebraic equations (DAEs) and stiff ODEs with singular mass matrices. These methods provide efficient integration for moderately stiff systems with algebraic constraints, offering excellent performance for small to medium-sized DAE problems.","category":"section"},{"location":"massmatrixdae/Rosenbrock/#Key-Properties","page":"OrdinaryDiffEqRosenbrock","title":"Key Properties","text":"Mass matrix Rosenbrock methods provide:\n\nDAE capability for index-1 differential-algebraic equations\nW-method efficiency using approximate Jacobians for computational savings\nMass matrix support for singular and non-diagonal mass matrices\nModerate to high order accuracy (2nd to 6th order available)\nGood stability properties with stiffly accurate behavior\nEmbedded error estimation for adaptive timestepping","category":"section"},{"location":"massmatrixdae/Rosenbrock/#When-to-Use-Mass-Matrix-Rosenbrock-Methods","page":"OrdinaryDiffEqRosenbrock","title":"When to Use Mass Matrix Rosenbrock Methods","text":"These methods are recommended for:\n\nIndex-1 DAE systems with moderate stiffness\nSmall to medium constrained systems (< 1000 equations)\nSemi-explicit DAEs arising from discretized PDEs\nProblems requiring good accuracy with moderate computational cost\nDAEs with moderate nonlinearity where W-methods are efficient\nElectrical circuits and mechanical systems with constraints\n\nwarn: Warn\nIn order to use OrdinaryDiffEqRosenbrock with DAEs that require a non-trivial consistent initialization, a nonlinear solver is required and thus using OrdinaryDiffEqNonlinearSolve is required or you must pass an initializealg with a valid nlsolve choice.","category":"section"},{"location":"massmatrixdae/Rosenbrock/#Mathematical-Background","page":"OrdinaryDiffEqRosenbrock","title":"Mathematical Background","text":"Mass matrix DAEs have the form: M du/dt = f(u,t)\n\nRosenbrock methods linearize around the current solution and solve linear systems of the form: (M/γh - J) k_i = ...\n\nwhere J is the Jacobian of f and γ is a method parameter.","category":"section"},{"location":"massmatrixdae/Rosenbrock/#Solver-Selection-Guide","page":"OrdinaryDiffEqRosenbrock","title":"Solver Selection Guide","text":"","category":"section"},{"location":"massmatrixdae/Rosenbrock/#Recommended-Methods-by-Tolerance","page":"OrdinaryDiffEqRosenbrock","title":"Recommended Methods by Tolerance","text":"High tolerances (>1e-2): Rosenbrock23 - efficient low-order method\nMedium tolerances (1e-8 to 1e-2): Rodas5P - most efficient choice, or Rodas4P for higher reliability\nLow tolerances (<1e-8): Rodas5Pe or higher-order alternatives","category":"section"},{"location":"massmatrixdae/Rosenbrock/#Method-families","page":"OrdinaryDiffEqRosenbrock","title":"Method families","text":"Rodas5P: Recommended - Most efficient 5th-order method for general use\nRodas4P: More reliable 4th-order alternative\nRosenbrock23: Good for high tolerance problems\nRodas5: Standard 5th-order method without embedded pair optimization","category":"section"},{"location":"massmatrixdae/Rosenbrock/#Performance-Guidelines","page":"OrdinaryDiffEqRosenbrock","title":"Performance Guidelines","text":"","category":"section"},{"location":"massmatrixdae/Rosenbrock/#When-mass-matrix-Rosenbrock-methods-excel","page":"OrdinaryDiffEqRosenbrock","title":"When mass matrix Rosenbrock methods excel","text":"Small to medium DAE systems (< 1000 equations)\nModerately stiff problems where full BDF methods are overkill\nProblems with efficient Jacobian computation or finite difference approximation\nIndex-1 DAEs with well-conditioned mass matrices\nSemi-explicit index-1 problems from spatial discretizations","category":"section"},{"location":"massmatrixdae/Rosenbrock/#System-size-considerations","page":"OrdinaryDiffEqRosenbrock","title":"System size considerations","text":"Small systems (< 100): Rosenbrock methods often outperform multistep methods\nMedium systems (100-1000): Good performance with proper linear algebra\nLarge systems (> 1000): Consider BDF methods instead","category":"section"},{"location":"massmatrixdae/Rosenbrock/#Important-DAE-Considerations","page":"OrdinaryDiffEqRosenbrock","title":"Important DAE Considerations","text":"","category":"section"},{"location":"massmatrixdae/Rosenbrock/#Initial-conditions","page":"OrdinaryDiffEqRosenbrock","title":"Initial conditions","text":"Must be consistent with algebraic constraints\nConsistent initialization may require nonlinear solver\nIndex-1 assumption for reliable performance","category":"section"},{"location":"massmatrixdae/Rosenbrock/#Mass-matrix-requirements","page":"OrdinaryDiffEqRosenbrock","title":"Mass matrix requirements","text":"Index-1 DAE structure for optimal performance\nNon-singular leading submatrix for differential variables\nWell-conditioned constraint equations","category":"section"},{"location":"massmatrixdae/Rosenbrock/#Alternative-Approaches","page":"OrdinaryDiffEqRosenbrock","title":"Alternative Approaches","text":"Consider these alternatives:\n\nMass matrix BDF methods for larger or highly stiff DAE systems\nImplicit Runge-Kutta methods for higher accuracy requirements\nStandard Rosenbrock methods for regular ODEs without constraints\nIMEX methods if natural explicit/implicit splitting exists","category":"section"},{"location":"massmatrixdae/Rosenbrock/#Example-Usage","page":"OrdinaryDiffEqRosenbrock","title":"Example Usage","text":"using LinearAlgebra: Diagonal\nfunction rober(du, u, p, t)\n    y₁, y₂, y₃ = u\n    k₁, k₂, k₃ = p\n    du[1] = -k₁ * y₁ + k₃ * y₂ * y₃\n    du[2] = k₁ * y₁ - k₃ * y₂ * y₃ - k₂ * y₂^2\n    du[3] = y₁ + y₂ + y₃ - 1\n    nothing\nend\nM = Diagonal([1.0, 1.0, 0])  # Singular mass matrix\nf = ODEFunction(rober, mass_matrix = M)\nprob_mm = ODEProblem(f, [1.0, 0.0, 0.0], (0.0, 1e5), (0.04, 3e7, 1e4))\nsol = solve(prob_mm, Rodas5(), reltol = 1e-8, abstol = 1e-8)\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqRosenbrock\", \"Rodas5P\")","category":"section"},{"location":"massmatrixdae/Rosenbrock/#Full-list-of-solvers","page":"OrdinaryDiffEqRosenbrock","title":"Full list of solvers","text":"","category":"section"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rosenbrock23-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rosenbrock23","text":"Rosenbrock23(; chunk_size = Val{0}(),\n               standardtag = Val{true}(),\n               autodiff = AutoForwardDiff(),\n               concrete_jac = nothing,\n               diff_type = Val{:forward}(),\n               linsolve = nothing,\n               precs = DEFAULT_PRECS,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  An Order 2/3 L-Stable Rosenbrock-W method which is good for very stiff equations with oscillations at low tolerances. 2nd order stiff-aware interpolation.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rosenbrock23(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nShampine L.F. and Reichelt M., (1997) The MATLAB ODE Suite, SIAM Journal of Scientific Computing, 18 (1), pp. 1-22.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rosenbrock32-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rosenbrock32","text":"Rosenbrock32(; chunk_size = Val{0}(),\n               standardtag = Val{true}(),\n               autodiff = AutoForwardDiff(),\n               concrete_jac = nothing,\n               diff_type = Val{:forward}(),\n               linsolve = nothing,\n               precs = DEFAULT_PRECS,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  An Order 3/2 A-Stable Rosenbrock-W method which is good for mildly stiff equations without oscillations at low tolerances. Note that this method is prone to instability in the presence of oscillations, so use with caution. 2nd order stiff-aware interpolation.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rosenbrock32(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nShampine L.F. and Reichelt M., (1997) The MATLAB ODE Suite, SIAM Journal of Scientific Computing, 18 (1), pp. 1-22.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3P-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3P","text":"ROS3P(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n            ForwardDiff default function-specific tags. For more information, see\n            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n            Defaults to `Val{true}()`.\n        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n            to specify whether to use automatic differentiation via\n            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n            `nothing`, which means it will be chosen true/false depending on circumstances\n            of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n          `ROS3P(linsolve = KLUFactorization()`).\n           When `nothing` is passed, uses `DefaultLinearSolver`.\n        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n          can be used as a left or right preconditioner.\n          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n          function where the arguments are defined as:\n            - `W`: the current Jacobian of the nonlinear system. Specified as either\n                ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                representation of the operator. Users can construct the W-matrix on demand\n                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                the `jac_prototype`.\n            - `du`: the current ODE derivative\n            - `u`: the current ODE state\n            - `p`: the ODE parameters\n            - `t`: the current ODE time\n            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                the last call to `precs`. It is recommended that this is checked to only\n                update the preconditioner when `newW == true`.\n            - `Plprev`: the previous `Pl`.\n            - `Prprev`: the previous `Pr`.\n            - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                Solver-dependent and subject to change.\n          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n          To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n          which is not used. Additionally, `precs` must supply the dispatch:\n          ```julia\n          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n          ```\n          which is used in the solver setup phase to construct the integrator\n          type with the preconditioners `(Pl,Pr)`.\n          The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n          is defined as:\n          ```julia\n          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n          ```\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method. Keeps high accuracy on discretizations of nonlinear parabolic PDEs.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nLang, J. & Verwer, ROS3P—An Accurate Third-Order Rosenbrock Solver Designed for Parabolic Problems J. BIT Numerical Mathematics (2001) 41: 731. doi:10.1023/A:1021900219772\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas3-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas3","text":"Rodas3(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Rodas3(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSandu, Verwer, Van Loon, Carmichael, Potra, Dabdub, Seinfeld, Benchmarking stiff ode solvers for atmospheric chemistry problems-I.  implicit vs explicit, Atmospheric Environment, 31(19), 3151-3166, 1997.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas23W-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas23W","text":"Rodas23W(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  An Order 2/3 L-Stable Rosenbrock-W method for stiff ODEs and DAEs in mass matrix form. 2nd order stiff-aware interpolation and additional error test for interpolation.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas23W(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G., Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024. Proceedings of the JuliaCon Conferences. https://proceedings.juliacon.org/papers/eb04326e1de8fa819a3595b376508a40\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas3P-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas3P","text":"Rodas3P(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `Rodas3P(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant and additional error test for interpolation. Keeps accuracy on discretizations of linear parabolic PDEs.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G., Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024. Proceedings of the JuliaCon Conferences. https://proceedings.juliacon.org/papers/eb04326e1de8fa819a3595b376508a40\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas4-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas4","text":"Rodas4(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Rodas4(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas42-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas42","text":"Rodas42(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `Rodas42(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas4P-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas4P","text":"Rodas4P(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `Rodas4P(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems (as opposed to lower if not corrected).\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach, G., Rentrop, P., An adaptive method of lines approach for modelling flow and transport in rivers.  Adaptive method of lines , Wouver, A. Vande, Sauces, Ph., Schiesser, W.E. (ed.),S. 181-205,Chapman & Hall/CRC, 2001,\nSteinebach, G., Order-reduction of ROW-methods for DAEs and method of lines  applications.  Preprint-Nr. 1741, FB Mathematik, TH Darmstadt, 1995.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas4P2-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas4P2","text":"Rodas4P2(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems. It is an improvement of Rodas4P and in case of inexact Jacobians a second order W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas4P2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G., Improvement of Rosenbrock-Wanner Method RODASP, In: Reis T., Grundel S., Schöps S. (eds)  Progress in Differential-Algebraic Equations II. Differential-Algebraic Equations Forum. Springer, Cham., 165-184, 2020.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5","text":"Rodas5(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Rodas5(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 5th order A-stable stiffly stable Rosenbrock method with a stiff-aware 4th order interpolant.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nDi Marzo G. RODAS5(4) – Méthodes de Rosenbrock d'ordre 5(4) adaptées aux problèmes différentiels-algébriques. MSc mathematics thesis, Faculty of Science, University of Geneva, Switzerland.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5P-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5P","text":"Rodas5P(; chunk_size = Val{0}(),\n          standardtag = Val{true}(),\n          autodiff = AutoForwardDiff(),\n          concrete_jac = nothing,\n          diff_type = Val{:forward}(),\n          linsolve = nothing,\n          precs = DEFAULT_PRECS,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 5th order A-stable stiffly stable Rosenbrock method with a stiff-aware 4th order interpolant. Has improved stability in the adaptive time stepping embedding.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas5P(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G. Construction of Rosenbrock–Wanner method Rodas5P and numerical benchmarks within the Julia Differential Equations package. In: BIT Numerical Mathematics, 63(2), 2023. doi:10.1007/s10543-023-00967-x\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5Pe-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5Pe","text":"Rodas5Pe(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  Variant of Rodas5P with modified embedded scheme.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas5Pe(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G. Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024. Proceedings of the JuliaCon Conferences. https://proceedings.juliacon.org/papers/eb04326e1de8fa819a3595b376508a40\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5Pr-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5Pr","text":"Rodas5Pr(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  Variant of Rodas5P with additional residual control.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas5Pr(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G. Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024. Proceedings of the JuliaCon Conferences. https://proceedings.juliacon.org/papers/eb04326e1de8fa819a3595b376508a40\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.RosenbrockW6S4OS-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.RosenbrockW6S4OS","text":"RosenbrockW6S4OS(; chunk_size = Val{0}(),\n                   standardtag = Val{true}(),\n                   autodiff = AutoForwardDiff(),\n                   concrete_jac = nothing,\n                   diff_type = Val{:forward}(),\n                   linsolve = nothing,\n                   precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method (fixed step only).\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify RosenbrockW6S4OS(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nhttps://doi.org/10.1016/j.cam.2009.09.017\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS2-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS2","text":"ROS2(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n           ForwardDiff default function-specific tags. For more information, see\n           [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n           Defaults to `Val{true}()`.\n       - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n           to specify whether to use automatic differentiation via\n           [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n           differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n           Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n           `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n           To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n           `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n       - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n           `nothing`, which means it will be chosen true/false depending on circumstances\n           of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n       - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n         For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n         `ROS2(linsolve = KLUFactorization()`).\n          When `nothing` is passed, uses `DefaultLinearSolver`.\n       - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n         can be used as a left or right preconditioner.\n         Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n         function where the arguments are defined as:\n           - `W`: the current Jacobian of the nonlinear system. Specified as either\n               ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n               commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n               representation of the operator. Users can construct the W-matrix on demand\n               by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n               the `jac_prototype`.\n           - `du`: the current ODE derivative\n           - `u`: the current ODE state\n           - `p`: the ODE parameters\n           - `t`: the current ODE time\n           - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n               the last call to `precs`. It is recommended that this is checked to only\n               update the preconditioner when `newW == true`.\n           - `Plprev`: the previous `Pl`.\n           - `Prprev`: the previous `Pr`.\n           - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n               Solver-dependent and subject to change.\n         The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n         To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n         which is not used. Additionally, `precs` must supply the dispatch:\n         ```julia\n         Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n         ```\n         which is used in the solver setup phase to construct the integrator\n         type with the preconditioners `(Pl,Pr)`.\n         The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n         is defined as:\n         ```julia\n         DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n         ```)\n\nRosenbrock-Wanner Method.  A 2nd order L-stable Rosenbrock method with 2 internal stages.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nJ. G. Verwer et al. (1999): A second-order Rosenbrock method applied to photochemical dispersion problems https://doi.org/10.1137/S1064827597326651\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS2PR-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS2PR","text":"ROS2PR(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `ROS2PR(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```)\n\nRosenbrock-Wanner Method.  2nd order stiffly accurate Rosenbrock method with 3 internal stages with (Rinf=0). For problems with medium stiffness the convergence behaviour is very poor and it is recommended to use ROS2S instead.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS2S-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS2S","text":"ROS2S(; chunk_size = Val{0}(),\n        standardtag = Val{true}(),\n        autodiff = AutoForwardDiff(),\n        concrete_jac = nothing,\n        diff_type = Val{:forward}(),\n        linsolve = nothing,\n        precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  2nd order stiffly accurate Rosenbrock-Wanner W-method with 3 internal stages with B_PR consistent of order 2 with (Rinf=0).\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS2S(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3","text":"ROS3(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n           ForwardDiff default function-specific tags. For more information, see\n           [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n           Defaults to `Val{true}()`.\n       - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n           to specify whether to use automatic differentiation via\n           [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n           differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n           Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n           `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n           To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n           `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n       - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n           `nothing`, which means it will be chosen true/false depending on circumstances\n           of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n       - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n         For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n         `ROS3(linsolve = KLUFactorization()`).\n          When `nothing` is passed, uses `DefaultLinearSolver`.\n       - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n         can be used as a left or right preconditioner.\n         Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n         function where the arguments are defined as:\n           - `W`: the current Jacobian of the nonlinear system. Specified as either\n               ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n               commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n               representation of the operator. Users can construct the W-matrix on demand\n               by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n               the `jac_prototype`.\n           - `du`: the current ODE derivative\n           - `u`: the current ODE state\n           - `p`: the ODE parameters\n           - `t`: the current ODE time\n           - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n               the last call to `precs`. It is recommended that this is checked to only\n               update the preconditioner when `newW == true`.\n           - `Plprev`: the previous `Pl`.\n           - `Prprev`: the previous `Pr`.\n           - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n               Solver-dependent and subject to change.\n         The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n         To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n         which is not used. Additionally, `precs` must supply the dispatch:\n         ```julia\n         Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n         ```\n         which is used in the solver setup phase to construct the integrator\n         type with the preconditioners `(Pl,Pr)`.\n         The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n         is defined as:\n         ```julia\n         DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n         ```)\n\nRosenbrock-Wanner Method.  3rd order L-stable Rosenbrock method with 3 internal stages with an embedded strongly A-stable 2nd order method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3PR-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3PR","text":"ROS3PR(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `ROS3PR(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```)\n\nRosenbrock-Wanner Method.  3nd order stiffly accurate Rosenbrock method with 3 internal stages with B_PR consistent of order 3, which is strongly A-stable with Rinf~=-0.73.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Scholz4_7-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Scholz4_7","text":"Scholz4_7(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n                ForwardDiff default function-specific tags. For more information, see\n                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n                Defaults to `Val{true}()`.\n            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n                to specify whether to use automatic differentiation via\n                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n                `nothing`, which means it will be chosen true/false depending on circumstances\n                of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n              `Scholz4_7(linsolve = KLUFactorization()`).\n               When `nothing` is passed, uses `DefaultLinearSolver`.\n            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n              can be used as a left or right preconditioner.\n              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n              function where the arguments are defined as:\n                - `W`: the current Jacobian of the nonlinear system. Specified as either\n                    ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                    representation of the operator. Users can construct the W-matrix on demand\n                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                    the `jac_prototype`.\n                - `du`: the current ODE derivative\n                - `u`: the current ODE state\n                - `p`: the ODE parameters\n                - `t`: the current ODE time\n                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                    the last call to `precs`. It is recommended that this is checked to only\n                    update the preconditioner when `newW == true`.\n                - `Plprev`: the previous `Pl`.\n                - `Prprev`: the previous `Pr`.\n                - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                    Solver-dependent and subject to change.\n              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n              To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n              which is not used. Additionally, `precs` must supply the dispatch:\n              ```julia\n              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n              ```\n              which is used in the solver setup phase to construct the integrator\n              type with the preconditioners `(Pl,Pr)`.\n              The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n              is defined as:\n              ```julia\n              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n              ```)\n\nRosenbrock-Wanner Method.  3nd order stiffly accurate Rosenbrock method with 3 internal stages with B_PR consistent of order 3, which is strongly A-stable with Rinf~=-0.73. Convergence with order 4 for the stiff case, but has a poor accuracy.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW1a-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW1a","text":"ROS34PW1a(; chunk_size = Val{0}(),\n            standardtag = Val{true}(),\n            autodiff = AutoForwardDiff(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW1a(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nRang, Joachim and Angermann, L (2005): New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1. BIT Numerical Mathematics, 45, 761–787.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW1b-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW1b","text":"ROS34PW1b(; chunk_size = Val{0}(),\n            standardtag = Val{true}(),\n            autodiff = AutoForwardDiff(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW1b(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nRang, Joachim and Angermann, L (2005): New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1. BIT Numerical Mathematics, 45, 761–787.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW2-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW2","text":"ROS34PW2(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order stiffy accurate Rosenbrock-W method for PDAEs.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nRang, Joachim and Angermann, L (2005): New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1. BIT Numerical Mathematics, 45, 761–787.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW3-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW3","text":"ROS34PW3(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order strongly A-stable (Rinf~0.63) Rosenbrock-W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW3(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nRang, Joachim and Angermann, L (2005): New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1. BIT Numerical Mathematics, 45, 761–787.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PRw-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PRw","text":"ROS34PRw(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  3rd order stiffly accurate Rosenbrock-Wanner W-method with 4 internal stages, B_PR consistent of order 2. The order of convergence decreases if medium stiff problems are considered.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PRw(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nJoachim Rang, Improved traditional Rosenbrock–Wanner methods for stiff ODEs and DAEs, Journal of Computational and Applied Mathematics, https://doi.org/10.1016/j.cam.2015.03.010\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3PRL-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3PRL","text":"ROS3PRL(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `ROS3PRL(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```)\n\nRosenbrock-Wanner Method.  3rd order stiffly accurate Rosenbrock method with 4 internal stages, B_PR consistent of order 2 with Rinf=0. The order of convergence decreases if medium stiff problems are considered, but it has good results for very stiff cases.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3PRL2-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3PRL2","text":"ROS3PRL2(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n               ForwardDiff default function-specific tags. For more information, see\n               [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n               Defaults to `Val{true}()`.\n           - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n               to specify whether to use automatic differentiation via\n               [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n               differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n               Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n               `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n               To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n               `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n           - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n               `nothing`, which means it will be chosen true/false depending on circumstances\n               of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n           - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n             For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n             `ROS3PRL2(linsolve = KLUFactorization()`).\n              When `nothing` is passed, uses `DefaultLinearSolver`.\n           - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n             can be used as a left or right preconditioner.\n             Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n             function where the arguments are defined as:\n               - `W`: the current Jacobian of the nonlinear system. Specified as either\n                   ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                   commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                   representation of the operator. Users can construct the W-matrix on demand\n                   by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                   the `jac_prototype`.\n               - `du`: the current ODE derivative\n               - `u`: the current ODE state\n               - `p`: the ODE parameters\n               - `t`: the current ODE time\n               - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                   the last call to `precs`. It is recommended that this is checked to only\n                   update the preconditioner when `newW == true`.\n               - `Plprev`: the previous `Pl`.\n               - `Prprev`: the previous `Pr`.\n               - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                   Solver-dependent and subject to change.\n             The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n             To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n             which is not used. Additionally, `precs` must supply the dispatch:\n             ```julia\n             Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n             ```\n             which is used in the solver setup phase to construct the integrator\n             type with the preconditioners `(Pl,Pr)`.\n             The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n             is defined as:\n             ```julia\n             DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n             ```)\n\nRosenbrock-Wanner Method.  3rd order stiffly accurate Rosenbrock method with 4 internal stages, B_PR consistent of order 3. The order of convergence does NOT decreases if medium stiff problems are considered as it does for ROS3PRL.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROK4a-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROK4a","text":"ROK4a(; chunk_size = Val{0}(),\n        standardtag = Val{true}(),\n        autodiff = AutoForwardDiff(),\n        concrete_jac = nothing,\n        diff_type = Val{:forward}(),\n        linsolve = nothing,\n        precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  4rd order L-stable Rosenbrock-Krylov method with 4 internal stages, with a 3rd order embedded method which is strongly A-stable with Rinf~=0.55. (when using exact Jacobians)\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROK4a(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nTranquilli, Paul and Sandu, Adrian (2014): Rosenbrock–Krylov Methods for Large Systems of Differential Equations https://doi.org/10.1137/130923336\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.RosShamp4-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.RosShamp4","text":"RosShamp4(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n                ForwardDiff default function-specific tags. For more information, see\n                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n                Defaults to `Val{true}()`.\n            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n                to specify whether to use automatic differentiation via\n                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n                `nothing`, which means it will be chosen true/false depending on circumstances\n                of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n              `RosShamp4(linsolve = KLUFactorization()`).\n               When `nothing` is passed, uses `DefaultLinearSolver`.\n            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n              can be used as a left or right preconditioner.\n              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n              function where the arguments are defined as:\n                - `W`: the current Jacobian of the nonlinear system. Specified as either\n                    ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                    representation of the operator. Users can construct the W-matrix on demand\n                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                    the `jac_prototype`.\n                - `du`: the current ODE derivative\n                - `u`: the current ODE state\n                - `p`: the ODE parameters\n                - `t`: the current ODE time\n                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                    the last call to `precs`. It is recommended that this is checked to only\n                    update the preconditioner when `newW == true`.\n                - `Plprev`: the previous `Pl`.\n                - `Prprev`: the previous `Pr`.\n                - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                    Solver-dependent and subject to change.\n              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n              To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n              which is not used. Additionally, `precs` must supply the dispatch:\n              ```julia\n              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n              ```\n              which is used in the solver setup phase to construct the integrator\n              type with the preconditioners `(Pl,Pr)`.\n              The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n              is defined as:\n              ```julia\n              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n              ```)\n\nRosenbrock-Wanner Method.  An A-stable 4th order Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nL. F. Shampine, Implementation of Rosenbrock Methods, ACM Transactions on Mathematical Software (TOMS), 8: 2, 93-113. doi:10.1145/355993.355994\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Veldd4-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Veldd4","text":"Veldd4(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Veldd4(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```)\n\nRosenbrock-Wanner Method.  A 4th order D-stable Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nvan Veldhuizen, D-stability and Kaps-Rentrop-methods, M. Computing (1984) 32: 229. doi:10.1007/BF02243574\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Velds4-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Velds4","text":"Velds4(; chunk_size = Val{0}(),\n         standardtag = Val{true}(),\n         autodiff = AutoForwardDiff(),\n         concrete_jac = nothing,\n         diff_type = Val{:forward}(),\n         linsolve = nothing,\n         precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order A-stable Rosenbrock method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Velds4(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nvan Veldhuizen, D-stability and Kaps-Rentrop-methods, M. Computing (1984) 32: 229. doi:10.1007/BF02243574\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.GRK4T-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.GRK4T","text":"GRK4T(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n            ForwardDiff default function-specific tags. For more information, see\n            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n            Defaults to `Val{true}()`.\n        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n            to specify whether to use automatic differentiation via\n            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n            `nothing`, which means it will be chosen true/false depending on circumstances\n            of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n          `GRK4T(linsolve = KLUFactorization()`).\n           When `nothing` is passed, uses `DefaultLinearSolver`.\n        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n          can be used as a left or right preconditioner.\n          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n          function where the arguments are defined as:\n            - `W`: the current Jacobian of the nonlinear system. Specified as either\n                ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                representation of the operator. Users can construct the W-matrix on demand\n                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                the `jac_prototype`.\n            - `du`: the current ODE derivative\n            - `u`: the current ODE state\n            - `p`: the ODE parameters\n            - `t`: the current ODE time\n            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                the last call to `precs`. It is recommended that this is checked to only\n                update the preconditioner when `newW == true`.\n            - `Plprev`: the previous `Pl`.\n            - `Prprev`: the previous `Pr`.\n            - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                Solver-dependent and subject to change.\n          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n          To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n          which is not used. Additionally, `precs` must supply the dispatch:\n          ```julia\n          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n          ```\n          which is used in the solver setup phase to construct the integrator\n          type with the preconditioners `(Pl,Pr)`.\n          The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n          is defined as:\n          ```julia\n          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n          ```)\n\nRosenbrock-Wanner Method.  An efficient 4th order Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nKaps, P. & Rentrop, Generalized Runge-Kutta methods of order four with stepsize control for stiff ordinary differential equations. P. Numer. Math. (1979) 33: 55. doi:10.1007/BF01396495\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.GRK4A-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.GRK4A","text":"GRK4A(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n            ForwardDiff default function-specific tags. For more information, see\n            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n            Defaults to `Val{true}()`.\n        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n            to specify whether to use automatic differentiation via\n            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n            `nothing`, which means it will be chosen true/false depending on circumstances\n            of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n          `GRK4A(linsolve = KLUFactorization()`).\n           When `nothing` is passed, uses `DefaultLinearSolver`.\n        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n          can be used as a left or right preconditioner.\n          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n          function where the arguments are defined as:\n            - `W`: the current Jacobian of the nonlinear system. Specified as either\n                ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                representation of the operator. Users can construct the W-matrix on demand\n                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                the `jac_prototype`.\n            - `du`: the current ODE derivative\n            - `u`: the current ODE state\n            - `p`: the ODE parameters\n            - `t`: the current ODE time\n            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                the last call to `precs`. It is recommended that this is checked to only\n                update the preconditioner when `newW == true`.\n            - `Plprev`: the previous `Pl`.\n            - `Prprev`: the previous `Pr`.\n            - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                Solver-dependent and subject to change.\n          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n          To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n          which is not used. Additionally, `precs` must supply the dispatch:\n          ```julia\n          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n          ```\n          which is used in the solver setup phase to construct the integrator\n          type with the preconditioners `(Pl,Pr)`.\n          The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n          is defined as:\n          ```julia\n          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n          ```)\n\nRosenbrock-Wanner Method.  An A-stable 4th order Rosenbrock method. Essentially \"anti-L-stable\" but efficient.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nKaps, P. & Rentrop, Generalized Runge-Kutta methods of order four with stepsize control for stiff ordinary differential equations. P. Numer. Math. (1979) 33: 55. doi:10.1007/BF01396495\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Ros4LStab-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Ros4LStab","text":"Ros4LStab(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n                ForwardDiff default function-specific tags. For more information, see\n                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n                Defaults to `Val{true}()`.\n            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n                to specify whether to use automatic differentiation via\n                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n                `nothing`, which means it will be chosen true/false depending on circumstances\n                of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n              `Ros4LStab(linsolve = KLUFactorization()`).\n               When `nothing` is passed, uses `DefaultLinearSolver`.\n            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n              can be used as a left or right preconditioner.\n              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n              function where the arguments are defined as:\n                - `W`: the current Jacobian of the nonlinear system. Specified as either\n                    ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                    representation of the operator. Users can construct the W-matrix on demand\n                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                    the `jac_prototype`.\n                - `du`: the current ODE derivative\n                - `u`: the current ODE state\n                - `p`: the ODE parameters\n                - `t`: the current ODE time\n                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                    the last call to `precs`. It is recommended that this is checked to only\n                    update the preconditioner when `newW == true`.\n                - `Plprev`: the previous `Pl`.\n                - `Prprev`: the previous `Pr`.\n                - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                    Solver-dependent and subject to change.\n              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n              To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n              which is not used. Additionally, `precs` must supply the dispatch:\n              ```julia\n              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n              ```\n              which is used in the solver setup phase to construct the integrator\n              type with the preconditioners `(Pl,Pr)`.\n              The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n              is defined as:\n              ```julia\n              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n              ```)\n\nRosenbrock-Wanner Method.  A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"OrdinaryDiffEq.jl is part of the SciML common interface, but can be used independently of DifferentialEquations.jl. The only requirement is that the user passes an OrdinaryDiffEq.jl algorithm to solve. For example, we can solve the ODE tutorial from the docs using the Tsit5() algorithm:\n\nusing OrdinaryDiffEq\nf(u, p, t) = 1.01 * u\nu0 = 1 / 2\ntspan = (0.0, 1.0)\nprob = ODEProblem(f, u0, tspan)\nsol = solve(prob, Tsit5(), reltol = 1e-8, abstol = 1e-8)\nusing Plots\nplot(sol, linewidth = 5, title = \"Solution to the linear ODE with a thick line\",\n    xaxis = \"Time (t)\", yaxis = \"u(t) (in μm)\", label = \"My Thick Line!\") # legend=false\nplot!(sol.t, t -> 0.5 * exp(1.01t), lw = 3, ls = :dash, label = \"True Solution!\")\n\nThat example uses the out-of-place syntax f(u,p,t), while the inplace syntax (more efficient for systems of equations) is shown in the Lorenz example:\n\nusing OrdinaryDiffEq\nfunction lorenz(du, u, p, t)\n    du[1] = 10.0(u[2] - u[1])\n    du[2] = u[1] * (28.0 - u[3]) - u[2]\n    du[3] = u[1] * u[2] - (8 / 3) * u[3]\nend\nu0 = [1.0; 0.0; 0.0]\ntspan = (0.0, 100.0)\nprob = ODEProblem(lorenz, u0, tspan)\nsol = solve(prob, Tsit5())\nusing Plots;\nplot(sol, vars = (1, 2, 3));\n\nVery fast static array versions can be specifically compiled to the size of your model. For example:\n\nusing OrdinaryDiffEq, StaticArrays\nfunction lorenz(u, p, t)\n    SA[10.0(u[2] - u[1]), u[1] * (28.0 - u[3]) - u[2], u[1] * u[2] - (8 / 3) * u[3]]\nend\nu0 = SA[1.0; 0.0; 0.0]\ntspan = (0.0, 100.0)\nprob = ODEProblem(lorenz, u0, tspan)\nsol = solve(prob, Tsit5())\n\nFor “refined ODEs”, like dynamical equations and SecondOrderODEProblems, refer to the DiffEqDocs. For example, in DiffEqTutorials.jl we show how to solve equations of motion using symplectic methods:\n\nfunction HH_acceleration(dv, v, u, p, t)\n    x, y = u\n    dx, dy = dv\n    dv[1] = -x - 2x * y\n    dv[2] = y^2 - y - x^2\nend\ninitial_positions = [0.0, 0.1]\ninitial_velocities = [0.5, 0.0]\nprob = SecondOrderODEProblem(HH_acceleration, initial_velocities, initial_positions, tspan)\nsol2 = solve(prob, KahanLi8(), dt = 1 / 10);\n\nOther refined forms are IMEX and semi-linear ODEs (for exponential integrators).","category":"section"},{"location":"usage/#Available-Solvers","page":"Usage","title":"Available Solvers","text":"For the list of available solvers, please refer to the DifferentialEquations.jl ODE Solvers, Dynamical ODE Solvers, and the Split ODE Solvers pages.","category":"section"},{"location":"explicit/Feagin/#OrdinaryDiffEqFeagin","page":"OrdinaryDiffEqFeagin","title":"OrdinaryDiffEqFeagin","text":"Ultra-high-order explicit Runge-Kutta methods for non-stiff problems at extremely low tolerances (< 1e-30). These methods are designed for applications requiring extreme precision, typically used with higher-precision number types like BigFloat.","category":"section"},{"location":"explicit/Feagin/#Key-Properties","page":"OrdinaryDiffEqFeagin","title":"Key Properties","text":"Feagin methods provide:\n\nUltra-high-order accuracy (10th, 12th, and 14th order)\nExtreme precision capabilities for very low tolerance requirements\nCompatibility with arbitrary precision arithmetic (BigFloat, Float128)\nSpecialized for very demanding applications requiring maximum accuracy","category":"section"},{"location":"explicit/Feagin/#When-to-Use-Feagin-Methods","page":"OrdinaryDiffEqFeagin","title":"When to Use Feagin Methods","text":"These methods are recommended for:\n\nExtremely low tolerance problems (< 1e-30)\nArbitrary precision arithmetic applications using BigFloat or Float128\nUltra-high precision requirements where standard methods are insufficient\nResearch applications requiring maximum possible accuracy\nLong-time integration where error accumulation must be minimized to extreme levels","category":"section"},{"location":"explicit/Feagin/#Important-Limitations","page":"OrdinaryDiffEqFeagin","title":"Important Limitations","text":"","category":"section"},{"location":"explicit/Feagin/#Theoretical-vs-Practical-Performance","page":"OrdinaryDiffEqFeagin","title":"Theoretical vs Practical Performance","text":"Very good theoretical efficiency due to high order and optimized coefficients\nPoor practical performance in benchmarks due to bad error estimators and adaptivity issues\nGenerally recommend Vern9 instead as it tends to be more efficient in practice despite lower theoretical order","category":"section"},{"location":"explicit/Feagin/#Performance-Considerations","page":"OrdinaryDiffEqFeagin","title":"Performance Considerations","text":"May be less efficient than Vern9 even for very low tolerance problems\nOutperformed by extrapolation methods at extremely low tolerances due to adaptive order\nPotential efficiency for >128-bit numbers but no practical cases found yet where this is actually true\nShould always be tested against Vern9 and extrapolation methods","category":"section"},{"location":"explicit/Feagin/#Solver-Selection-Guide","page":"OrdinaryDiffEqFeagin","title":"Solver Selection Guide","text":"","category":"section"},{"location":"explicit/Feagin/#Extreme-precision-(-1e-30)","page":"OrdinaryDiffEqFeagin","title":"Extreme precision (< 1e-30)","text":"Feagin14: 14th-order method for maximum accuracy\nFeagin12: 12th-order method, balance of accuracy and efficiency\nFeagin10: 10th-order method for moderate extreme precision","category":"section"},{"location":"explicit/Feagin/#Strongly-recommended-alternatives","page":"OrdinaryDiffEqFeagin","title":"Strongly recommended alternatives","text":"For most very low tolerance problems: Use Vern9 first (more efficient in practice despite lower theoretical order)\nFor extremely low tolerances: Consider extrapolation methods for adaptive order\nFor >128-bit precision: These methods may be more efficient, but no practical cases found yet\nAlways benchmark: Compare performance with Vern9 and extrapolation methods before choosing Feagin methods","category":"section"},{"location":"explicit/Feagin/#Usage-Guidelines","page":"OrdinaryDiffEqFeagin","title":"Usage Guidelines","text":"Best with BigFloat or Float128 number types\nUseful in Float128 precision range but test against other algorithms\nConsider problem-specific characteristics when choosing order level\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqFeagin\", \"Feagin14\")","category":"section"},{"location":"explicit/Feagin/#Full-list-of-solvers","page":"OrdinaryDiffEqFeagin","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/Feagin/#OrdinaryDiffEqFeagin.Feagin10","page":"OrdinaryDiffEqFeagin","title":"OrdinaryDiffEqFeagin.Feagin10","text":"Feagin10(; step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nExplicit Runge-Kutta Method.  Feagin's 10th-order method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{feagin2012high, title={High-order explicit Runge-Kutta methods using m-symmetry}, author={Feagin, Terry}, year={2012}, publisher={Neural, Parallel \\& Scientific Computations} }\n\n\n\n\n\n","category":"type"},{"location":"explicit/Feagin/#OrdinaryDiffEqFeagin.Feagin12","page":"OrdinaryDiffEqFeagin","title":"OrdinaryDiffEqFeagin.Feagin12","text":"Feagin12(; step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nExplicit Runge-Kutta Method.  Feagin's 12th-order method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{feagin2012high, title={High-order explicit Runge-Kutta methods using m-symmetry}, author={Feagin, Terry}, year={2012}, publisher={Neural, Parallel \\& Scientific Computations} }\n\n\n\n\n\n","category":"type"},{"location":"explicit/Feagin/#OrdinaryDiffEqFeagin.Feagin14","page":"OrdinaryDiffEqFeagin","title":"OrdinaryDiffEqFeagin.Feagin14","text":"Feagin14(; step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nExplicit Runge-Kutta Method.  Feagin's 14th-order method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{feagin2009explicit, title={An Explicit Runge-Kutta Method of Order Fourteen}, author={Feagin, Terry}, year={2009}, publisher={Numerical Algorithms} }\n\n\n\n\n\n","category":"type"},{"location":"imex/IMEXBDF/#OrdinaryDiffEqBDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"IMEX BDF (Implicit-Explicit Backward Differentiation Formula) methods for stiff differential equations that can be split into stiff and non-stiff components. These methods apply implicit BDF schemes to the stiff part while treating the non-stiff part explicitly, providing efficient handling of problems with mixed stiffness characteristics.","category":"section"},{"location":"imex/IMEXBDF/#Key-Properties","page":"OrdinaryDiffEqBDF","title":"Key Properties","text":"IMEX BDF methods provide:\n\nImplicit-explicit splitting for mixed stiffness problems\nBDF stability for the stiff component with A-stable and L-stable behavior\nExplicit treatment of non-stiff terms avoiding unnecessary computational cost\nHigh-order accuracy up to 4th order for both components\nEfficient for large systems where full implicit treatment is expensive\nNatural for operator splitting problems","category":"section"},{"location":"imex/IMEXBDF/#When-to-Use-IMEX-BDF-Methods","page":"OrdinaryDiffEqBDF","title":"When to Use IMEX BDF Methods","text":"These methods are recommended for:\n\nReaction-diffusion systems where reaction terms are stiff and diffusion is moderate\nConvection-diffusion problems with stiff source terms and explicit convection\nParabolic PDEs where diffusion operators are naturally split from other terms\nProblems with natural stiffness separation where some terms require implicit treatment\nLarge-scale systems where full implicit methods are computationally prohibitive\nApplications requiring operator splitting methodology","category":"section"},{"location":"imex/IMEXBDF/#Mathematical-Background","page":"OrdinaryDiffEqBDF","title":"Mathematical Background","text":"IMEX BDF methods split the ODE system du/dt = f(u,t) into: du/dt = f₁(u,t) + f₂(u,t)\n\nwhere:\n\nf₁(u,t) contains stiff terms (treated implicitly with BDF)\nf₂(u,t) contains non-stiff terms (treated explicitly)\n\nThis splitting must be chosen carefully to ensure both stability and efficiency.","category":"section"},{"location":"imex/IMEXBDF/#Problem-Splitting-Requirements","page":"OrdinaryDiffEqBDF","title":"Problem Splitting Requirements","text":"These methods require a SplitODEProblem formulation where:\n\nFirst function f₁ should contain stiff, implicit terms\nSecond function f₂ should contain non-stiff, explicit terms\nSplitting strategy significantly affects method performance\nStiffness characteristics should align with implicit/explicit treatment","category":"section"},{"location":"imex/IMEXBDF/#Solver-Selection-Guide","page":"OrdinaryDiffEqBDF","title":"Solver Selection Guide","text":"","category":"section"},{"location":"imex/IMEXBDF/#IMEX-Multistep-Methods","page":"OrdinaryDiffEqBDF","title":"IMEX Multistep Methods","text":"SBDF2: Recommended - Second-order IMEX BDF method, good balance of accuracy and stability\nSBDF3: Third-order method for higher accuracy requirements\nSBDF4: Fourth-order method for maximum accuracy in IMEX BDF family\nSBDF: Adaptive order method (experimental)","category":"section"},{"location":"imex/IMEXBDF/#IMEX-SDIRK-Methods","page":"OrdinaryDiffEqBDF","title":"IMEX SDIRK Methods","text":"IMEXEuler: First-order method for simple problems or debugging\nIMEXEulerARK: Alternative first-order formulation","category":"section"},{"location":"imex/IMEXBDF/#Performance-Guidelines","page":"OrdinaryDiffEqBDF","title":"Performance Guidelines","text":"","category":"section"},{"location":"imex/IMEXBDF/#When-IMEX-BDF-methods-excel","page":"OrdinaryDiffEqBDF","title":"When IMEX BDF methods excel","text":"Natural stiffness separation where splitting is obvious\nLarge systems where full implicit treatment is expensive\nParabolic PDEs with natural operator splitting\nReaction-diffusion problems with well-separated timescales\nProblems where implicit component has efficient linear algebra","category":"section"},{"location":"imex/IMEXBDF/#Splitting-strategy-considerations","page":"OrdinaryDiffEqBDF","title":"Splitting strategy considerations","text":"Identify stiff vs non-stiff terms based on eigenvalue analysis\nLinear stiff terms work well in implicit component\nNonlinear non-stiff terms are suitable for explicit treatment\nTest different splittings to optimize performance","category":"section"},{"location":"imex/IMEXBDF/#Alternative-Approaches","page":"OrdinaryDiffEqBDF","title":"Alternative Approaches","text":"Consider these alternatives:\n\nFull implicit methods (BDF, SDIRK) if splitting is unclear or ineffective\nStandard IMEX Runge-Kutta methods for different accuracy/efficiency trade-offs\nExponential integrators for linear stiff problems with nonlinear non-stiff terms\nRosenbrock methods for moderately stiff problems without natural splitting","category":"section"},{"location":"imex/IMEXBDF/#Usage-Considerations","page":"OrdinaryDiffEqBDF","title":"Usage Considerations","text":"Careful splitting design is crucial for method effectiveness\nStability analysis should verify that explicit treatment doesn't introduce instabilities\nTimestep restrictions may apply to the explicit component\nLinear algebra efficiency in the implicit component affects overall performance\n\nimex_first_steps = evalfile(\"./common_imex_first_steps.jl\")\nimex_first_steps(\"OrdinaryDiffEqBDF\", \"SBDF2\")","category":"section"},{"location":"imex/IMEXBDF/#Full-list-of-solvers","page":"OrdinaryDiffEqBDF","title":"Full list of solvers","text":"","category":"section"},{"location":"imex/IMEXBDF/#IMEX-Multistep","page":"OrdinaryDiffEqBDF","title":"IMEX Multistep","text":"","category":"section"},{"location":"imex/IMEXBDF/#IMEX-SDIRK","page":"OrdinaryDiffEqBDF","title":"IMEX SDIRK","text":"Note that Implicit Euler is the 1st order BDF method, and is thus implemented here using the same machinery.","category":"section"},{"location":"imex/IMEXBDF/#OrdinaryDiffEqBDF.SBDF2","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.SBDF2","text":"SBDF2(;kwargs...)\n\nThe two-step version of the IMEX multistep methods of\n\nUri M. Ascher, Steven J. Ruuth, Brian T. R. Wetton. Implicit-Explicit Methods for Time-Dependent Partial Differential Equations. Society for Industrial and Applied Mathematics. Journal on Numerical Analysis, 32(3), pp 797-823, 1995. doi: https://doi.org/10.1137/0732037\n\nSee also SBDF.\n\n\n\n\n\n","category":"function"},{"location":"imex/IMEXBDF/#OrdinaryDiffEqBDF.SBDF3","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.SBDF3","text":"SBDF3(;kwargs...)\n\nThe three-step version of the IMEX multistep methods of\n\nUri M. Ascher, Steven J. Ruuth, Brian T. R. Wetton. Implicit-Explicit Methods for Time-Dependent Partial Differential Equations. Society for Industrial and Applied Mathematics. Journal on Numerical Analysis, 32(3), pp 797-823, 1995. doi: https://doi.org/10.1137/0732037\n\nSee also SBDF.\n\n\n\n\n\n","category":"function"},{"location":"imex/IMEXBDF/#OrdinaryDiffEqBDF.SBDF4","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.SBDF4","text":"SBDF4(;kwargs...)\n\nThe four-step version of the IMEX multistep methods of\n\nUri M. Ascher, Steven J. Ruuth, Brian T. R. Wetton. Implicit-Explicit Methods for Time-Dependent Partial Differential Equations. Society for Industrial and Applied Mathematics. Journal on Numerical Analysis, 32(3), pp 797-823, 1995. doi: https://doi.org/10.1137/0732037\n\nSee also SBDF.\n\n\n\n\n\n","category":"function"},{"location":"imex/IMEXBDF/#OrdinaryDiffEqBDF.IMEXEuler","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.IMEXEuler","text":"IMEXEuler(;kwargs...)\n\nThe one-step version of the IMEX multistep methods of\n\nUri M. Ascher, Steven J. Ruuth, Brian T. R. Wetton. Implicit-Explicit Methods for Time-Dependent Partial Differential Equations. Society for Industrial and Applied Mathematics. Journal on Numerical Analysis, 32(3), pp 797-823, 1995. doi: https://doi.org/10.1137/0732037\n\nWhen applied to a SplitODEProblem of the form\n\nu'(t) = f1(u) + f2(u)\n\nThe default IMEXEuler() method uses an update of the form\n\nunew = uold + dt * (f1(unew) + f2(uold))\n\nSee also SBDF, IMEXEulerARK.\n\n\n\n\n\n","category":"function"},{"location":"imex/IMEXBDF/#OrdinaryDiffEqBDF.IMEXEulerARK","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.IMEXEulerARK","text":"IMEXEulerARK(;kwargs...)\n\nThe one-step version of the IMEX multistep methods of\n\nUri M. Ascher, Steven J. Ruuth, Brian T. R. Wetton. Implicit-Explicit Methods for Time-Dependent Partial Differential Equations. Society for Industrial and Applied Mathematics. Journal on Numerical Analysis, 32(3), pp 797-823, 1995. doi: https://doi.org/10.1137/0732037\n\nWhen applied to a SplitODEProblem of the form\n\nu'(t) = f1(u) + f2(u)\n\nA classical additive Runge-Kutta method in the sense of Araújo, Murua, Sanz-Serna (1997) consisting of the implicit and the explicit Euler method given by\n\ny1   = uold + dt * f1(y1)\nunew = uold + dt * (f1(unew) + f2(y1))\n\nSee also SBDF, IMEXEuler.\n\n\n\n\n\n","category":"function"},{"location":"imex/StabilizedIRK/#OrdinaryDiffEqStabilizedIRK","page":"OrdinaryDiffEqStabilizedIRK","title":"OrdinaryDiffEqStabilizedIRK","text":"Stabilized Implicit Runge-Kutta (IMEX) methods combine the benefits of stabilized explicit methods with implicit treatment of problematic eigenvalues. These IMEX schemes are designed for problems where the Jacobian has both large real eigenvalues (suitable for explicit stabilized methods) and large complex eigenvalues (requiring implicit treatment).","category":"section"},{"location":"imex/StabilizedIRK/#Key-Properties","page":"OrdinaryDiffEqStabilizedIRK","title":"Key Properties","text":"Stabilized IRK methods provide:\n\nIMEX formulation treating different stiffness components appropriately\nLarge stability regions for real eigenvalues via explicit stabilized schemes\nImplicit treatment of complex eigenvalues for unconditional stability\nEfficient handling of mixed stiffness characteristics\nSplitting-based approach requiring SplitODEProblem formulation","category":"section"},{"location":"imex/StabilizedIRK/#When-to-Use-Stabilized-IRK-Methods","page":"OrdinaryDiffEqStabilizedIRK","title":"When to Use Stabilized IRK Methods","text":"These methods are recommended for:\n\nMixed stiffness problems with both real and complex eigenvalues\nParabolic PDEs with convection where diffusion and advection have different scales\nReaction-diffusion systems with stiff reactions and moderate diffusion\nProblems where pure explicit stabilized methods fail due to complex eigenvalues\nLarge-scale systems where full implicit methods are too expensive","category":"section"},{"location":"imex/StabilizedIRK/#Mathematical-Background","page":"OrdinaryDiffEqStabilizedIRK","title":"Mathematical Background","text":"Standard stabilized explicit methods (like RKC, ROCK) achieve large stability regions along the negative real axis but struggle with complex eigenvalues. Stabilized IRK methods address this by:\n\nExplicit stabilized treatment for large real eigenvalues\nImplicit treatment for complex eigenvalues\nIMEX coupling to maintain overall stability and accuracy","category":"section"},{"location":"imex/StabilizedIRK/#Problem-Splitting-Requirements","page":"OrdinaryDiffEqStabilizedIRK","title":"Problem Splitting Requirements","text":"These methods require a SplitODEProblem where:\n\nFirst component contains terms with large real eigenvalues (explicit treatment)\nSecond component contains terms with complex eigenvalues (implicit treatment)\nSplitting design is crucial for method performance","category":"section"},{"location":"imex/StabilizedIRK/#Spectral-Radius-Estimation","page":"OrdinaryDiffEqStabilizedIRK","title":"Spectral Radius Estimation","text":"Users can supply an upper bound on the spectral radius:\n\neigen_est = (integrator) -> integrator.eigen_est = upper_bound\n\nThis bound applies to the explicit component of the split problem.","category":"section"},{"location":"imex/StabilizedIRK/#Solver-Selection-Guide","page":"OrdinaryDiffEqStabilizedIRK","title":"Solver Selection Guide","text":"","category":"section"},{"location":"imex/StabilizedIRK/#Available-methods","page":"OrdinaryDiffEqStabilizedIRK","title":"Available methods","text":"IRKC: Implicit Runge-Kutta-Chebyshev method for mixed stiffness problems","category":"section"},{"location":"imex/StabilizedIRK/#Usage-considerations","page":"OrdinaryDiffEqStabilizedIRK","title":"Usage considerations","text":"Requires careful splitting of the problem components\nSpectral radius estimation needed for explicit component\nTest splitting strategies for optimal performance\nCompare with pure implicit or explicit stabilized alternatives","category":"section"},{"location":"imex/StabilizedIRK/#Performance-Guidelines","page":"OrdinaryDiffEqStabilizedIRK","title":"Performance Guidelines","text":"","category":"section"},{"location":"imex/StabilizedIRK/#When-IMEX-stabilized-methods-excel","page":"OrdinaryDiffEqStabilizedIRK","title":"When IMEX stabilized methods excel","text":"Mixed eigenvalue distribution (both real and complex)\nModerate to large systems where splitting is natural\nProblems where neither pure explicit nor implicit methods are ideal","category":"section"},{"location":"imex/StabilizedIRK/#Splitting-strategy-considerations","page":"OrdinaryDiffEqStabilizedIRK","title":"Splitting strategy considerations","text":"Identify dominant eigenvalue types in different terms\nReal-dominated terms → explicit component\nComplex-dominated terms → implicit component\nTest different splittings for best performance","category":"section"},{"location":"imex/StabilizedIRK/#Alternative-Approaches","page":"OrdinaryDiffEqStabilizedIRK","title":"Alternative Approaches","text":"Consider these alternatives:\n\nPure implicit methods (BDF, SDIRK, Rosenbrock) for highly stiff problems\nExplicit stabilized methods (ROCK, RKC) if complex eigenvalues are small\nStandard IMEX methods for natural explicit/implicit splitting\n\nimex_first_steps = evalfile(\"./common_imex_first_steps.jl\")\nimex_first_steps(\"OrdinaryDiffEqStabilizedIRK\", \"IRKC\")","category":"section"},{"location":"imex/StabilizedIRK/#Full-list-of-solvers","page":"OrdinaryDiffEqStabilizedIRK","title":"Full list of solvers","text":"","category":"section"},{"location":"imex/StabilizedIRK/#OrdinaryDiffEqStabilizedIRK.IRKC","page":"OrdinaryDiffEqStabilizedIRK","title":"OrdinaryDiffEqStabilizedIRK.IRKC","text":"IRKC(; eigen_est = nothing)\n\nStabilized Implicit Runge Kutta method. Implicit Runge-Kutta-Chebyshev method.\n\nKeyword Arguments\n\neigen_est: function of the form   (integrator) -> integrator.eigen_est = upper_bound,   where upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.   If eigen_est is not provided, upper_bound will be estimated using the power iteration.\n\nReferences\n\nREF TBD\n\n\n\n\n\n","category":"type"},{"location":"explicit/Extrapolation/#OrdinaryDiffEqExtrapolation","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation","text":"Explicit extrapolation methods that achieve high accuracy through Richardson extrapolation of basic integration schemes. These methods provide adaptive order capabilities and natural parallelism, though they are generally outclassed by modern Runge-Kutta methods for most non-stiff problems.","category":"section"},{"location":"explicit/Extrapolation/#Key-Properties","page":"OrdinaryDiffEqExtrapolation","title":"Key Properties","text":"Extrapolation methods provide:\n\nAdaptive order capability allowing arbitrarily high orders\nNatural parallelism across different substep sequences\nHigh accuracy potential for very smooth problems\nRichardson extrapolation to eliminate lower-order error terms\nAutomatic stepsize and order control\nTheoretical appeal but often practical limitations","category":"section"},{"location":"explicit/Extrapolation/#When-to-Use-Extrapolation-Methods","page":"OrdinaryDiffEqExtrapolation","title":"When to Use Extrapolation Methods","text":"These methods are recommended for:\n\nVery smooth problems where high-order accuracy is beneficial\nExtremely low tolerance requirements where adaptive order helps\nParallel computing environments that can exploit the natural parallelism\nResearch applications exploring adaptive order techniques\nProblems where other high-order methods struggle with accuracy","category":"section"},{"location":"explicit/Extrapolation/#Important-Limitations","page":"OrdinaryDiffEqExtrapolation","title":"Important Limitations","text":"Generally outclassed by modern explicit RK methods (Tsit5, Verner methods)\nHigher computational overhead compared to optimized RK methods\nBest suited for very smooth functions - poor performance on non-smooth problems\nParallel efficiency gains often don't compensate for increased work","category":"section"},{"location":"explicit/Extrapolation/#Mathematical-Background","page":"OrdinaryDiffEqExtrapolation","title":"Mathematical Background","text":"Extrapolation methods use sequences of basic integrators (like Euler or midpoint) with different stepsizes, then apply Richardson extrapolation to achieve higher-order accuracy. The adaptive order capability comes from using longer extrapolation sequences.","category":"section"},{"location":"explicit/Extrapolation/#Solver-Selection-Guide","page":"OrdinaryDiffEqExtrapolation","title":"Solver Selection Guide","text":"","category":"section"},{"location":"explicit/Extrapolation/#Explicit-extrapolation-methods","page":"OrdinaryDiffEqExtrapolation","title":"Explicit extrapolation methods","text":"AitkenNeville: Euler extrapolation using Aitken-Neville algorithm\nExtrapolationMidpointDeuflhard: Midpoint extrapolation with barycentric coordinates\nExtrapolationMidpointHairerWanner: Midpoint extrapolation following ODEX algorithm","category":"section"},{"location":"explicit/Extrapolation/#When-to-consider-these-methods","page":"OrdinaryDiffEqExtrapolation","title":"When to consider these methods","text":"Very low tolerances (< 1e-12) where adaptive order might help\nExtremely smooth problems with analytic solutions\nParallel computing scenarios with many available cores\nComparison studies with other high-order methods","category":"section"},{"location":"explicit/Extrapolation/#Better-alternatives-for-most-problems","page":"OrdinaryDiffEqExtrapolation","title":"Better alternatives for most problems","text":"For high accuracy: Use Verner methods (Vern7, Vern8, Vern9)\nFor general problems: Use Tsit5 or appropriate RK method\nFor stiff problems: Consider implicit extrapolation methods","category":"section"},{"location":"explicit/Extrapolation/#Performance-Notes","page":"OrdinaryDiffEqExtrapolation","title":"Performance Notes","text":"Consider stiff extrapolation methods which can perform very well for sufficiently stiff problems\nTest against Verner methods before choosing extrapolation for high accuracy\nParallelism benefits are problem and hardware dependent\nMost effective on very smooth, well-behaved problems\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqExtrapolation\", \"ExtrapolationMidpointDeuflhard\")","category":"section"},{"location":"explicit/Extrapolation/#Full-list-of-solvers","page":"OrdinaryDiffEqExtrapolation","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/Extrapolation/#OrdinaryDiffEqExtrapolation.AitkenNeville","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation.AitkenNeville","text":"AitkenNeville(; max_order::Int = 10,\n                min_order::Int = 1,\n                init_order = 3,\n                thread = OrdinaryDiffEq.False())\n\nParallelized Explicit Extrapolation Method. Euler extrapolation using Aitken-Neville with the Romberg Sequence.\n\nKeyword Arguments\n\nmax_order: maximum order of the adaptive order algorithm.\nmin_order: minimum order of the adaptive order algorithm.\ninit_order: initial order of the adaptive order algorithm.\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@inproceedings{elrod2022parallelizing,   title={Parallelizing explicit and implicit extrapolation methods for ordinary differential equations},   author={Elrod, Chris and Ma, Yingbo and Althaus, Konstantin and Rackauckas, Christopher and others},   booktitle={2022 IEEE High Performance Extreme Computing Conference (HPEC)},   pages={1–9},   year={2022},   organization={IEEE}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/Extrapolation/#OrdinaryDiffEqExtrapolation.ExtrapolationMidpointDeuflhard","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation.ExtrapolationMidpointDeuflhard","text":"ExtrapolationMidpointDeuflhard(; max_order = 10,\n                                 min_order = 1,\n                                 init_order = 5,\n                                 thread = OrdinaryDiffEq.True(),\n                                 sequence = :harmonic,\n                                 sequence_factor = 2)\n\nParallelized Explicit Extrapolation Method. Midpoint extrapolation using Barycentric coordinates.\n\nKeyword Arguments\n\nmax_order: maximum order of the adaptive order algorithm.\nmin_order: minimum order of the adaptive order algorithm.\ninit_order: initial order of the adaptive order algorithm.\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nsequence: the step-number sequences, also called the subdividing sequence. Possible values are :harmonic, :romberg or :bulirsch.\nsequence_factor: denotes which even multiple of sequence to take while evaluating internal discretizations.\n\nReferences\n\n@inproceedings{elrod2022parallelizing,   title={Parallelizing explicit and implicit extrapolation methods for ordinary differential equations},   author={Elrod, Chris and Ma, Yingbo and Althaus, Konstantin and Rackauckas, Christopher and others},   booktitle={2022 IEEE High Performance Extreme Computing Conference (HPEC)},   pages={1–9},   year={2022},   organization={IEEE}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/Extrapolation/#OrdinaryDiffEqExtrapolation.ExtrapolationMidpointHairerWanner","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation.ExtrapolationMidpointHairerWanner","text":"ExtrapolationMidpointHairerWanner(; max_order = 10,\n                                    min_order = 2,\n                                    init_order = 5,\n                                    thread = OrdinaryDiffEq.True(),\n                                    sequence = :harmonic,\n                                    sequence_factor = 2)\n\nParallelized Explicit Extrapolation Method. Midpoint extrapolation using Barycentric coordinates,     following Hairer's ODEX in the adaptivity behavior.\n\nKeyword Arguments\n\nmax_order: maximum order of the adaptive order algorithm.\nmin_order: minimum order of the adaptive order algorithm.\ninit_order: initial order of the adaptive order algorithm.\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nsequence: the step-number sequences, also called the subdividing sequence. Possible values are :harmonic, :romberg or :bulirsch.\nsequence_factor: denotes which even multiple of sequence to take while evaluating internal discretizations.\n\nReferences\n\n@inproceedings{elrod2022parallelizing,   title={Parallelizing explicit and implicit extrapolation methods for ordinary differential equations},   author={Elrod, Chris and Ma, Yingbo and Althaus, Konstantin and Rackauckas, Christopher and others},   booktitle={2022 IEEE High Performance Extreme Computing Conference (HPEC)},   pages={1–9},   year={2022},   organization={IEEE}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK","text":"Low-storage Runge-Kutta methods are specialized explicit schemes designed to minimize memory requirements while maintaining high-order accuracy. These methods are essential for large-scale computational fluid dynamics and wave propagation problems where memory constraints are critical.","category":"section"},{"location":"explicit/LowStorageRK/#Key-Properties","page":"OrdinaryDiffEqLowStorageRK","title":"Key Properties","text":"Low-storage RK methods provide:\n\nDrastically reduced memory usage (typically 2-4 registers vs 7-10 for standard RK)\nHigh-order accuracy comparable to standard RK methods\nPreservation of important stability properties (low dissipation/dispersion)\nScalability to very large PDE discretizations","category":"section"},{"location":"explicit/LowStorageRK/#When-to-Use-Low-Storage-RK-Methods","page":"OrdinaryDiffEqLowStorageRK","title":"When to Use Low-Storage RK Methods","text":"These methods are recommended for:\n\nLarge-scale PDE discretizations where memory is the limiting factor\nComputational fluid dynamics and wave propagation simulations\nHigh-performance computing applications with memory constraints\nGPU computations where memory bandwidth is critical\nCompressible flow simulations and aerodynamics\nSeismic wave propagation and acoustic simulations\nProblems with millions or billions of unknowns","category":"section"},{"location":"explicit/LowStorageRK/#Memory-Efficiency-Comparison","page":"OrdinaryDiffEqLowStorageRK","title":"Memory Efficiency Comparison","text":"Registers refer to the number of copies of the u0 vector that must be stored in memory during integration:\n\nStandard Tsit5: ~9 registers (copies of the state vector)\nLow-storage methods: 2-4 registers (copies of the state vector)\nPractical example: If u0 is from a PDE semi-discretization requiring 2 GB, then Tsit5 needs 18 GB of working memory, while a 2-register method only needs 4 GB and can achieve the same order\nTrade-off: These methods achieve memory reduction by being less computationally efficient, trading compute performance for lower memory requirements","category":"section"},{"location":"explicit/LowStorageRK/#Solver-Selection-Guide","page":"OrdinaryDiffEqLowStorageRK","title":"Solver Selection Guide","text":"","category":"section"},{"location":"explicit/LowStorageRK/#General-purpose-low-storage","page":"OrdinaryDiffEqLowStorageRK","title":"General-purpose low-storage","text":"CarpenterKennedy2N54: Fourth-order, 5-stage, excellent general choice\nRDPK3Sp510: Fifth-order with only 3 registers, very memory efficient","category":"section"},{"location":"explicit/LowStorageRK/#Wave-propagation-optimized","page":"OrdinaryDiffEqLowStorageRK","title":"Wave propagation optimized","text":"ORK256: Second-order, 5-stage, optimized for wave equations\nCFRLDDRK64: Low-dissipation and low-dispersion variant\nTSLDDRK74: Seventh-order for high accuracy wave propagation","category":"section"},{"location":"explicit/LowStorageRK/#Discontinuous-Galerkin-optimized","page":"OrdinaryDiffEqLowStorageRK","title":"Discontinuous Galerkin optimized","text":"DGLDDRK73_C: Optimized for DG discretizations (constrained)\nDGLDDRK84_C, DGLDDRK84_F: Fourth-order DG variants","category":"section"},{"location":"explicit/LowStorageRK/#Specialized-high-order","page":"OrdinaryDiffEqLowStorageRK","title":"Specialized high-order","text":"NDBLSRK124, NDBLSRK144: Multi-stage fourth-order methods\nSHLDDRK64: Low dissipation and dispersion properties\nRK46NL: Six-stage fourth-order method","category":"section"},{"location":"explicit/LowStorageRK/#Computational-fluid-dynamics","page":"OrdinaryDiffEqLowStorageRK","title":"Computational fluid dynamics","text":"Carpenter-Kennedy-Lewis series (CKLLSRK*): Optimized for Navier-Stokes equations\nParsani-Ketcheson-Deconinck series (ParsaniKetcheson*): CFD-optimized variants\nRanocha-Dalcin-Parsani-Ketcheson series (RDPK*): Modern CFD methods","category":"section"},{"location":"explicit/LowStorageRK/#Performance-Considerations","page":"OrdinaryDiffEqLowStorageRK","title":"Performance Considerations","text":"Use only when memory-bound: Standard RK methods are often more efficient when memory is not limiting\nBest for large systems: Most beneficial for problems with >10⁶ unknowns\nGPU acceleration: Particularly effective on memory-bandwidth limited hardware\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqLowStorageRK\", \"CarpenterKennedy2N54\")","category":"section"},{"location":"explicit/LowStorageRK/#Full-list-of-solvers","page":"OrdinaryDiffEqLowStorageRK","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ORK256","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ORK256","text":"ORK256(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False(),\n         williamson_condition = true)\n\nExplicit Runge-Kutta Method.  A second-order, five-stage method for wave propagation equations. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nMatteo Bernardini, Sergio Pirozzoli.     A General Strategy for the Optimization of Runge-Kutta Schemes for Wave     Propagation Phenomena.     Journal of Computational Physics, 228(11), pp 4182-4199, 2009.     doi: https://doi.org/10.1016/j.jcp.2009.02.032\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.DGLDDRK73_C","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.DGLDDRK73_C","text":"DGLDDRK73_C(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False(),\n              williamson_condition = true)\n\nExplicit Runge-Kutta Method.  7-stage, third order low-storage low-dissipation, low-dispersion scheme for discontinuous Galerkin space discretizations applied to wave propagation problems. Optimized for PDE discretizations when maximum spatial step is small due to geometric features of computational domain. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nT. Toulorge, W. Desmet.     Optimal Runge–Kutta Schemes for Discontinuous Galerkin Space Discretizations     Applied to Wave Propagation Problems.     Journal of Computational Physics, 231(4), pp 2067-2091, 2012.     doi: https://doi.org/10.1016/j.jcp.2011.11.024\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CarpenterKennedy2N54","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CarpenterKennedy2N54","text":"CarpenterKennedy2N54(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                       step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                       thread = OrdinaryDiffEq.False(),\n                       williamson_condition = true)\n\nExplicit Runge-Kutta Method.  A fourth-order, five-stage low-storage method of Carpenter and Kennedy (free 3rd order Hermite interpolant). Fixed timestep only. Designed for hyperbolic PDEs (stability properties).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\n@article{carpenter1994fourth,     title={Fourth-order 2N-storage Runge-Kutta schemes},     author={Carpenter, Mark H and Kennedy, Christopher A},     year={1994}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.NDBLSRK124","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.NDBLSRK124","text":"NDBLSRK124(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False(),\n             williamson_condition = true)\n\nExplicit Runge-Kutta Method.  12-stage, fourth order low-storage method with optimized stability regions for advection-dominated problems. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nJens Niegemann, Richard Diehl, Kurt Busch.     Efficient Low-Storage Runge–Kutta Schemes with Optimized Stability Regions.     Journal of Computational Physics, 231, pp 364-372, 2012.     doi: https://doi.org/10.1016/j.jcp.2011.09.003\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.NDBLSRK144","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.NDBLSRK144","text":"NDBLSRK144(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False(),\n             williamson_condition = true)\n\nExplicit Runge-Kutta Method.  14-stage, fourth order low-storage method with optimized stability regions for advection-dominated problems. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nJens Niegemann, Richard Diehl, Kurt Busch.     Efficient Low-Storage Runge–Kutta Schemes with Optimized Stability Regions.     Journal of Computational Physics, 231, pp 364-372, 2012.     doi: https://doi.org/10.1016/j.jcp.2011.09.003\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CFRLDDRK64","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CFRLDDRK64","text":"CFRLDDRK64(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 6-stage, fourth order low-storage, low-dissipation, low-dispersion scheme. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nM. Calvo, J. M. Franco, L. Randez. A New Minimum Storage Runge–Kutta Scheme     for Computational Acoustics. Journal of Computational Physics, 201, pp 1-12, 2004.     doi: https://doi.org/10.1016/j.jcp.2004.05.012\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.TSLDDRK74","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.TSLDDRK74","text":"TSLDDRK74(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 7-stage, fourth order low-storage low-dissipation, low-dispersion scheme with maximal accuracy and stability limit along the imaginary axes. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nKostas Tselios, T. E. Simos. Optimized Runge–Kutta Methods with Minimal Dispersion and Dissipation     for Problems arising from Computational Acoustics. Physics Letters A, 393(1-2), pp 38-47, 2007.     doi: https://doi.org/10.1016/j.physleta.2006.10.072\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.DGLDDRK84_C","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.DGLDDRK84_C","text":"DGLDDRK84_C(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False(),\n              williamson_condition = true)\n\nExplicit Runge-Kutta Method.  8-stage, fourth order low-storage low-dissipation, low-dispersion scheme for discontinuous Galerkin space discretizations applied to wave propagation problems. Optimized for PDE discretizations when maximum spatial step is small due to geometric features of computational domain. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nT. Toulorge, W. Desmet.     Optimal Runge–Kutta Schemes for Discontinuous Galerkin Space Discretizations     Applied to Wave Propagation Problems.     Journal of Computational Physics, 231(4), pp 2067-2091, 2012.     doi: https://doi.org/10.1016/j.jcp.2011.11.024\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.DGLDDRK84_F","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.DGLDDRK84_F","text":"DGLDDRK84_F(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False(),\n              williamson_condition = true)\n\nExplicit Runge-Kutta Method.  8-stage, fourth order low-storage low-dissipation, low-dispersion scheme for discontinuous Galerkin space discretizations applied to wave propagation problems. Optimized for PDE discretizations when the maximum spatial step size is not constrained. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nT. Toulorge, W. Desmet.     Optimal Runge–Kutta Schemes for Discontinuous Galerkin Space Discretizations     Applied to Wave Propagation Problems.     Journal of Computational Physics, 231(4), pp 2067-2091, 2012.     doi: https://doi.org/10.1016/j.jcp.2011.11.024\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.SHLDDRK64","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.SHLDDRK64","text":"SHLDDRK64(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False(),\n            williamson_condition = true)\n\nExplicit Runge-Kutta Method.  A fourth-order, six-stage low-storage method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nD. Stanescu, W. G. Habashi.     2N-Storage Low Dissipation and Dispersion Runge-Kutta Schemes for Computational     Acoustics.     Journal of Computational Physics, 143(2), pp 674-681, 1998.     doi: https://doi.org/10.1006/jcph.1998.5986     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.RK46NL","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.RK46NL","text":"RK46NL(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  6-stage, fourth order low-stage, low-dissipation, low-dispersion scheme. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nJulien Berland, Christophe Bogey, Christophe Bailly. Low-Dissipation and Low-Dispersion Fourth-Order Runge-Kutta Algorithm. Computers & Fluids, 35(10), pp 1459-1463, 2006. doi: https://doi.org/10.1016/j.compfluid.2005.04.003\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S32","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S32","text":"ParsaniKetchesonDeconinck3S32(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 3-stage, second order (3S) low-storage scheme, optimized  the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S82","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S82","text":"ParsaniKetchesonDeconinck3S82(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 8-stage, second order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S53","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S53","text":"ParsaniKetchesonDeconinck3S53(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 5-stage, third order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S173","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S173","text":"ParsaniKetchesonDeconinck3S173(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 17-stage, third order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S94","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S94","text":"ParsaniKetchesonDeconinck3S94(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 9-stage, fourth order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S184","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S184","text":"ParsaniKetchesonDeconinck3S184(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 18-stage, fourth order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S105","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S105","text":"ParsaniKetchesonDeconinck3S105(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 10-stage, fifth order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S205","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S205","text":"ParsaniKetchesonDeconinck3S205(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 20-stage, fifth order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK43_2","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK43_2","text":"CKLLSRK43_2(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 4-stage, third order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK54_3C","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK54_3C","text":"CKLLSRK54_3C(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK95_4S","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK95_4S","text":"CKLLSRK95_4S(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 9-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK95_4C","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK95_4C","text":"CKLLSRK95_4C(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 9-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK95_4M","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK95_4M","text":"CKLLSRK95_4M(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 9-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK54_3C_3R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK54_3C_3R","text":"CKLLSRK54_3C_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK54_3M_3R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK54_3M_3R","text":"CKLLSRK54_3M_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK54_3N_3R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK54_3N_3R","text":"CKLLSRK54_3N_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK85_4C_3R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK85_4C_3R","text":"CKLLSRK85_4C_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 8-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK85_4M_3R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK85_4M_3R","text":"CKLLSRK85_4M_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 8-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK85_4P_3R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK85_4P_3R","text":"CKLLSRK85_4P_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 8-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK54_3N_4R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK54_3N_4R","text":"CKLLSRK54_3N_4R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK54_3M_4R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK54_3M_4R","text":"CKLLSRK54_3M_4R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK65_4M_4R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK65_4M_4R","text":"CKLLSRK65_4M_4R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  6-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK85_4FM_4R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK85_4FM_4R","text":"CKLLSRK85_4FM_4R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                   step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                   thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 8-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK75_4M_5R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK75_4M_5R","text":"CKLLSRK75_4M_5R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  CKLLSRK754M5R: Low-Storage Method 7-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.RDPK3Sp35","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.RDPK3Sp35","text":"RDPK3Sp35(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, five-stage method with embedded error estimator designed for spectral element discretizations of compressible fluid mechanics.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021)     Optimized Runge-Kutta Methods with Automatic Step Size Control for     Compressible Computational Fluid Dynamics     arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.RDPK3SpFSAL35","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.RDPK3SpFSAL35","text":"RDPK3SpFSAL35(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, five-stage method with embedded error estimator using the FSAL property designed for spectral element discretizations of compressible fluid mechanics.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021)     Optimized Runge-Kutta Methods with Automatic Step Size Control for     Compressible Computational Fluid Dynamics     arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.RDPK3Sp49","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.RDPK3Sp49","text":"RDPK3Sp49(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A fourth-order, nine-stage method with embedded error estimator designed for spectral element discretizations of compressible fluid mechanics.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021)     Optimized Runge-Kutta Methods with Automatic Step Size Control for     Compressible Computational Fluid Dynamics     arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.RDPK3SpFSAL49","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.RDPK3SpFSAL49","text":"RDPK3SpFSAL49(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A fourth-order, nine-stage method with embedded error estimator using the FSAL property designed for spectral element discretizations of compressible fluid mechanics.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021)     Optimized Runge-Kutta Methods with Automatic Step Size Control for     Compressible Computational Fluid Dynamics     arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.RDPK3Sp510","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.RDPK3Sp510","text":"RDPK3Sp510(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A fifth-order, ten-stage method with embedded error estimator designed for spectral element discretizations of compressible fluid mechanics.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021)     Optimized Runge-Kutta Methods with Automatic Step Size Control for     Compressible Computational Fluid Dynamics     arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.RDPK3SpFSAL510","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.RDPK3SpFSAL510","text":"RDPK3SpFSAL510(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                 step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                 thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A fifth-order, ten-stage method with embedded error estimator using the FSAL property designed for spectral element discretizations of compressible fluid mechanics.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021)     Optimized Runge-Kutta Methods with Automatic Step Size Control for     Compressible Computational Fluid Dynamics     arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.HSLDDRK64","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.HSLDDRK64","text":"HSLDDRK64(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False(),\n            williamson_condition = true)\n\nExplicit Runge-Kutta Method.  Low-Storage Method 6-stage, fourth order low-stage, low-dissipation, low-dispersion scheme. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nD. Stanescu, W. G. Habashi.     2N-Storage Low Dissipation and Dispersion Runge-Kutta Schemes for Computational     Acoustics.     Journal of Computational Physics, 143(2), pp 674-681, 1998.     doi: https://doi.org/10.1006/jcph.1998.5986     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.NDBLSRK134","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.NDBLSRK134","text":"NDBLSRK134(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False(),\n             williamson_condition = true)\n\nExplicit Runge-Kutta Method.  13-stage, fourth order low-storage method with optimized stability regions for advection-dominated problems. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nJens Niegemann, Richard Diehl, Kurt Busch.     Efficient Low-Storage Runge–Kutta Schemes with Optimized Stability Regions.     Journal of Computational Physics, 231, pp 364-372, 2012.     doi: https://doi.org/10.1016/j.jcp.2011.09.003\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.SHLDDRK_2N","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.SHLDDRK_2N","text":"SHLDDRK_2N(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low dissipation and dispersion Runge-Kutta schemes for computational acoustics\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{stanescu19982n,     title={2N-storage low dissipation and dispersion Runge-Kutta schemes for computational acoustics},     author={Stanescu, D and Habashi, WG},     journal={Journal of Computational Physics},     volume={143},     number={2},     pages={674–681},     year={1998},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.SHLDDRK52","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.SHLDDRK52","text":"SHLDDRK52(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low dissipation and dispersion Runge-Kutta schemes for computational acoustics\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{stanescu19982n,     title={2N-storage low dissipation and dispersion Runge-Kutta schemes for computational acoustics},     author={Stanescu, D and Habashi, WG},     journal={Journal of Computational Physics},     volume={143},     number={2},     pages={674–681},     year={1998},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner","text":"Verner methods are high-order explicit Runge-Kutta methods designed for high-accuracy integration of non-stiff differential equations. These are the preferred solvers when very low tolerances are required.","category":"section"},{"location":"explicit/Verner/#Key-Properties","page":"OrdinaryDiffEqVerner","title":"Key Properties","text":"Verner methods provide:\n\nHigh-order accuracy (6th through 9th order) for precise integration\nExcellent efficiency at low tolerances (1e-8 to 1e-15)\nRobust error estimation with embedded error control\nDense output capability with high-quality interpolation","category":"section"},{"location":"explicit/Verner/#When-to-Use-Verner-Methods","page":"OrdinaryDiffEqVerner","title":"When to Use Verner Methods","text":"Verner methods are recommended for:\n\nHigh-accuracy requirements with tolerances between 1e-8 and 1e-15\nSmooth non-stiff problems where high precision is critical\nLong-time integration where error accumulation must be minimized\nProblems requiring dense output with high interpolation accuracy\nOrbit computation, molecular dynamics, and other precision-critical applications","category":"section"},{"location":"explicit/Verner/#Solver-Selection-Guide","page":"OrdinaryDiffEqVerner","title":"Solver Selection Guide","text":"","category":"section"},{"location":"explicit/Verner/#Medium-low-tolerance-(1e-6-to-1e-8)","page":"OrdinaryDiffEqVerner","title":"Medium-low tolerance (1e-6 to 1e-8)","text":"Vern6: Sixth-order method, good balance of efficiency and accuracy\nAutoVern6: Automatic switching version for mixed stiffness","category":"section"},{"location":"explicit/Verner/#Low-tolerance-(1e-8-to-1e-12)-with-Float64","page":"OrdinaryDiffEqVerner","title":"Low tolerance (1e-8 to 1e-12) with Float64","text":"Vern7: Seventh-order method, excellent for most high-precision needs\nVern8: Eighth-order method, best efficiency at very low tolerances\nAutoVern7, AutoVern8: Automatic switching versions","category":"section"},{"location":"explicit/Verner/#Very-low-tolerance-(1e-12)","page":"OrdinaryDiffEqVerner","title":"Very low tolerance (<1e-12)","text":"Vern9: Ninth-order method for extreme precision requirements\nRecommended with BigFloat for tolerances below 1e-15\nAutoVern9: Automatic switching version for mixed problems","category":"section"},{"location":"explicit/Verner/#Performance-Notes","page":"OrdinaryDiffEqVerner","title":"Performance Notes","text":"Vern6: Most efficient for tolerances around 1e-6 to 1e-8\nVern7: Sweet spot for tolerances around 1e-8 to 1e-10\nVern8: Best for tolerances around 1e-10 to 1e-12\nVern9: For tolerances below 1e-12, especially with arbitrary precision\n\nThe Auto* variants automatically switch to stiff solvers when stiffness is detected, making them robust for problems of unknown character.\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqVerner\", \"Vern6\")","category":"section"},{"location":"explicit/Verner/#Full-list-of-solvers","page":"OrdinaryDiffEqVerner","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.Vern6","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.Vern6","text":"Vern6(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False(),\n        lazy = true)\n\nExplicit Runge-Kutta Method.  Verner's most efficient 6/5 method (lazy 6th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nlazy: determines if the lazy interpolant is used.\n\nReferences\n\n@article{verner2010numerically,     title={Numerically optimal Runge–Kutta pairs with interpolants},     author={Verner, James H},     journal={Numerical Algorithms},     volume={53},     number={2-3},     pages={383–396},     year={2010},     publisher={Springer}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.Vern7","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.Vern7","text":"Vern7(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False(),\n        lazy = true)\n\nExplicit Runge-Kutta Method.  Verner's most efficient 7/6 method (lazy 7th order interpolant). Good for problems requiring high accuracy. Slightly more computationally expensive than Tsit5. Performance best when parameter vector remains unchanged. Recommended for high-accuracy non-stiff problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nlazy: determines if the lazy interpolant is used.\n\nReferences\n\n@article{verner2010numerically,     title={Numerically optimal Runge–Kutta pairs with interpolants},     author={Verner, James H},     journal={Numerical Algorithms},     volume={53},     number={2-3},     pages={383–396},     year={2010},     publisher={Springer}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.Vern8","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.Vern8","text":"Vern8(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False(),\n        lazy = true)\n\nExplicit Runge-Kutta Method.  Verner's most efficient 8/7 method (lazy 8th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nlazy: determines if the lazy interpolant is used.\n\nReferences\n\n@article{verner2010numerically,     title={Numerically optimal Runge–Kutta pairs with interpolants},     author={Verner, James H},     journal={Numerical Algorithms},     volume={53},     number={2-3},     pages={383–396},     year={2010},     publisher={Springer}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.Vern9","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.Vern9","text":"Vern9(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False(),\n        lazy = true)\n\nExplicit Runge-Kutta Method.  Verner's most efficient 9/8 method (lazy 9th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nlazy: determines if the lazy interpolant is used.\n\nReferences\n\n@article{verner2010numerically,     title={Numerically optimal Runge–Kutta pairs with interpolants},     author={Verner, James H},     journal={Numerical Algorithms},     volume={53},     number={2-3},     pages={383–396},     year={2010},     publisher={Springer}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.AutoVern6","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.AutoVern6","text":"Automatic switching algorithm that can switch between the (non-stiff) Vern6() and stiff_alg.\n\nAutoVern6(stiff_alg; kwargs...)\n\nThis method is equivalent to AutoAlgSwitch(Vern6(), stiff_alg; kwargs...). To gain access to stiff algorithms you might have to install additional libraries, such as OrdinaryDiffEqRosenbrock.\n\n\n\n\n\n","category":"function"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.AutoVern7","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.AutoVern7","text":"Automatic switching algorithm that can switch between the (non-stiff) Vern7() and stiff_alg.\n\nAutoVern7(stiff_alg; kwargs...)\n\nThis method is equivalent to AutoAlgSwitch(Vern7(), stiff_alg; kwargs...). To gain access to stiff algorithms you might have to install additional libraries, such as OrdinaryDiffEqRosenbrock.\n\n\n\n\n\n","category":"function"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.AutoVern8","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.AutoVern8","text":"Automatic switching algorithm that can switch between the (non-stiff) Vern8() and stiff_alg.\n\nAutoVern8(stiff_alg; kwargs...)\n\nThis method is equivalent to AutoAlgSwitch(Vern8(), stiff_alg; kwargs...). To gain access to stiff algorithms you might have to install additional libraries, such as OrdinaryDiffEqRosenbrock.\n\n\n\n\n\n","category":"function"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.AutoVern9","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.AutoVern9","text":"Automatic switching algorithm that can switch between the (non-stiff) Vern9() and stiff_alg.\n\nAutoVern9(stiff_alg; kwargs...)\n\nThis method is equivalent to AutoAlgSwitch(Vern9(), stiff_alg; kwargs...). To gain access to stiff algorithms you might have to install additional libraries, such as OrdinaryDiffEqRosenbrock.\n\n\n\n\n\n","category":"function"},{"location":"#OrdinaryDiffEq.jl","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl","text":"OrdinaryDiffEq.jl is a component package in the DifferentialEquations ecosystem. It holds the core ordinary differential equation solvers and utilities. While completely independent and usable on its own, users interested in using this functionality should check out DifferentialEquations.jl.","category":"section"},{"location":"#Installation","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"Installation","text":"Assuming that you already have Julia correctly installed, it suffices to import OrdinaryDiffEq.jl in the standard way:\n\nimport Pkg;\nPkg.add(\"OrdinaryDiffEq\");","category":"section"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK","text":"Strong Stability Preserving Runge-Kutta (SSPRK) methods are specialized explicit Runge-Kutta methods designed to preserve important stability properties of the underlying spatial discretization when applied to hyperbolic partial differential equations and conservation laws.","category":"section"},{"location":"explicit/SSPRK/#Key-Properties","page":"OrdinaryDiffEqSSPRK","title":"Key Properties","text":"SSPRK methods provide:\n\nStrong stability preservation for convex functionals (total variation, maximum norm, entropy)\nOptimal SSP coefficients allowing larger stable timesteps\nNon-oscillatory behavior crucial for hyperbolic PDEs and conservation laws\nHigh-order accuracy while maintaining monotonicity properties\nSpecialized variants for different orders and storage requirements","category":"section"},{"location":"explicit/SSPRK/#When-to-Use-SSPRK-Methods","page":"OrdinaryDiffEqSSPRK","title":"When to Use SSPRK Methods","text":"SSPRK methods are essential for:\n\nHyperbolic partial differential equations (Euler equations, shallow water, etc.)\nConservation laws where preserving physical bounds is critical\nDiscontinuous Galerkin methods and other high-order spatial discretizations\nProblems requiring monotonicity preservation or total variation stability\nShock-capturing schemes where spurious oscillations must be avoided\nAstrophysical simulations and computational fluid dynamics","category":"section"},{"location":"explicit/SSPRK/#SSP-Coefficient-and-CFL-Conditions","page":"OrdinaryDiffEqSSPRK","title":"SSP Coefficient and CFL Conditions","text":"The SSP coefficient determines the maximum allowable timestep for stability preservation. Use OrdinaryDiffEqCore.ssp_coefficient(alg) to query this value for step size calculations. The timestep must satisfy dt ≤ CFL * dx / max_wavespeed where CFL ≤ SSP coefficient.","category":"section"},{"location":"explicit/SSPRK/#Solver-Selection-Guide","page":"OrdinaryDiffEqSSPRK","title":"Solver Selection Guide","text":"","category":"section"},{"location":"explicit/SSPRK/#Second-order-methods","page":"OrdinaryDiffEqSSPRK","title":"Second-order methods","text":"SSPRK22: Two-stage, second-order (SSP coefficient = 1)\nSSPRKMSVS32: Three-step multistep variant","category":"section"},{"location":"explicit/SSPRK/#Third-order-methods","page":"OrdinaryDiffEqSSPRK","title":"Third-order methods","text":"SSPRK33: Three-stage, third-order, optimal (SSP coefficient = 1)\nSSPRK53: Five-stage, third-order, higher SSP coefficient\nSSPRK63, SSPRK73, SSPRK83: More stages for larger SSP coefficients\nSSPRK43: Four-stage with embedded error estimation\nSSPRK432: Low-storage variant","category":"section"},{"location":"explicit/SSPRK/#Fourth-order-methods","page":"OrdinaryDiffEqSSPRK","title":"Fourth-order methods","text":"SSPRK54: Five-stage, fourth-order\nSSPRK104: Ten-stage, fourth-order, large SSP coefficient","category":"section"},{"location":"explicit/SSPRK/#Low-storage-variants","page":"OrdinaryDiffEqSSPRK","title":"Low-storage variants","text":"SSPRK53_2N1, SSPRK53_2N2, SSPRK53_H: Two-register storage schemes","category":"section"},{"location":"explicit/SSPRK/#Discontinuous-Galerkin-optimized","page":"OrdinaryDiffEqSSPRK","title":"Discontinuous Galerkin optimized","text":"KYKSSPRK42: Optimized for DG spatial discretizations\nKYK2014DGSSPRK_3S2: Specialized DG method","category":"section"},{"location":"explicit/SSPRK/#Adaptive-methods","page":"OrdinaryDiffEqSSPRK","title":"Adaptive methods","text":"SSPRK432: Third-order with error control\nSSPRK932: High-stage adaptive method\nSSPRKMSVS43: Multistep adaptive variant\n\nfirst_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqSSPRK\", \"SSPRK22\")","category":"section"},{"location":"explicit/SSPRK/#Full-list-of-solvers","page":"OrdinaryDiffEqSSPRK","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK22","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK22","text":"SSPRK22(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A second-order, two-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nShu, Chi-Wang, and Stanley Osher.     Efficient implementation of essentially non-oscillatory shock-capturing schemes.     Journal of Computational Physics 77.2 (1988): 439-471.     https://doi.org/10.1016/0021-9991(88)90177-5\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK33","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK33","text":"SSPRK33(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, three-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nShu, Chi-Wang, and Stanley Osher.     Efficient implementation of essentially non-oscillatory shock-capturing schemes.     Journal of Computational Physics 77.2 (1988): 439-471.     https://doi.org/10.1016/0021-9991(88)90177-5\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK53","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK53","text":"SSPRK53(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, five-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRuuth, Steven.     Global optimization of explicit strong-stability-preserving Runge-Kutta methods.     Mathematics of Computation 75.253 (2006): 183-207\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.KYKSSPRK42","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.KYKSSPRK42","text":"KYKSSPRK42(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Optimal strong-stability-preserving Runge-Kutta time discretizations for discontinuous Galerkin methods\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kubatko2014optimal,     title={Optimal strong-stability-preserving Runge–Kutta time discretizations for discontinuous Galerkin methods},     author={Kubatko, Ethan J and Yeager, Benjamin A and Ketcheson, David I},     journal={Journal of Scientific Computing},     volume={60},     pages={313–344},     year={2014},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.KYK2014DGSSPRK_3S2","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.KYK2014DGSSPRK_3S2","text":"KYK2014DGSSPRK_3S2(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                     step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                     thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Optimal strong-stability-preserving Runge-Kutta time discretizations for discontinuous Galerkin methods\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kubatko2014optimal, title={Optimal strong-stability-preserving Runge–Kutta time discretizations for discontinuous Galerkin methods}, author={Kubatko, Ethan J and Yeager, Benjamin A and Ketcheson, David I}, journal={Journal of Scientific Computing}, volume={60}, pages={313–344}, year={2014}, publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK53_2N1","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK53_2N1","text":"SSPRK53_2N1(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, five-stage explicit strong stability preserving (SSP) low-storage method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nHigueras and T. Roldán.     New third order low-storage SSP explicit Runge–Kutta methods     arXiv:1809.04807v1.\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK53_2N2","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK53_2N2","text":"SSPRK53_2N2(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, five-stage explicit strong stability preserving (SSP) low-storage method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nHigueras and T. Roldán.     New third order low-storage SSP explicit Runge–Kutta methods     arXiv:1809.04807v1.\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK53_H","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK53_H","text":"SSPRK53_H(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, five-stage explicit strong stability preserving (SSP) low-storage method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nHigueras and T. Roldán.     New third order low-storage SSP explicit Runge–Kutta methods     arXiv:1809.04807v1.\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK63","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK63","text":"SSPRK63(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, six-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRuuth, Steven.     Global optimization of explicit strong-stability-preserving Runge-Kutta methods.     Mathematics of Computation 75.253 (2006): 183-207\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK73","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK73","text":"SSPRK73(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, seven-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRuuth, Steven.     Global optimization of explicit strong-stability-preserving Runge-Kutta methods.     Mathematics of Computation 75.253 (2006): 183-207\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK83","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK83","text":"SSPRK83(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, eight-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRuuth, Steven.     Global optimization of explicit strong-stability-preserving Runge-Kutta methods.     Mathematics of Computation 75.253 (2006): 183-207\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK43","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK43","text":"SSPRK43(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, four-stage explicit strong stability preserving (SSP) method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nOptimal third-order explicit SSP method with four stages discovered by\n\nJ. F. B. M. Kraaijevanger. \"Contractivity of Runge-Kutta methods.\" In: BIT Numerical Mathematics 31.3 (1991), pp. 482–528. DOI: 10.1007/BF01933264.\n\nEmbedded method constructed by\n\nSidafa Conde, Imre Fekete, John N. Shadid. \"Embedded error estimation and adaptive step-size control for optimal explicit strong stability preserving Runge–Kutta methods.\" arXiv: 1806.08693\n\nEfficient implementation (and optimized controller) developed by\n\nHendrik Ranocha, Lisandro Dalcin, Matteo Parsani, David I. Ketcheson (2021) Optimized Runge-Kutta Methods with Automatic Step Size Control for Compressible Computational Fluid Dynamics arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK432","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK432","text":"SSPRK432(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, four-stage explicit strong stability preserving (SSP) method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nGottlieb, Sigal, David I. Ketcheson, and Chi-Wang Shu.     Strong stability preserving Runge-Kutta and multistep time discretizations.     World Scientific, 2011.     Example 6.1\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRKMSVS43","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRKMSVS43","text":"SSPRKMSVS43(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, four-step explicit strong stability preserving (SSP) linear multistep method. This method does not come with an error estimator and requires a fixed time step size.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nShu, Chi-Wang.     Total-variation-diminishing time discretizations.     SIAM Journal on Scientific and Statistical Computing 9, no. 6 (1988): 1073-1084.     DOI: 10.1137/0909073\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRKMSVS32","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRKMSVS32","text":"SSPRKMSVS32(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A second-order, three-step explicit strong stability preserving (SSP) linear multistep method. This method does not come with an error estimator and requires a fixed time step size.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nShu, Chi-Wang.     Total-variation-diminishing time discretizations.     SIAM Journal on Scientific and Statistical Computing 9, no. 6 (1988): 1073-1084.     DOI: 10.1137/0909073\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK932","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK932","text":"SSPRK932(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, nine-stage explicit strong stability preserving (SSP) method.\n\nConsider using SSPRK43 instead, which uses the same main method and an improved embedded method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nGottlieb, Sigal, David I. Ketcheson, and Chi-Wang Shu.     Strong stability preserving Runge-Kutta and multistep time discretizations.     World Scientific, 2011.\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK54","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK54","text":"SSPRK54(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A fourth-order, five-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRuuth, Steven.     Global optimization of explicit strong-stability-preserving Runge-Kutta methods.     Mathematics of Computation 75.253 (2006): 183-207.\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK104","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK104","text":"SSPRK104(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A fourth-order, ten-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nKetcheson, David I.     Highly efficient strong stability-preserving Runge–Kutta methods with     low-storage implementations.     SIAM Journal on Scientific Computing 30.4 (2008): 2113-2136.\n\n\n\n\n\n","category":"type"},{"location":"imex/IMEXMultistep/#OrdinaryDiffEqIMEXMultistep","page":"OrdinaryDiffEqIMEXMultistep","title":"OrdinaryDiffEqIMEXMultistep","text":"Standard low-order IMEX (Implicit-Explicit) multistep methods for problems that can be split into stiff and non-stiff components. These are widely used classical methods in partial differential equation applications, providing simple and reliable IMEX integration with moderate accuracy requirements.","category":"section"},{"location":"imex/IMEXMultistep/#Key-Properties","page":"OrdinaryDiffEqIMEXMultistep","title":"Key Properties","text":"IMEX Multistep methods provide:\n\nStandard IMEX formulations commonly used in PDE applications\nLow-order accuracy (typically 2nd order) with good stability\nSimple implementation and well-understood behavior\nExplicit treatment of non-stiff terms with implicit handling of stiff components\nFixed timestep requirements due to multistep nature\nEfficient for large-scale problems where splitting is natural","category":"section"},{"location":"imex/IMEXMultistep/#When-to-Use-IMEX-Multistep-Methods","page":"OrdinaryDiffEqIMEXMultistep","title":"When to Use IMEX Multistep Methods","text":"These methods are recommended for:\n\nClassical PDE applications where standard IMEX methods are established\nReaction-diffusion systems with natural explicit/implicit splitting\nConvection-diffusion problems where convection is explicit and diffusion implicit\nLarge-scale spatial discretizations where simple, efficient methods are preferred\nApplications prioritizing robustness over high-order accuracy\nProblems with natural operator splitting methodology","category":"section"},{"location":"imex/IMEXMultistep/#Mathematical-Background","page":"OrdinaryDiffEqIMEXMultistep","title":"Mathematical Background","text":"IMEX multistep methods treat the split system: du/dt = f₁(u,t) + f₂(u,t)\n\nusing:\n\nImplicit multistep schemes (like Crank-Nicolson) for stiff terms f₁\nExplicit multistep schemes (like Adams-Bashforth) for non-stiff terms f₂\n\nThis combination provides stability for stiff components while maintaining efficiency for non-stiff parts.","category":"section"},{"location":"imex/IMEXMultistep/#Problem-Splitting-Requirements","page":"OrdinaryDiffEqIMEXMultistep","title":"Problem Splitting Requirements","text":"These methods require a SplitODEProblem where:\n\nFirst function f₁ contains stiff terms requiring implicit treatment\nSecond function f₂ contains non-stiff terms suitable for explicit treatment\nSplitting should align with the natural time scale separation\nLinear stiff terms work particularly well with these methods","category":"section"},{"location":"imex/IMEXMultistep/#Solver-Selection-Guide","page":"OrdinaryDiffEqIMEXMultistep","title":"Solver Selection Guide","text":"","category":"section"},{"location":"imex/IMEXMultistep/#Available-Methods","page":"OrdinaryDiffEqIMEXMultistep","title":"Available Methods","text":"CNAB2: Recommended - Crank-Nicolson Adams-Bashforth 2nd order method\nCNLF2: Crank-Nicolson Leap-Frog 2nd order method","category":"section"},{"location":"imex/IMEXMultistep/#Method-characteristics","page":"OrdinaryDiffEqIMEXMultistep","title":"Method characteristics","text":"CNAB2: Most commonly used, good stability and accuracy balance\nCNLF2: Alternative formulation, may have different stability properties","category":"section"},{"location":"imex/IMEXMultistep/#Performance-Guidelines","page":"OrdinaryDiffEqIMEXMultistep","title":"Performance Guidelines","text":"","category":"section"},{"location":"imex/IMEXMultistep/#When-IMEX-Multistep-methods-excel","page":"OrdinaryDiffEqIMEXMultistep","title":"When IMEX Multistep methods excel","text":"PDE problems with established IMEX splitting practices\nLarge spatial discretizations where method efficiency matters more than high accuracy\nProblems with linear stiff terms that are efficiently handled implicitly\nApplications requiring consistent timesteps (no adaptive timestepping)\nWell-conditioned problems where simple methods suffice","category":"section"},{"location":"imex/IMEXMultistep/#Splitting-strategy-considerations","page":"OrdinaryDiffEqIMEXMultistep","title":"Splitting strategy considerations","text":"Linear diffusion terms → implicit component (f₁)\nNonlinear convection/reaction → explicit component (f₂) if not too stiff\nSource terms → choose based on stiffness characteristics\nBoundary conditions → often naturally handled in implicit component","category":"section"},{"location":"imex/IMEXMultistep/#Limitations-and-Considerations","page":"OrdinaryDiffEqIMEXMultistep","title":"Limitations and Considerations","text":"","category":"section"},{"location":"imex/IMEXMultistep/#Method-limitations","page":"OrdinaryDiffEqIMEXMultistep","title":"Method limitations","text":"Fixed timestep required - no adaptive timestepping capabilities\nLow order only - maximum 2nd order accuracy\nStartup procedures needed for multistep methods\nLimited stability analysis compared to modern IMEX-RK methods","category":"section"},{"location":"imex/IMEXMultistep/#When-to-consider-alternatives","page":"OrdinaryDiffEqIMEXMultistep","title":"When to consider alternatives","text":"Higher accuracy needs: Use IMEX-RK or higher-order IMEX methods\nAdaptive timestepping: Use IMEX-RK or ARK methods\nComplex stability requirements: Use more sophisticated IMEX schemes\nVery stiff problems: Consider fully implicit methods","category":"section"},{"location":"imex/IMEXMultistep/#Alternative-Approaches","page":"OrdinaryDiffEqIMEXMultistep","title":"Alternative Approaches","text":"Consider these alternatives:\n\nIMEX Runge-Kutta methods for adaptive timestepping and higher order\nIMEX BDF methods for better stability properties and higher accuracy\nFully implicit methods if splitting is not beneficial\nExponential integrators for linear stiff problems","category":"section"},{"location":"imex/IMEXMultistep/#Classical-Applications","page":"OrdinaryDiffEqIMEXMultistep","title":"Classical Applications","text":"These methods are standard in:\n\nComputational fluid dynamics for incompressible Navier-Stokes equations\nAtmospheric modeling for advection-diffusion-reaction systems\nOcean modeling for transport equations with diffusion\nAstrophysical simulations for multiphysics problems\n\nimex_first_steps = evalfile(\"./common_imex_first_steps.jl\")\nimex_first_steps(\"OrdinaryDiffEqIMEXMultistep\", \"CNAB2\")","category":"section"},{"location":"imex/IMEXMultistep/#Full-list-of-solvers","page":"OrdinaryDiffEqIMEXMultistep","title":"Full list of solvers","text":"","category":"section"},{"location":"imex/IMEXMultistep/#OrdinaryDiffEqIMEXMultistep.CNAB2","page":"OrdinaryDiffEqIMEXMultistep","title":"OrdinaryDiffEqIMEXMultistep.CNAB2","text":"CNAB2()\n\nIMEX Multistep method. Crank-Nicolson Adams Bashforth Order 2 (fixed time step)\n\nKeyword Arguments\n\nReferences\n\n@article{jorgenson2014unconditional,     title={Unconditional stability of a Crank-Nicolson Adams-Bashforth 2 numerical method},     author={JORGENSON, ANDREW D},     journal={A (A- C)},     volume={1},     number={2},     pages={1},     year={2014}}     @article{he2010numerical,     title={Numerical implementation of the Crank–Nicolson/Adams–Bashforth scheme for the time-dependent Navier–Stokes equations},     author={He, Yinnian and Li, Jian},     journal={International journal for numerical methods in fluids},     volume={62},     number={6},     pages={647–659},     year={2010},     publisher={Wiley Online Library}}\n\n\n\n\n\n","category":"type"},{"location":"imex/IMEXMultistep/#OrdinaryDiffEqIMEXMultistep.CNLF2","page":"OrdinaryDiffEqIMEXMultistep","title":"OrdinaryDiffEqIMEXMultistep.CNLF2","text":"CNLF2()\n\nIMEX Multistep method. Crank-Nicholson Leapfrong 2.\n\nKeyword Arguments\n\nReferences\n\n@article{han2020second,     title={A second order, linear, unconditionally stable, Crank–Nicolson–Leapfrog scheme for phase field models of two-phase incompressible flows},     author={Han, Daozhi and Jiang, Nan},     journal={Applied Mathematics Letters},     volume={108},     pages={106521},     year={2020},     publisher={Elsevier}}     @article{jiang2015crank,     title={A Crank–Nicolson Leapfrog stabilization: Unconditional stability and two applications},     author={Jiang, Nan and Kubacki, Michaela and Layton, William and Moraiti, Marina and Tran, Hoang},     journal={Journal of Computational and Applied Mathematics},     volume={281},     pages={263–276},     year={2015},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"}]
}
