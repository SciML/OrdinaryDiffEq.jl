<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>OrdinaryDiffEqFIRK · OrdinaryDiffEq.jl</title><meta name="title" content="OrdinaryDiffEqFIRK · OrdinaryDiffEq.jl"/><meta property="og:title" content="OrdinaryDiffEqFIRK · OrdinaryDiffEq.jl"/><meta property="twitter:title" content="OrdinaryDiffEqFIRK · OrdinaryDiffEq.jl"/><meta name="description" content="Documentation for OrdinaryDiffEq.jl."/><meta property="og:description" content="Documentation for OrdinaryDiffEq.jl."/><meta property="twitter:description" content="Documentation for OrdinaryDiffEq.jl."/><meta property="og:url" content="https://ordinarydiffeq.sciml.ai/stable/implicit/FIRK/"/><meta property="twitter:url" content="https://ordinarydiffeq.sciml.ai/stable/implicit/FIRK/"/><link rel="canonical" href="https://ordinarydiffeq.sciml.ai/stable/implicit/FIRK/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="OrdinaryDiffEq.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">OrdinaryDiffEq.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">OrdinaryDiffEq.jl: ODE solvers and utilities</a></li><li><a class="tocitem" href="../../usage/">Usage</a></li><li><span class="tocitem">Explicit Solvers</span><ul><li><a class="tocitem" href="../../explicit/Tsit5/">OrdinaryDiffEqTsit5</a></li><li><a class="tocitem" href="../../explicit/Verner/">OrdinaryDiffEqVerner</a></li><li><a class="tocitem" href="../../explicit/AdamsBashforthMoulton/">OrdinaryDiffEqAdamsBashforthMoulton</a></li><li><a class="tocitem" href="../../explicit/LowStorageRK/">OrdinaryDiffEqLowStorageRK</a></li><li><a class="tocitem" href="../../explicit/SSPRK/">OrdinaryDiffEqSSPRK</a></li><li><a class="tocitem" href="../../explicit/LowOrderRK/">OrdinaryDiffEqLowOrderRK</a></li><li><a class="tocitem" href="../../explicit/HighOrderRK/">OrdinaryDiffEqHighOrderRK</a></li><li><a class="tocitem" href="../../explicit/Feagin/">OrdinaryDiffEqFeagin</a></li><li><a class="tocitem" href="../../explicit/PRK/">OrdinaryDiffEqPRK</a></li><li><a class="tocitem" href="../../explicit/QPRK/">OrdinaryDiffEqQPRK</a></li><li><a class="tocitem" href="../../explicit/TaylorSeries/">OrdinaryDiffEqTaylorSeries</a></li><li><a class="tocitem" href="../../explicit/Extrapolation/">OrdinaryDiffEqExtrapolation</a></li></ul></li><li><span class="tocitem">Semi-Implicit Solvers</span><ul><li><a class="tocitem" href="../../semiimplicit/Rosenbrock/">OrdinaryDiffEqRosenbrock</a></li><li><a class="tocitem" href="../../semiimplicit/StabilizedRK/">OrdinaryDiffEqStabilizedRK</a></li><li><a class="tocitem" href="../../semiimplicit/ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li></ul></li><li><span class="tocitem">Implicit Solvers</span><ul><li><a class="tocitem" href="../SDIRK/">OrdinaryDiffEqSDIRK</a></li><li class="is-active"><a class="tocitem" href>OrdinaryDiffEqFIRK</a><ul class="internal"><li><a class="tocitem" href="#Key-Properties"><span>Key Properties</span></a></li><li><a class="tocitem" href="#When-to-Use-FIRK-Methods"><span>When to Use FIRK Methods</span></a></li><li><a class="tocitem" href="#Mathematical-Background"><span>Mathematical Background</span></a></li><li><a class="tocitem" href="#Computational-Considerations"><span>Computational Considerations</span></a></li><li><a class="tocitem" href="#Solver-Selection-Guide"><span>Solver Selection Guide</span></a></li><li><a class="tocitem" href="#Performance-Guidelines"><span>Performance Guidelines</span></a></li><li><a class="tocitem" href="#Full-list-of-solvers"><span>Full list of solvers</span></a></li></ul></li><li><a class="tocitem" href="../BDF/">OrdinaryDiffEqBDF</a></li><li><a class="tocitem" href="../Extrapolation/">OrdinaryDiffEqExtrapolation</a></li><li><a class="tocitem" href="../PDIRK/">OrdinaryDiffEqPDIRK</a></li><li><a class="tocitem" href="../Nordsieck/">OrdinaryDiffEqNordsieck</a></li></ul></li><li><span class="tocitem">IMEX Solvers</span><ul><li><a class="tocitem" href="../../imex/IMEXMultistep/">OrdinaryDiffEqIMEXMultistep</a></li><li><a class="tocitem" href="../../imex/StabilizedIRK/">OrdinaryDiffEqStabilizedIRK</a></li><li><a class="tocitem" href="../../imex/IMEXBDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><span class="tocitem">Dynamical ODE Explicit Solvers</span><ul><li><a class="tocitem" href="../../dynamicalodeexplicit/RKN/">OrdinaryDiffEqRKN</a></li><li><a class="tocitem" href="../../dynamicalodeexplicit/SymplecticRK/">OrdinaryDiffEqSymplecticRK</a></li></ul></li><li><span class="tocitem">Semilinear ODE Solvers</span><ul><li><a class="tocitem" href="../../semilinear/ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li><li><a class="tocitem" href="../../semilinear/Linear/">OrdinaryDiffEqLinear</a></li></ul></li><li><span class="tocitem">Mass Matrix DAE Solvers</span><ul><li><a class="tocitem" href="../../massmatrixdae/Rosenbrock/">OrdinaryDiffEqRosenbrock</a></li><li><a class="tocitem" href="../../massmatrixdae/BDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><span class="tocitem">Fully Implicit DAE Solvers</span><ul><li><a class="tocitem" href="../../fullyimplicitdae/BDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><span class="tocitem">Misc Solvers</span><ul><li><a class="tocitem" href="../../misc/">Miscellaneous Solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Implicit Solvers</a></li><li class="is-active"><a href>OrdinaryDiffEqFIRK</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>OrdinaryDiffEqFIRK</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/OrdinaryDiffEq.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/master/docs/src/implicit/FIRK.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="OrdinaryDiffEqFIRK"><a class="docs-heading-anchor" href="#OrdinaryDiffEqFIRK">OrdinaryDiffEqFIRK</a><a id="OrdinaryDiffEqFIRK-1"></a><a class="docs-heading-anchor-permalink" href="#OrdinaryDiffEqFIRK" title="Permalink"></a></h1><p>Fully Implicit Runge-Kutta (FIRK) methods for stiff differential equations requiring very high accuracy. These methods solve a fully coupled implicit system at each timestep, providing superior accuracy and stability compared to diagonally implicit methods.</p><div class="admonition is-warning" id="Real-Numbers-Only-68e9a25eb5ed0d7b"><header class="admonition-header">Real Numbers Only<a class="admonition-anchor" href="#Real-Numbers-Only-68e9a25eb5ed0d7b" title="Permalink"></a></header><div class="admonition-body"><p>FIRK methods should only be used for problems defined on real numbers, not complex numbers.</p></div></div><h2 id="Key-Properties"><a class="docs-heading-anchor" href="#Key-Properties">Key Properties</a><a id="Key-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Properties" title="Permalink"></a></h2><p>FIRK methods provide:</p><ul><li><strong>Highest-order implicit methods</strong> (excluding extrapolation)</li><li><strong>Superior accuracy</strong> for very low tolerance requirements (≤ 1e-9)</li><li><strong>A-stable and L-stable</strong> behavior for stiff problems</li><li><strong>Higher order per stage</strong> than SDIRK methods (order 2s+1 for s stages)</li><li><strong>Special geometric properties</strong> (some methods are symplectic)</li><li><strong>Excellent for small to medium systems</strong> with high accuracy requirements</li></ul><h2 id="When-to-Use-FIRK-Methods"><a class="docs-heading-anchor" href="#When-to-Use-FIRK-Methods">When to Use FIRK Methods</a><a id="When-to-Use-FIRK-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-FIRK-Methods" title="Permalink"></a></h2><p>These methods are recommended for:</p><ul><li><strong>Very low tolerance problems</strong> (1e-9 and below) where accuracy is paramount</li><li><strong>Small to medium stiff systems</strong> (&lt; 200 equations)</li><li><strong>Problems requiring highest possible accuracy</strong> for implicit methods</li><li><strong>Stiff problems</strong> where SDIRK order limitations (max order 5) are insufficient</li><li><strong>Applications where computational cost is acceptable</strong> for maximum accuracy</li></ul><h2 id="Mathematical-Background"><a class="docs-heading-anchor" href="#Mathematical-Background">Mathematical Background</a><a id="Mathematical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background" title="Permalink"></a></h2><p>RadauIIA methods are based on Gaussian collocation and achieve order 2s+1 for s stages, making them among the highest-order implicit methods available. They represent the ODE analog of Gaussian quadrature. For more details on recent advances in FIRK methods, see our paper: <a href="https://arxiv.org/abs/2412.14362">High-Order Adaptive Time Stepping for the Incompressible Navier-Stokes Equations</a>.</p><h2 id="Computational-Considerations"><a class="docs-heading-anchor" href="#Computational-Considerations">Computational Considerations</a><a id="Computational-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Computational-Considerations" title="Permalink"></a></h2><h3 id="Advantages"><a class="docs-heading-anchor" href="#Advantages">Advantages</a><a id="Advantages-1"></a><a class="docs-heading-anchor-permalink" href="#Advantages" title="Permalink"></a></h3><ul><li><strong>Higher accuracy per stage</strong> than diagonal methods</li><li><strong>Better multithreading</strong> for small systems due to larger linear algebra operations</li><li><strong>No order restrictions</strong> like SDIRK methods (which max out at order 5)</li></ul><h3 id="Disadvantages"><a class="docs-heading-anchor" href="#Disadvantages">Disadvantages</a><a id="Disadvantages-1"></a><a class="docs-heading-anchor-permalink" href="#Disadvantages" title="Permalink"></a></h3><ul><li><strong>Limited to real-valued problems</strong> - cannot be used for complex number systems</li><li><strong>Higher implementation complexity</strong> compared to SDIRK methods</li></ul><h2 id="Solver-Selection-Guide"><a class="docs-heading-anchor" href="#Solver-Selection-Guide">Solver Selection Guide</a><a id="Solver-Selection-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-Selection-Guide" title="Permalink"></a></h2><h3 id="High-accuracy-requirements"><a class="docs-heading-anchor" href="#High-accuracy-requirements">High accuracy requirements</a><a id="High-accuracy-requirements-1"></a><a class="docs-heading-anchor-permalink" href="#High-accuracy-requirements" title="Permalink"></a></h3><ul><li><strong><code>AdaptiveRadau</code></strong>: <strong>Recommended</strong> - adaptive order method that automatically selects optimal order</li><li><strong><code>RadauIIA5</code></strong>: 5th-order method, good balance of accuracy and efficiency</li><li><strong><code>RadauIIA9</code></strong>: 9th-order method for extremely high accuracy requirements</li><li><strong><code>RadauIIA3</code></strong>: 3rd-order method for moderate accuracy needs</li></ul><h3 id="System-size-considerations"><a class="docs-heading-anchor" href="#System-size-considerations">System size considerations</a><a id="System-size-considerations-1"></a><a class="docs-heading-anchor-permalink" href="#System-size-considerations" title="Permalink"></a></h3><ul><li><strong>Systems &lt; 200</strong>: FIRK methods are competitive due to better multithreading</li><li><strong>Systems &gt; 200</strong>: Consider SDIRK or BDF methods instead</li></ul><h2 id="Performance-Guidelines"><a class="docs-heading-anchor" href="#Performance-Guidelines">Performance Guidelines</a><a id="Performance-Guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Guidelines" title="Permalink"></a></h2><ul><li><strong>Best for tolerances ≤ 1e-9</strong> where high accuracy justifies the cost</li><li><strong>Most efficient on small to medium systems</strong> where linear algebra cost is manageable</li><li><strong>Should be tested against</strong> parallel implicit extrapolation methods which specialize in similar regimes</li><li><strong>Compare with</strong> high-order SDIRK methods for borderline cases</li></ul><h2>Installation</h2><p>To be able to access the solvers in <code>OrdinaryDiffEqFIRK</code>, you must first install them use the Julia package manager:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;OrdinaryDiffEqFIRK&quot;)</code></pre><p>This will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.</p><h2>Example usage</h2><pre><code class="language-julia hljs">using OrdinaryDiffEqFIRK

function lorenz!(du, u, p, t)
    du[1] = 10.0 * (u[2] - u[1])
    du[2] = u[1] * (28.0 - u[3]) - u[2]
    du[3] = u[1] * u[2] - (8 / 3) * u[3]
end
u0 = [1.0; 0.0; 0.0]
tspan = (0.0, 100.0)
prob = ODEProblem(lorenz!, u0, tspan)
sol = solve(prob, RadauIIA5())</code></pre><h2 id="Full-list-of-solvers"><a class="docs-heading-anchor" href="#Full-list-of-solvers">Full list of solvers</a><a id="Full-list-of-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Full-list-of-solvers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqFIRK.RadauIIA3" href="#OrdinaryDiffEqFIRK.RadauIIA3"><code>OrdinaryDiffEqFIRK.RadauIIA3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RadauIIA3(; chunk_size = Val{0}(),
            autodiff = AutoForwardDiff(),
            standardtag = Val{true}(),
            concrete_jac = nothing,
            diff_type = Val{:forward},
            linsolve = nothing,
            precs = DEFAULT_PRECS,
            extrapolant = :dense,
            smooth_est = true,
            step_limiter! = trivial_limiter!)</code></pre><p>Fully-Implicit Runge-Kutta Method. An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency. Similar to Hairer&#39;s SEULEX.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>RadauIIA3(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>extrapolant</code>: TBD</li><li><code>smooth_est</code>: TBD</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><p>@article{hairer1999stiff, title={Stiff differential equations solved by Radau methods}, author={Hairer, Ernst and Wanner, Gerhard}, journal={Journal of Computational and Applied Mathematics}, volume={111}, number={1-2}, pages={93–111}, year={1999}, publisher={Elsevier}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/804884cab088ccfa8734d5fbed4253d4d1dff28e/lib/OrdinaryDiffEqFIRK/src/algorithms.jl#L21-L105">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqFIRK.RadauIIA5" href="#OrdinaryDiffEqFIRK.RadauIIA5"><code>OrdinaryDiffEqFIRK.RadauIIA5</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RadauIIA5(; chunk_size = Val{0}(),
            autodiff = AutoForwardDiff(),
            standardtag = Val{true}(),
            concrete_jac = nothing,
            diff_type = Val{:forward},
            linsolve = nothing,
            precs = DEFAULT_PRECS,
            extrapolant = :dense,
            smooth_est = true,
            step_limiter! = trivial_limiter!)</code></pre><p>Fully-Implicit Runge-Kutta Method. An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency. 5th order method with excellent numerical stability. Good for highly stiff systems, problems requiring high-order implicit integration, systems with complex eigenvalue structures. Best for low tolerance stiff problems (&lt;1e-9).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>RadauIIA5(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>extrapolant</code>: TBD</li><li><code>smooth_est</code>: TBD</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><p>@article{hairer1999stiff, title={Stiff differential equations solved by Radau methods}, author={Hairer, Ernst and Wanner, Gerhard}, journal={Journal of Computational and Applied Mathematics}, volume={111}, number={1-2}, pages={93–111}, year={1999}, publisher={Elsevier}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/804884cab088ccfa8734d5fbed4253d4d1dff28e/lib/OrdinaryDiffEqFIRK/src/algorithms.jl#L68-L151">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqFIRK.RadauIIA9" href="#OrdinaryDiffEqFIRK.RadauIIA9"><code>OrdinaryDiffEqFIRK.RadauIIA9</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RadauIIA9(; chunk_size = Val{0}(),
            autodiff = AutoForwardDiff(),
            standardtag = Val{true}(),
            concrete_jac = nothing,
            diff_type = Val{:forward},
            linsolve = nothing,
            precs = DEFAULT_PRECS,
            extrapolant = :dense,
            smooth_est = true,
            step_limiter! = trivial_limiter!)</code></pre><p>Fully-Implicit Runge-Kutta Method. An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency. Similar to Hairer&#39;s SEULEX.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>RadauIIA9(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>extrapolant</code>: TBD</li><li><code>smooth_est</code>: TBD</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><p>@article{hairer1999stiff, title={Stiff differential equations solved by Radau methods}, author={Hairer, Ernst and Wanner, Gerhard}, journal={Journal of Computational and Applied Mathematics}, volume={111}, number={1-2}, pages={93–111}, year={1999}, publisher={Elsevier}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/804884cab088ccfa8734d5fbed4253d4d1dff28e/lib/OrdinaryDiffEqFIRK/src/algorithms.jl#L116-L200">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../SDIRK/">« OrdinaryDiffEqSDIRK</a><a class="docs-footer-nextpage" href="../BDF/">OrdinaryDiffEqBDF »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 22 July 2025 05:31">Tuesday 22 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
