var documenterSearchIndex = {"docs":
[{"location":"semilinear/Linear/#OrdinaryDiffEqLinear","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear","text":"","category":"section"},{"location":"semilinear/Linear/","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear","text":"Methods for semi-linear differential equations.","category":"page"},{"location":"semilinear/Linear/#Installation","page":"OrdinaryDiffEqLinear","title":"Installation","text":"","category":"section"},{"location":"semilinear/Linear/","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear","text":"To be able to access the solvers in OrdinaryDiffEqLinear, you must first install them use the Julia package manager:","category":"page"},{"location":"semilinear/Linear/","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear","text":"using Pkg\nPkg.add(\"OrdinaryDiffEqLinear\")","category":"page"},{"location":"semilinear/Linear/","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear","text":"This will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.","category":"page"},{"location":"semilinear/Linear/#Example-usage","page":"OrdinaryDiffEqLinear","title":"Example usage","text":"","category":"section"},{"location":"semilinear/Linear/","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear","text":"using OrdinaryDiffEqLinear, SciMLOperators\nfunction update_func(A, u, p, t)\n    A[1, 1] = 0\n    A[2, 1] = sin(u[1])\n    A[1, 2] = -1\n    A[2, 2] = 0\nend\nA0 = ones(2, 2)\nA = MatrixOperator(A0, update_func = update_func)\nu0 = ones(2)\ntspan = (0.0, 30.0)\nprob = ODEProblem(A, u0, tspan)\nsol = solve(prob, LieRK4(), dt = 1 / 4)","category":"page"},{"location":"semilinear/Linear/#Full-list-of-solvers","page":"OrdinaryDiffEqLinear","title":"Full list of solvers","text":"","category":"section"},{"location":"semilinear/Linear/#Time-and-State-Independent-Solvers","page":"OrdinaryDiffEqLinear","title":"Time and State-Independent Solvers","text":"","category":"section"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.LinearExponential","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.LinearExponential","text":"LinearExponential(; krylov = :off,\n                    m = 10,\n                    iop = 0)\n\nSemilinear ODE solver Exact solution formula for linear, time-independent problems.\n\nKeyword Arguments\n\nkrylov:\n:off: cache the operator beforehand. Requires Matrix(A) method defined for the operator A.\n:simple: uses simple Krylov approximations with fixed subspace size m.\n:adaptive: uses adaptive Krylov approximations with internal timestepping.\nm: Controls the size of Krylov subspace if krylov=:simple, and the initial subspace size if krylov=:adaptive.\niop: If not zero, determines the length of the incomplete orthogonalization procedure       Note that if the linear operator/Jacobian is hermitian,       then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@book{strogatz2018nonlinear,     title={Nonlinear dynamics and chaos: with applications to physics, biology, chemistry, and engineering},     author={Strogatz, Steven H},     year={2018},     publisher={CRC press}}\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#Time-Dependent-and-State-Independent-Solvers","page":"OrdinaryDiffEqLinear","title":"Time-Dependent and State-Independent Solvers","text":"","category":"section"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusMidpoint","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusMidpoint","text":"MagnusMidpoint(; krylov = false,\n                 m = 30,\n                 iop = 0)\n\nSemilinear ODE solver Second order Magnus Midpoint method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nhttps://joshuagoings.com/2017/06/15/magnus/\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusLeapfrog","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusLeapfrog","text":"MagnusLeapfrog(; krylov = false,\n                 m = 30,\n                 iop = 0)\n\nSemilinear ODE solver Second order Magnus Leapfrog method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nhttps://joshuagoings.com/2017/06/15/magnus/\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusGauss4","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusGauss4","text":"MagnusGauss4(; krylov = false,\n               m = 30,\n               iop = 0)\n\nSemilinear ODE solver Fourth order Magnus method approximated using a two stage Gauss quadrature.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{hairer2011solving,   title={Solving differential equations on manifolds},   author={Hairer, Ernst},   journal={Lecture notes},   year={2011} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusNC6","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusNC6","text":"MagnusNC6(; krylov = false,\n            m = 30,\n            iop = 0)\n\nSemilinear ODE solver Sixth order Magnus method approximated using Newton-Cotes quadrature.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{blanes2000improved,   title={Improved high order integrators based on the Magnus expansion},   author={Blanes, Sergio and Casas, Fernando and Ros, Javier},   journal={BIT Numerical Mathematics},   volume={40},   number={3},   pages={434–450},   year={2000},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusGL6","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusGL6","text":"MagnusGL6(; krylov = false,\n            m = 30,\n            iop = 0)\n\nSemilinear ODE solver Sixth order Magnus method approximated using Gauss-Legendre quadrature.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{blanes2000improved,   title={Improved high order integrators based on the Magnus expansion},   author={Blanes, Sergio and Casas, Fernando and Ros, Javier},   journal={BIT Numerical Mathematics},   volume={40},   number={3},   pages={434–450},   year={2000},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusGL8","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusGL8","text":"MagnusGL8(; krylov = false,\n            m = 30,\n            iop = 0)\n\nSemilinear ODE solver Eighth order Magnus method approximated using Newton-Cotes quadrature.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{blanes2000improved,   title={Improved high order integrators based on the Magnus expansion},   author={Blanes, Sergio and Casas, Fernando and Ros, Javier},   journal={BIT Numerical Mathematics},   volume={40},   number={3},   pages={434–450},   year={2000},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusNC8","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusNC8","text":"MagnusNC8(; krylov = false,\n            m = 30,\n            iop = 0)\n\nSemilinear ODE solver Eighth order Magnus method approximated using Gauss-Legendre quadrature.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{blanes2000improved,   title={Improved high order integrators based on the Magnus expansion},   author={Blanes, Sergio and Casas, Fernando and Ros, Javier},   journal={BIT Numerical Mathematics},   volume={40},   number={3},   pages={434–450},   year={2000},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusGL4","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusGL4","text":"MagnusGL4(; krylov = false,\n            m = 30,\n            iop = 0)\n\nSemilinear ODE solver Fourth order Magnus method approximated using Gauss-Legendre quadrature.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{blanes2009magnus,   title={The Magnus expansion and some of its applications},   author={Blanes, Sergio and Casas, Fernando and Oteo, Jose-Angel and Ros, Jos{'e}},   journal={Physics reports},   volume={470},   number={5-6},   pages={151–238},   year={2009},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#State-Dependent-Solvers","page":"OrdinaryDiffEqLinear","title":"State-Dependent Solvers","text":"","category":"section"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.LieEuler","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.LieEuler","text":"LieEuler(; krylov = false,\n           m = 30,\n           iop = 0)\n\nSemilinear ODE solver description\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{celledoni2014introduction,   title={An introduction to Lie group integrators–basics, new developments and applications},   author={Celledoni, Elena and Marthinsen, H{\u0007a}kon and Owren, Brynjulf},   journal={Journal of Computational Physics},   volume={257},   pages={1040–1061},   year={2014},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.RKMK2","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.RKMK2","text":"RKMK2(; krylov = false,\n        m = 30,\n        iop = 0)\n\nSemilinear ODE solver Second order Runge–Kutta–Munthe-Kaas method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{celledoni2014introduction,   title={An introduction to Lie group integrators–basics, new developments and applications},   author={Celledoni, Elena and Marthinsen, H{\u0007a}kon and Owren, Brynjulf},   journal={Journal of Computational Physics},   volume={257},   pages={1040–1061},   year={2014},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.RKMK4","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.RKMK4","text":"RKMK4(; krylov = false,\n        m = 30,\n        iop = 0)\n\nSemilinear ODE solver Fourth order Runge–Kutta–Munthe-Kaas method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{celledoni2014introduction,   title={An introduction to Lie group integrators–basics, new developments and applications},   author={Celledoni, Elena and Marthinsen, H{\u0007a}kon and Owren, Brynjulf},   journal={Journal of Computational Physics},   volume={257},   pages={1040–1061},   year={2014},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.LieRK4","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.LieRK4","text":"LieRK4(; krylov = false,\n         m = 30,\n         iop = 0)\n\nSemilinear ODE solver Fourth order Lie Runge-Kutta method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{celledoni2014introduction,   title={An introduction to Lie group integrators–basics, new developments and applications},   author={Celledoni, Elena and Marthinsen, H{\u0007a}kon and Owren, Brynjulf},   journal={Journal of Computational Physics},   volume={257},   pages={1040–1061},   year={2014},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.CG2","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.CG2","text":"CG2(; krylov = false,\n      m = 30,\n      iop = 0)\n\nSemilinear ODE solver Second order Crouch–Grossman method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{celledoni2014introduction,   title={An introduction to Lie group integrators–basics, new developments and applications},   author={Celledoni, Elena and Marthinsen, H{\u0007a}kon and Owren, Brynjulf},   journal={Journal of Computational Physics},   volume={257},   pages={1040–1061},   year={2014},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.CG4a","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.CG4a","text":"CG4a(; krylov = false,\n       m = 30,\n       iop = 0)\n\nSemilinear ODE solver  Fourth order Crouch-Grossman method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{jackiewicz2000construction,   title={Construction of Runge–Kutta methods of Crouch–Grossman type of high order},   author={Jackiewicz, Zdzislaw and Marthinsen, Arne and Owren, Brynjulf},   journal={Advances in Computational Mathematics},   volume={13},   pages={405–415},   year={2000},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.MagnusAdapt4","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.MagnusAdapt4","text":"MagnusAdapt4()\n\nSemilinear ODE solver Fourth Order Adaptive Magnus method.\n\nKeyword Arguments\n\nReferences\n\n@article{li2008adaptive,     title={Adaptive explicit Magnus numerical method for nonlinear dynamical systems},     author={Li, Wen-cheng and Deng, Zi-chen},     journal={Applied Mathematics and Mechanics},     volume={29},     number={9},     pages={1111–1118},     year={2008},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.CayleyEuler","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.CayleyEuler","text":"CayleyEuler()\n\nSemilinear ODE solver First order method using Cayley transformations.\n\nKeyword Arguments\n\nReferences\n\n@article{iserles2000lie,     title={Lie-group methods},     author={Iserles, Arieh and Munthe-Kaas, Hans Z and Norsett, Syvert P and Zanna, Antonella},     journal={Acta numerica},     volume={9},     pages={215–365},     year={2000},     publisher={Cambridge University Press}}\n\n\n\n\n\n","category":"type"},{"location":"semilinear/Linear/#Time-and-State-Dependent-Operators","page":"OrdinaryDiffEqLinear","title":"Time and State-Dependent Operators","text":"","category":"section"},{"location":"semilinear/Linear/#OrdinaryDiffEqLinear.CG3","page":"OrdinaryDiffEqLinear","title":"OrdinaryDiffEqLinear.CG3","text":"CG3(; krylov = false,\n      m = 30,\n      iop = 0)\n\nSemilinear ODE solver Third order Crouch-Grossman method.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\n@article{crouch1993numerical,   title={Numerical integration of ordinary differential equations on manifolds},   author={Crouch, Peter E and Grossman, R},   journal={Journal of Nonlinear Science},   volume={3},   pages={1–33},   year={1993},   publisher={Springer} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/PDIRK/#OrdinaryDiffEqPDIRK","page":"OrdinaryDiffEqPDIRK","title":"OrdinaryDiffEqPDIRK","text":"","category":"section"},{"location":"implicit/PDIRK/","page":"OrdinaryDiffEqPDIRK","title":"OrdinaryDiffEqPDIRK","text":"PDIRK methods are parallel DIRK methods. SDIRK methods, or singly-diagonally implicit methods, have to build and solve a factorize a Jacobian of the form W = I-gammaJ where gamma is dependent on the chosen method. PDIRK methods use multiple different choices of gamma, i.e. W_i = I-gamma_iJ, which are all used in the update process. There are some advantages to this, as no SDIRK method can be a higher order than 5, while DIRK methods generally can have arbitrarily high order and lower error coefficients, leading to lower errors at larger dt sizes. With the right construction of the tableau, these matrices can be factorized and the underlying steps can be computed in parallel, which is why these are the parallel DIRK methods.","category":"page"},{"location":"implicit/PDIRK/","page":"OrdinaryDiffEqPDIRK","title":"OrdinaryDiffEqPDIRK","text":"warning: Experimental\nOrdinaryDiffEqPDIRK is experimental, as there are no parallel DIRK tableaus that achieve good performance in the literature.","category":"page"},{"location":"implicit/PDIRK/","page":"OrdinaryDiffEqPDIRK","title":"OrdinaryDiffEqPDIRK","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqPDIRK\", \"PDIRK44\")","category":"page"},{"location":"implicit/PDIRK/#Full-list-of-solvers","page":"OrdinaryDiffEqPDIRK","title":"Full list of solvers","text":"","category":"section"},{"location":"implicit/PDIRK/#OrdinaryDiffEqPDIRK.PDIRK44","page":"OrdinaryDiffEqPDIRK","title":"OrdinaryDiffEqPDIRK.PDIRK44","text":"PDIRK44(; chunk_size = Val{0}(),\n          autodiff = AutoForwardDiff(),\n          standardtag = Val{true}(),\n          concrete_jac = nothing,\n          diff_type = Val{:forward},\n          linsolve = nothing,\n          precs = DEFAULT_PRECS,\n          nlsolve = NLNewton(),\n          extrapolant = :constant,\n          thread = OrdinaryDiffEq.True())\n\nParallel Diagonally Implicit Runge-Kutta Method. A 2 processor 4th order diagonally non-adaptive implicit method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify PDIRK44(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD,\nextrapolant: TBD,\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n\"@article{iserles1990theory, title={On the theory of parallel Runge—Kutta methods}, author={Iserles, Arieh and Norrsett, SP}, journal={IMA Journal of numerical Analysis}, volume={10}, number={4}, pages={463–488}, year={1990}, publisher={Oxford University Press}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/Extrapolation/#StiffExtrapolation","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation","text":"","category":"section"},{"location":"implicit/Extrapolation/","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation","text":"Solvers based on within method parallelism. These solvers perform well for medium sized systems of ordinary differential equations, of about 20 to 500 equations, at low tolerances.","category":"page"},{"location":"implicit/Extrapolation/","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqExtrapolation\", \"ImplicitEulerBarycentricExtrapolation\")","category":"page"},{"location":"implicit/Extrapolation/#Full-list-of-solvers","page":"OrdinaryDiffEqExtrapolation","title":"Full list of solvers","text":"","category":"section"},{"location":"implicit/Extrapolation/#OrdinaryDiffEqExtrapolation.ImplicitEulerExtrapolation","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation.ImplicitEulerExtrapolation","text":"ImplicitEulerExtrapolation(; chunk_size = Val{0}(),\n                             autodiff = AutoForwardDiff(),\n                             standardtag = Val{true}(),\n                             concrete_jac = nothing,\n                             diff_type = Val{:forward},\n                             linsolve = nothing,\n                             precs = DEFAULT_PRECS,\n                             max_order = 12,\n                             min_order = 3,\n                             init_order = 5,\n                             thread = OrdinaryDiffEq.False(),\n                             sequence = :harmonic)\n\nParallelized Explicit Extrapolation Method. Extrapolation of implicit Euler method with Romberg sequence. Similar to Hairer's SEULEX.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ImplicitEulerExtrapolation(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nmax_order: maximum order of the adaptive order algorithm.\nmin_order: minimum order of the adaptive order algorithm.\ninit_order: initial order of the adaptive order algorithm.\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nsequence: the step-number sequences, also called the subdividing sequence. Possible values are :harmonic, :romberg or :bulirsch.\n\nReferences\n\n@inproceedings{elrod2022parallelizing,   title={Parallelizing explicit and implicit extrapolation methods for ordinary differential equations},   author={Elrod, Chris and Ma, Yingbo and Althaus, Konstantin and Rackauckas, Christopher and others},   booktitle={2022 IEEE High Performance Extreme Computing Conference (HPEC)},   pages={1–9},   year={2022},   organization={IEEE}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/Extrapolation/#OrdinaryDiffEqExtrapolation.ImplicitDeuflhardExtrapolation","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation.ImplicitDeuflhardExtrapolation","text":"ImplicitDeuflhardExtrapolation(; chunk_size = Val{0}(),\n                                 autodiff = AutoForwardDiff(),\n                                 standardtag = Val{true}(),\n                                 concrete_jac = nothing,\n                                 diff_type = Val{:forward},\n                                 linsolve = nothing,\n                                 precs = DEFAULT_PRECS,\n                                 max_order = 10,\n                                 min_order = 1,\n                                 init_order = 5,\n                                 thread = OrdinaryDiffEq.False(),\n                                 sequence = :harmonic)\n\nParallelized Explicit Extrapolation Method. Midpoint extrapolation using Barycentric coordinates.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ImplicitDeuflhardExtrapolation(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nmax_order: maximum order of the adaptive order algorithm.\nmin_order: minimum order of the adaptive order algorithm.\ninit_order: initial order of the adaptive order algorithm.\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nsequence: the step-number sequences, also called the subdividing sequence. Possible values are :harmonic, :romberg or :bulirsch.\n\nReferences\n\n@inproceedings{elrod2022parallelizing,   title={Parallelizing explicit and implicit extrapolation methods for ordinary differential equations},   author={Elrod, Chris and Ma, Yingbo and Althaus, Konstantin and Rackauckas, Christopher and others},   booktitle={2022 IEEE High Performance Extreme Computing Conference (HPEC)},   pages={1–9},   year={2022},   organization={IEEE}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/Extrapolation/#OrdinaryDiffEqExtrapolation.ImplicitHairerWannerExtrapolation","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation.ImplicitHairerWannerExtrapolation","text":"ImplicitHairerWannerExtrapolation(; chunk_size = Val{0}(),\n                                    autodiff = AutoForwardDiff(),\n                                    standardtag = Val{true}(),\n                                    concrete_jac = nothing,\n                                    diff_type = Val{:forward},\n                                    linsolve = nothing,\n                                    precs = DEFAULT_PRECS,\n                                    max_order = 10,\n                                    min_order = 2,\n                                    init_order = 5,\n                                    thread = OrdinaryDiffEq.False(),\n                                    sequence = :harmonic)\n\nParallelized Explicit Extrapolation Method. Midpoint extrapolation using Barycentric coordinates,     following Hairer's SODEX in the adaptivity behavior.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ImplicitHairerWannerExtrapolation(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nmax_order: maximum order of the adaptive order algorithm.\nmin_order: minimum order of the adaptive order algorithm.\ninit_order: initial order of the adaptive order algorithm.\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nsequence: the step-number sequences, also called the subdividing sequence. Possible values are :harmonic, :romberg or :bulirsch.\n\nReferences\n\n@inproceedings{elrod2022parallelizing,   title={Parallelizing explicit and implicit extrapolation methods for ordinary differential equations},   author={Elrod, Chris and Ma, Yingbo and Althaus, Konstantin and Rackauckas, Christopher and others},   booktitle={2022 IEEE High Performance Extreme Computing Conference (HPEC)},   pages={1–9},   year={2022},   organization={IEEE}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/Extrapolation/#OrdinaryDiffEqExtrapolation.ImplicitEulerBarycentricExtrapolation","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation.ImplicitEulerBarycentricExtrapolation","text":"ImplicitEulerBarycentricExtrapolation(; chunk_size = Val{0}(),\n                                        autodiff = AutoForwardDiff(),\n                                        standardtag = Val{true}(),\n                                        concrete_jac = nothing,\n                                        diff_type = Val{:forward},\n                                        linsolve = nothing,\n                                        precs = DEFAULT_PRECS,\n                                        max_order = 10,\n                                        min_order = 3,\n                                        init_order = 5,\n                                        thread = OrdinaryDiffEq.False(),\n                                        sequence = :harmonic,\n                                        sequence_factor = 2)\n\nParallelized Explicit Extrapolation Method. Euler extrapolation using Barycentric coordinates,     following Hairer's SODEX in the adaptivity behavior.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ImplicitEulerBarycentricExtrapolation(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nmax_order: maximum order of the adaptive order algorithm.\nmin_order: minimum order of the adaptive order algorithm.\ninit_order: initial order of the adaptive order algorithm.\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nsequence: the step-number sequences, also called the subdividing sequence. Possible values are :harmonic, :romberg or :bulirsch.\nsequence_factor: denotes which even multiple of sequence to take while evaluating internal discretizations.\n\nReferences\n\n@inproceedings{elrod2022parallelizing,   title={Parallelizing explicit and implicit extrapolation methods for ordinary differential equations},   author={Elrod, Chris and Ma, Yingbo and Althaus, Konstantin and Rackauckas, Christopher and others},   booktitle={2022 IEEE High Performance Extreme Computing Conference (HPEC)},   pages={1–9},   year={2022},   organization={IEEE}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/FIRK/#OrdinaryDiffEqFIRK","page":"OrdinaryDiffEqFIRK","title":"OrdinaryDiffEqFIRK","text":"","category":"section"},{"location":"implicit/FIRK/","page":"OrdinaryDiffEqFIRK","title":"OrdinaryDiffEqFIRK","text":"FIRK methods are fully implicit Runge-Kutta methods. They can have special properties, like be symplectic integrators, and can achieve higher order for the same number of stage in comparison to diagonal methods. However, the fully implicit methods have a larger implicit system to solve and thus have a higher linear algebra cost. This can be useful in some contexts to promote more parallelism, but also since the size of the factorization is cubic and the dominant cost for large equations, multiplying O(n^3) operations to O((sn)^3) can be a considerable cost increase for FIRK tableaus, where s, the number of stages, is particularly large. That said, the restriction to diagonal implicitness imposes order restrictions, such as SDIRK methods having a maximum order of 5, which can restrict the problems best suited for SDIRK methods.","category":"page"},{"location":"implicit/FIRK/","page":"OrdinaryDiffEqFIRK","title":"OrdinaryDiffEqFIRK","text":"The most common FIRK method in production are those based on RadauIIA tableaus, which is an ODE representation of Gaussian collocation. Like Gaussian collocation, it achieves higher order convergence than its stages, namely order 2s+1 for s stages. Thus RadauIIA FIRK methods tend to be some of the highest order methods (excluding extrapolation methods). This means that high order RadauIIA methods are recommended in the same scenarios that high-order explicit Runge-Kutta methods are recommended simply with the restriction of being a stiff equation. Such scenarios include cases like very low tolerances: RadauIIA methods can be the best performing methods for scenarios where tolerances are 1e-9 and below. Additionally, for ODE systems of size less than 200, the increased size of the Jacobian is mitigated by improved multithreading, since BLAS implementations are only good at multithreading LU factorizations after a certain matrix size. For this reason, RadauIIA methods tend to be recommended in cases where ODE size is small to intermediate and very accurate solutions are required.","category":"page"},{"location":"implicit/FIRK/","page":"OrdinaryDiffEqFIRK","title":"OrdinaryDiffEqFIRK","text":"They should be tested against the parallel implicit extrapolation which also specialize in this regime.","category":"page"},{"location":"implicit/FIRK/","page":"OrdinaryDiffEqFIRK","title":"OrdinaryDiffEqFIRK","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqFIRK\", \"RadauIIA5\")","category":"page"},{"location":"implicit/FIRK/#Full-list-of-solvers","page":"OrdinaryDiffEqFIRK","title":"Full list of solvers","text":"","category":"section"},{"location":"implicit/FIRK/#OrdinaryDiffEqFIRK.RadauIIA3","page":"OrdinaryDiffEqFIRK","title":"OrdinaryDiffEqFIRK.RadauIIA3","text":"RadauIIA3(; chunk_size = Val{0}(),\n            autodiff = AutoForwardDiff(),\n            standardtag = Val{true}(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward},\n            linsolve = nothing,\n            precs = DEFAULT_PRECS,\n            extrapolant = :dense,\n            smooth_est = true,\n            step_limiter! = trivial_limiter!)\n\nFully-Implicit Runge-Kutta Method. An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency. Similar to Hairer's SEULEX.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify RadauIIA3(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nextrapolant: TBD\nsmooth_est: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{hairer1999stiff, title={Stiff differential equations solved by Radau methods}, author={Hairer, Ernst and Wanner, Gerhard}, journal={Journal of Computational and Applied Mathematics}, volume={111}, number={1-2}, pages={93–111}, year={1999}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/FIRK/#OrdinaryDiffEqFIRK.RadauIIA5","page":"OrdinaryDiffEqFIRK","title":"OrdinaryDiffEqFIRK.RadauIIA5","text":"RadauIIA5(; chunk_size = Val{0}(),\n            autodiff = AutoForwardDiff(),\n            standardtag = Val{true}(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward},\n            linsolve = nothing,\n            precs = DEFAULT_PRECS,\n            extrapolant = :dense,\n            smooth_est = true,\n            step_limiter! = trivial_limiter!)\n\nFully-Implicit Runge-Kutta Method. An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency. Similar to Hairer's SEULEX.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify RadauIIA5(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nextrapolant: TBD\nsmooth_est: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{hairer1999stiff, title={Stiff differential equations solved by Radau methods}, author={Hairer, Ernst and Wanner, Gerhard}, journal={Journal of Computational and Applied Mathematics}, volume={111}, number={1-2}, pages={93–111}, year={1999}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/FIRK/#OrdinaryDiffEqFIRK.RadauIIA9","page":"OrdinaryDiffEqFIRK","title":"OrdinaryDiffEqFIRK.RadauIIA9","text":"RadauIIA9(; chunk_size = Val{0}(),\n            autodiff = AutoForwardDiff(),\n            standardtag = Val{true}(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward},\n            linsolve = nothing,\n            precs = DEFAULT_PRECS,\n            extrapolant = :dense,\n            smooth_est = true,\n            step_limiter! = trivial_limiter!)\n\nFully-Implicit Runge-Kutta Method. An A-B-L stable fully implicit Runge-Kutta method with internal tableau complex basis transform for efficiency. Similar to Hairer's SEULEX.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify RadauIIA9(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nextrapolant: TBD\nsmooth_est: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{hairer1999stiff, title={Stiff differential equations solved by Radau methods}, author={Hairer, Ernst and Wanner, Gerhard}, journal={Journal of Computational and Applied Mathematics}, volume={111}, number={1-2}, pages={93–111}, year={1999}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK","text":"","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK","text":"A symplectic integrator is an integrator whose solution resides on a symplectic manifold. Because of discretization error, when it is solving a Hamiltonian system it doesn't get exactly the correct trajectory on the manifold. Instead, that trajectory itself is perturbed O(Δtn) for the order n from the true trajectory. Then there's a linear drift due to numerical error of this trajectory over time Normal integrators tend to have a quadratic (or more) drift, and do not have any good global guarantees about this phase space path (just local). What means is that symplectic integrators tend to capture the long-time patterns better than normal integrators because of this lack of drift and this almost guarantee of periodicity.","category":"page"},{"location":"dynamicalodeexplicit/SymplecticRK/#Installation","page":"OrdinaryDiffEqSymplecticRK","title":"Installation","text":"","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK","text":"To be able to access the solvers in OrdinaryDiffEqSymplecticRK, you must first install them use the Julia package manager:","category":"page"},{"location":"dynamicalodeexplicit/SymplecticRK/","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK","text":"using Pkg\nPkg.add(\"OrdinaryDiffEqSymplecticRK\")","category":"page"},{"location":"dynamicalodeexplicit/SymplecticRK/","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK","text":"This will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.","category":"page"},{"location":"dynamicalodeexplicit/SymplecticRK/#Example-usage","page":"OrdinaryDiffEqSymplecticRK","title":"Example usage","text":"","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK","text":"using OrdinaryDiffEqSymplecticRK\nfunction HH_acceleration!(dv, v, u, p, t)\n    x, y = u\n    dx, dy = dv\n    dv[1] = -x - 2x * y\n    dv[2] = y^2 - y - x^2\nend\ninitial_positions = [0.0, 0.1]\ninitial_velocities = [0.5, 0.0]\ntspan = (0.0, 1.0)\nprob = SecondOrderODEProblem(HH_acceleration!, initial_velocities, initial_positions, tspan)\nsol = solve(prob, KahanLi8(), dt = 1 / 10)","category":"page"},{"location":"dynamicalodeexplicit/SymplecticRK/#Full-list-of-solvers","page":"OrdinaryDiffEqSymplecticRK","title":"Full list of solvers","text":"","category":"section"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.SymplecticEuler","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.SymplecticEuler","text":"SymplecticEuler()\n\nSymplectic Runge-Kutta Methods First order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\nhttps://en.wikipedia.org/wiki/Semi-implicitEulermethod\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.VelocityVerlet","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.VelocityVerlet","text":"VelocityVerlet()\n\nSymplectic Runge-Kutta Methods 2nd order explicit symplectic integrator. Requires f_2(t,u) = v, i.e. a second order ODE.\n\nKeyword Arguments\n\nReferences\n\n@article{verlet1967computer, title={Computer\" experiments\" on classical fluids. I. Thermodynamical properties of Lennard-Jones molecules}, author={Verlet, Loup}, journal={Physical review}, volume={159}, number={1}, pages={98}, year={1967}, publisher={APS} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.VerletLeapfrog","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.VerletLeapfrog","text":"VerletLeapfrog()\n\nSymplectic Runge-Kutta Methods 2nd order explicit symplectic integrator. Kick-drift-kick form. Requires only one evaluation of f1 per step.\n\nKeyword Arguments\n\nReferences\n\n@article{monaghan2005, \ttitle = {Smoothed particle hydrodynamics}, \tauthor = {Monaghan, Joseph J.}, \tyear = {2005}, \tjournal = {Reports on Progress in Physics}, \tvolume = {68}, \tnumber = {8}, \tpages = {1703–1759}, \tdoi = {10.1088/0034-4885/68/8/R01}, }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.LeapfrogDriftKickDrift","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.LeapfrogDriftKickDrift","text":"LeapfrogDriftKickDrift()\n\nSymplectic Runge-Kutta Methods 2nd order explicit symplectic integrator. Drift-kick-drift form of VerletLeapfrog designed to work when f1 depends on v. Requires two evaluation of f1 per step.\n\nKeyword Arguments\n\nReferences\n\n@article{monaghan2005, \ttitle = {Smoothed particle hydrodynamics}, \tauthor = {Monaghan, Joseph J.}, \tyear = {2005}, \tjournal = {Reports on Progress in Physics}, \tvolume = {68}, \tnumber = {8}, \tpages = {1703–1759}, \tdoi = {10.1088/0034-4885/68/8/R01}, }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.PseudoVerletLeapfrog","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.PseudoVerletLeapfrog","text":"PseudoVerletLeapfrog()\n\nSymplectic Runge-Kutta Methods 2nd order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{verlet1967computer, title={Computer\" experiments\" on classical fluids. I. Thermodynamical properties of Lennard-Jones molecules}, author={Verlet, Loup}, journal={Physical review}, volume={159}, number={1}, pages={98}, year={1967}, publisher={APS} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.McAte2","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.McAte2","text":"McAte2()\n\nSymplectic Runge-Kutta Methods Optimized efficiency 2nd order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{mclachlan1992accuracy, title={The accuracy of symplectic integrators}, author={McLachlan, Robert I and Atela, Pau}, journal={Nonlinearity}, volume={5}, number={2}, pages={541}, year={1992}, publisher={IOP Publishing} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.Ruth3","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.Ruth3","text":"Ruth3()\n\nSymplectic Runge-Kutta Methods 3rd order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{ruth1983canonical, title={A canonical integration technique}, author={Ruth, Ronald D}, journal={IEEE Trans. Nucl. Sci.}, volume={30}, number={CERN-LEP-TH-83-14}, pages={2669–2671}, year={1983}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.McAte3","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.McAte3","text":"McAte3()\n\nSymplectic Runge-Kutta Methods Optimized efficiency 3rd order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{mclachlan1992accuracy, title={The accuracy of symplectic integrators}, author={McLachlan, Robert I and Atela, Pau}, journal={Nonlinearity}, volume={5}, number={2}, pages={541}, year={1992}, publisher={IOP Publishing} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.CandyRoz4","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.CandyRoz4","text":"CandyRoz4()\n\nSymplectic Runge-Kutta Methods 4th order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{candy1991symplectic, itle={A symplectic integration algorithm for separable Hamiltonian functions}, uthor={Candy, J and Rozmus, W}, ournal={Journal of Computational Physics}, olume={92}, umber={1}, ages={230–256}, ear={1991}, ublisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.McAte4","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.McAte4","text":"McAte4()\n\nSymplectic Runge-Kutta Methods 4th order explicit symplectic integrator. Requires quadratic kinetic energy.\n\nKeyword Arguments\n\nReferences\n\n@article{mclachlan1992accuracy, title={The accuracy of symplectic integrators}, author={McLachlan, Robert I and Atela, Pau}, journal={Nonlinearity}, volume={5}, number={2}, pages={541}, year={1992}, publisher={IOP Publishing} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.CalvoSanz4","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.CalvoSanz4","text":"CalvoSanz4()\n\nSymplectic Runge-Kutta Methods Optimized efficiency 4th order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{sanz1993symplectic, title={Symplectic numerical methods for Hamiltonian problems}, author={Sanz-Serna, Jes{'u}s Maria and Calvo, Mari-Paz}, journal={International Journal of Modern Physics C}, volume={4}, number={02}, pages={385–392}, year={1993}, publisher={World Scientific} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.McAte42","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.McAte42","text":"McAte42()\n\nSymplectic Runge-Kutta Methods 4th order explicit symplectic integrator. BROKEN\n\nKeyword Arguments\n\nReferences\n\n@article{mclachlan1992accuracy, title={The accuracy of symplectic integrators}, author={McLachlan, Robert I and Atela, Pau}, journal={Nonlinearity}, volume={5}, number={2}, pages={541}, year={1992}, publisher={IOP Publishing} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.McAte5","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.McAte5","text":"McAte5()\n\nSymplectic Runge-Kutta Methods Optimized efficiency 5th order explicit symplectic integrator. Requires quadratic kinetic energy.\n\nKeyword Arguments\n\nReferences\n\n@article{mclachlan1992accuracy, title={The accuracy of symplectic integrators}, author={McLachlan, Robert I and Atela, Pau}, journal={Nonlinearity}, volume={5}, number={2}, pages={541}, year={1992}, publisher={IOP Publishing} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.Yoshida6","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.Yoshida6","text":"Yoshida6()\n\nSymplectic Runge-Kutta Methods 6th order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{yoshida1990construction, title={Construction of higher order symplectic integrators}, author={Yoshida, Haruo}, journal={Physics letters A}, volume={150}, number={5-7}, pages={262–268}, year={1990}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.KahanLi6","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.KahanLi6","text":"KahanLi6()\n\nSymplectic Runge-Kutta Methods Optimized efficiency 6th order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{yoshida1990construction, title={Construction of higher order symplectic integrators}, author={Yoshida, Haruo}, journal={Physics letters A}, volume={150}, number={5-7}, pages={262–268}, year={1990}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.McAte8","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.McAte8","text":"McAte8()\n\nSymplectic Runge-Kutta Methods 8th order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{mclachlan1995numerical, title={On the numerical integration of ordinary differential equations by symmetric composition methods}, author={McLachlan, Robert I}, journal={SIAM Journal on Scientific Computing}, volume={16}, number={1}, pages={151–168}, year={1995}, publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.KahanLi8","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.KahanLi8","text":"KahanLi8()\n\nSymplectic Runge-Kutta Methods Optimized efficiency 8th order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{kahan1997composition, title={Composition constants for raising the orders of unconventional schemes for ordinary differential equations}, author={Kahan, William and Li, Ren-Cang}, journal={Mathematics of computation}, volume={66}, number={219}, pages={1089–1099}, year={1997}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/SymplecticRK/#OrdinaryDiffEqSymplecticRK.SofSpa10","page":"OrdinaryDiffEqSymplecticRK","title":"OrdinaryDiffEqSymplecticRK.SofSpa10","text":"SofSpa10()\n\nSymplectic Runge-Kutta Methods 10th order explicit symplectic integrator.\n\nKeyword Arguments\n\nReferences\n\n@article{sofroniou2005derivation, title={Derivation of symmetric composition constants for symmetric integrators}, author={Sofroniou, Mark and Spaletta, Giulia}, journal={Optimization Methods and Software}, volume={20}, number={4-5}, pages={597–613}, year={2005}, publisher={Taylor \\& Francis}}\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/StabilizedRK/#OrdinaryDiffEqStabilizedRK","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK","text":"","category":"section"},{"location":"semiimplicit/StabilizedRK/","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK","text":"Explicit stabilized methods utilize an upper bound on the spectral radius of the Jacobian. Users can supply an upper bound by specifying the keyword argument eigen_est, for example","category":"page"},{"location":"semiimplicit/StabilizedRK/","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK","text":"`eigen_est = (integrator) -> integrator.eigen_est = upper_bound`","category":"page"},{"location":"semiimplicit/StabilizedRK/","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqStabilizedRK\", \"ROCK4\")","category":"page"},{"location":"semiimplicit/StabilizedRK/#Full-list-of-solvers","page":"OrdinaryDiffEqStabilizedRK","title":"Full list of solvers","text":"","category":"section"},{"location":"semiimplicit/StabilizedRK/#OrdinaryDiffEqStabilizedRK.ROCK2","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK.ROCK2","text":"ROCK2(; min_stages = 0,\n        max_stages = 200,\n        eigen_est = nothing)\n\nStabilized Explicit Method. Second order method. Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.\n\nKeyword Arguments\n\nmin_stages: The minimum degree of the Chebyshev polynomial.\nmax_stages: The maximumdegree of the Chebyshev polynomial.\neigen_est: function of the form   (integrator) -> integrator.eigen_est = upper_bound,   where upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.   If eigen_est is not provided, upper_bound will be estimated using the power iteration.\n\nReferences\n\nAssyr Abdulle, Alexei A. Medovikov. Second Order Chebyshev Methods based on Orthogonal Polynomials. Numerische Mathematik, 90 (1), pp 1-18, 2001. doi: https://dx.doi.org/10.1007/s002110100292\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/StabilizedRK/#OrdinaryDiffEqStabilizedRK.ROCK4","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK.ROCK4","text":"ROCK4(; min_stages = 0,\n        max_stages = 152,\n        eigen_est = nothing)\n\nStabilized Explicit Method. Fourth order method. Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.\n\nKeyword Arguments\n\nmin_stages: The minimum degree of the Chebyshev polynomial.\nmax_stages: The maximumdegree of the Chebyshev polynomial.\neigen_est: function of the form   (integrator) -> integrator.eigen_est = upper_bound,   where upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.   If eigen_est is not provided, upper_bound will be estimated using the power iteration.\n\nReferences\n\nAssyr Abdulle. Fourth Order Chebyshev Methods With Recurrence Relation. 2002 Society for Industrial and Applied Mathematics Journal on Scientific Computing, 23(6), pp 2041-2054, 2001. doi: https://doi.org/10.1137/S1064827500379549\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/StabilizedRK/#OrdinaryDiffEqStabilizedRK.RKC","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK.RKC","text":"RKC(; eigen_est = nothing)\n\nStabilized Explicit Method. Second order method. Exhibits high stability for real eigenvalues.\n\nKeyword Arguments\n\neigen_est: function of the form   (integrator) -> integrator.eigen_est = upper_bound,   where upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.   If eigen_est is not provided, upper_bound will be estimated using the power iteration.\n\nReferences\n\nB. P. Sommeijer, L. F. Shampine, J. G. Verwer. RKC: An Explicit Solver for Parabolic PDEs, Journal of Computational and Applied Mathematics, 88(2), pp 315-326, 1998. doi: https://doi.org/10.1016/S0377-0427(97)00219-7\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/StabilizedRK/#OrdinaryDiffEqStabilizedRK.SERK2","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK.SERK2","text":"SERK2(; controller = :PI\n        eigen_est = nothing)\n\nStabilized Explicit Method. Second order method.\n\nKeyword Arguments\n\ncontroller: TBD\neigen_est: function of the form   (integrator) -> integrator.eigen_est = upper_bound,   where upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.   If eigen_est is not provided, upper_bound will be estimated using the power iteration.\n\nReferences\n\n@article{kleefeld2013serk2v2, title={SERK2v2: A new second-order stabilized explicit Runge-Kutta method for stiff problems}, author={Kleefeld, B and Martin-Vaquero, J}, journal={Numerical Methods for Partial Differential Equations}, volume={29}, number={1}, pages={170–185}, year={2013}, publisher={Wiley Online Library}}\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/StabilizedRK/#OrdinaryDiffEqStabilizedRK.ESERK4","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK.ESERK4","text":"ESERK4(; eigen_est = nothing)\n\nStabilized Explicit Method. Fourth order method. Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.\n\nKeyword Arguments\n\neigen_est: function of the form   (integrator) -> integrator.eigen_est = upper_bound,   where upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.   If eigen_est is not provided, upper_bound will be estimated using the power iteration.\n\nReferences\n\nJ. Martín-Vaquero, B. Kleefeld. Extrapolated stabilized explicit Runge-Kutta methods, Journal of Computational Physics, 326, pp 141-155, 2016. doi: https://doi.org/10.1016/j.jcp.2016.08.042.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/StabilizedRK/#OrdinaryDiffEqStabilizedRK.ESERK5","page":"OrdinaryDiffEqStabilizedRK","title":"OrdinaryDiffEqStabilizedRK.ESERK5","text":"ESERK5(; eigen_est = nothing)\n\nStabilized Explicit Method. Fifth order method. Exhibits high stability for real eigenvalues and is smoothened to allow for moderate sized complex eigenvalues.\n\nKeyword Arguments\n\neigen_est: function of the form   (integrator) -> integrator.eigen_est = upper_bound,   where upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.   If eigen_est is not provided, upper_bound will be estimated using the power iteration.\n\nReferences\n\nJ. Martín-Vaquero, A. Kleefeld. ESERK5: A fifth-order extrapolated stabilized explicit Runge-Kutta method, Journal of Computational and Applied Mathematics, 356, pp 22-36, 2019. doi: https://doi.org/10.1016/j.cam.2019.01.040.\n\n\n\n\n\n","category":"type"},{"location":"explicit/PRK/#OrdinaryDiffEqPRK","page":"OrdinaryDiffEqPRK","title":"OrdinaryDiffEqPRK","text":"","category":"section"},{"location":"explicit/PRK/","page":"OrdinaryDiffEqPRK","title":"OrdinaryDiffEqPRK","text":"Explicit solvers optimized for a certain number of parallel calls of the system of ordinary differential equations f.","category":"page"},{"location":"explicit/PRK/","page":"OrdinaryDiffEqPRK","title":"OrdinaryDiffEqPRK","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqPRK\", \"KuttaPRK2p5\")","category":"page"},{"location":"explicit/PRK/#Full-list-of-solvers","page":"OrdinaryDiffEqPRK","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/PRK/#OrdinaryDiffEqPRK.KuttaPRK2p5","page":"OrdinaryDiffEqPRK","title":"OrdinaryDiffEqPRK.KuttaPRK2p5","text":"KuttaPRK2p5(; thread = OrdinaryDiffEq.True())\n\nExplicit Runge-Kutta Method A 5 parallel, 2 processor method of 5th order.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{jackson1995potential, title={The potential for parallelism in Runge–Kutta methods. Part 1: RK formulas in standard form}, author={Jackson, Kenneth R and Norsett, Syvert Paul}, journal={SIAM journal on numerical analysis}, volume={32}, number={1}, pages={49–82}, year={1995}, publisher={SIAM}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/Tsit5/#OrdinaryDiffEqTsit5","page":"OrdinaryDiffEqTsit5","title":"OrdinaryDiffEqTsit5","text":"","category":"section"},{"location":"explicit/Tsit5/","page":"OrdinaryDiffEqTsit5","title":"OrdinaryDiffEqTsit5","text":"Recommended solver for most non-stiff problems at default and higher tolerance.","category":"page"},{"location":"explicit/Tsit5/","page":"OrdinaryDiffEqTsit5","title":"OrdinaryDiffEqTsit5","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqTsit5\", \"Tsit5\")","category":"page"},{"location":"explicit/Tsit5/#Full-list-of-solvers","page":"OrdinaryDiffEqTsit5","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/Tsit5/#OrdinaryDiffEqTsit5.Tsit5","page":"OrdinaryDiffEqTsit5","title":"OrdinaryDiffEqTsit5.Tsit5","text":"Tsit5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A fifth-order explicit Runge-Kutta method with embedded error     estimator of Tsitouras. Free 4th order interpolant.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{tsitouras2011runge,     title={Runge–Kutta pairs of order 5 (4) satisfying only the first column simplifying assumption},     author={Tsitouras, Ch},     journal={Computers \\& Mathematics with Applications},     volume={62},     number={2},     pages={770–775},     year={2011},     publisher={Elsevier}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/Tsit5/#OrdinaryDiffEqTsit5.AutoTsit5","page":"OrdinaryDiffEqTsit5","title":"OrdinaryDiffEqTsit5.AutoTsit5","text":"Automatic switching algorithm that can switch between the (non-stiff) Tsit5() and stiff_alg.\n\nAutoTsit5(stiff_alg; kwargs...)\n\nThis method is equivalent to AutoAlgSwitch(Tsit5(), stiff_alg; kwargs...). To gain access to stiff algorithms you might have to install additional libraries, such as OrdinaryDiffEqRosenbrock.\n\n\n\n\n\n","category":"function"},{"location":"implicit/Nordsieck/#OrdinaryDiffEqNordsieck","page":"OrdinaryDiffEqNordsieck","title":"OrdinaryDiffEqNordsieck","text":"","category":"section"},{"location":"implicit/Nordsieck/","page":"OrdinaryDiffEqNordsieck","title":"OrdinaryDiffEqNordsieck","text":"The Nordsieck form is an alternative representation of multistep methods which, instead of representing and saving past step values in a history vector, it uses a derivative list (like a Taylor expansion) for the computation of the next point. The Nordsieck form was pioneered by early implementations of BDF methods such LSODE, VODE, and finally CVODE. It can have some advantages in terms of restartability as the full Nordsieck vector can be instantiated given only the information of f and its derivatives after discontinuities, but the higher derivative representations can also introduce numerical instabilities of their own.","category":"page"},{"location":"implicit/Nordsieck/","page":"OrdinaryDiffEqNordsieck","title":"OrdinaryDiffEqNordsieck","text":"The Nordsieck implementations here are considered experimental implementations of the LSODE non-fixed leading coefficient form and are generally considered inferior to the fixed-leading history-based BDF implementation of FBDF, and thus for all standard usage we recommend FBDF. However, this algorithm is kept for experimental research and development purposes with the possibility of one day becoming a more discontinuity-aware BDF implementation.","category":"page"},{"location":"implicit/Nordsieck/","page":"OrdinaryDiffEqNordsieck","title":"OrdinaryDiffEqNordsieck","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqNordsieck\", \"AN5\")","category":"page"},{"location":"implicit/Nordsieck/#Full-list-of-solvers","page":"OrdinaryDiffEqNordsieck","title":"Full list of solvers","text":"","category":"section"},{"location":"implicit/Nordsieck/#OrdinaryDiffEqNordsieck.AN5","page":"OrdinaryDiffEqNordsieck","title":"OrdinaryDiffEqNordsieck.AN5","text":"AN5()\n\nAdaptive step size Adams explicit Method An adaptive 5th order fixed-leading coefficient Adams method in Nordsieck form.\n\nwarning: Experimental\nAN5 is experimental, the solver VCABM is generally preferred.\n\nKeyword Arguments\n\nReferences\n\n\n\n\n\n","category":"type"},{"location":"implicit/Nordsieck/#OrdinaryDiffEqNordsieck.JVODE","page":"OrdinaryDiffEqNordsieck","title":"OrdinaryDiffEqNordsieck.JVODE","text":"warning: Experimental\nJVODE is experimental, the solver VCABM is generally preferred.\n\n\n\n\n\n","category":"type"},{"location":"implicit/Nordsieck/#OrdinaryDiffEqNordsieck.JVODE_Adams","page":"OrdinaryDiffEqNordsieck","title":"OrdinaryDiffEqNordsieck.JVODE_Adams","text":"warning: Experimental\nJVODE is experimental, the solver VCABM is generally preferred.\n\n\n\n\n\n","category":"function"},{"location":"implicit/Nordsieck/#OrdinaryDiffEqNordsieck.JVODE_BDF","page":"OrdinaryDiffEqNordsieck","title":"OrdinaryDiffEqNordsieck.JVODE_BDF","text":"warning: Experimental\nJVODE is experimental, the solver FBDF is generally preferred.\n\n\n\n\n\n","category":"function"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"","category":"section"},{"location":"massmatrixdae/BDF/","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"Multistep BDF methods, good for large stiff systems.","category":"page"},{"location":"massmatrixdae/BDF/","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"using LinearAlgebra: Diagonal\nfunction rober(du, u, p, t)\n    y₁, y₂, y₃ = u\n    k₁, k₂, k₃ = p\n    du[1] = -k₁ * y₁ + k₃ * y₂ * y₃\n    du[2] = k₁ * y₁ - k₃ * y₂ * y₃ - k₂ * y₂^2\n    du[3] = y₁ + y₂ + y₃ - 1\n    nothing\nend\nM = Diagonal([1.0, 1.0, 0])\nf = ODEFunction(rober, mass_matrix = M)\nprob_mm = ODEProblem(f, [1.0, 0.0, 0.0], (0.0, 1e5), (0.04, 3e7, 1e4))\nsol = solve(prob_mm, FBDF(), reltol = 1e-8, abstol = 1e-8)","category":"page"},{"location":"massmatrixdae/BDF/#Full-list-of-solvers","page":"OrdinaryDiffEqBDF","title":"Full list of solvers","text":"","category":"section"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.ABDF2-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.ABDF2","text":"ABDF2(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        κ = nothing,\n        tol = nothing,\n        nlsolve = NLNewton(),\n        smooth_est = true,\n        extrapolant = :linear,\n        controller = :Standard,\n        step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order 2 L-stable fixed leading coefficient multistep BDF method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ABDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- κ: TBD\ntol: TBD\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nE. Alberdi Celayaa, J. J. Anza Aguirrezabalab, P. Chatzipantelidisc. Implementation of an Adaptive BDF2 Formula and Comparison with The MATLAB Ode15s. Procedia Computer Science, 29, pp 1014-1026, 2014. doi: https://doi.org/10.1016/j.procs.2014.05.091\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.QNDF-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QNDF","text":"QNDF(; chunk_size = Val{0}(),\n       autodiff = AutoForwardDiff(),\n       standardtag = Val{true}(),\n       concrete_jac = nothing,\n       linsolve = nothing,\n       precs = DEFAULT_PRECS,\n       κ = nothing,\n       tol = nothing,\n       nlsolve = NLNewton(),\n       extrapolant = :linear,\n       kappa =  promote(-0.1850, -1 // 9, -0.0823, -0.0415, 0),\n       controller = :Standard,\n       step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order quasi-constant timestep NDF method. Utilizes Shampine's accuracy-optimal kappa values as defaults (has a keyword argument for a tuple of kappa coefficients).\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify QNDF(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- κ: TBD\ntol: TBD\nnlsolve: TBD\nextrapolant: TBD\nkappa: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{shampine1997matlab, title={The matlab ode suite}, author={Shampine, Lawrence F and Reichelt, Mark W}, journal={SIAM journal on scientific computing}, volume={18}, number={1}, pages={1–22}, year={1997}, publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.QNDF1-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QNDF1","text":"QNDF1(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        nlsolve = NLNewton(),\n        extrapolant = :linear,\n        kappa = -0.1850,\n        controller = :Standard,\n        step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order 1 quasi-constant timestep L-stable numerical differentiation function (NDF) method. Optional parameter kappa defaults to Shampine's accuracy-optimal -0.1850.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify QNDF1(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\nkappa: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{shampine1997matlab, title={The matlab ode suite}, author={Shampine, Lawrence F and Reichelt, Mark W}, journal={SIAM journal on scientific computing}, volume={18}, number={1}, pages={1–22}, year={1997}, publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.QNDF2-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QNDF2","text":"QNDF2(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        nlsolve = NLNewton(),\n        extrapolant = :linear,\n        kappa =  -1 // 9,\n        controller = :Standard,\n        step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order 2 quasi-constant timestep L-stable numerical differentiation function (NDF) method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify QNDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\nkappa: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{shampine1997matlab, title={The matlab ode suite}, author={Shampine, Lawrence F and Reichelt, Mark W}, journal={SIAM journal on scientific computing}, volume={18}, number={1}, pages={1–22}, year={1997}, publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.QBDF-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QBDF","text":"QBDF: Multistep Method\n\nAn alias of QNDF with κ=0.\n\n\n\n\n\n","category":"function"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.QBDF1-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QBDF1","text":"QBDF1: Multistep Method\n\nAn alias of QNDF1 with κ=0.\n\n\n\n\n\n","category":"function"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.QBDF2-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QBDF2","text":"QBDF2: Multistep Method\n\nAn alias of QNDF2 with κ=0.\n\n\n\n\n\n","category":"function"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.MEBDF2-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.MEBDF2","text":"MEBDF2(; chunk_size = Val{0}(),\n         autodiff = AutoForwardDiff(),\n         standardtag = Val{true}(),\n         concrete_jac = nothing,\n         linsolve = nothing,\n         precs = DEFAULT_PRECS,\n         nlsolve = NLNewton(),\n         extrapolant = :constant)\n\nMultistep Method. The second order Modified Extended BDF method,     which has improved stability properties over the standard BDF.     Fixed timestep only.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify MEBDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{cash2000modified, title={Modified extended backward differentiation formulae for the numerical solution of stiff initial value problems in ODEs and DAEs}, author={Cash, JR}, journal={Journal of Computational and Applied Mathematics}, volume={125}, number={1-2}, pages={117–130}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/BDF/#OrdinaryDiffEqBDF.FBDF-massmatrixdae-BDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.FBDF","text":"FBDF(; chunk_size = Val{0}(),\n       autodiff = AutoForwardDiff(),\n       standardtag = Val{true}(),\n       concrete_jac = nothing,\n       linsolve = nothing,\n       precs = DEFAULT_PRECS,\n       κ = nothing,\n       tol = nothing,\n       nlsolve = NLNewton(),\n       extrapolant = :linear,\n       controller = :Standard,\n       step_limiter! = trivial_limiter!,\n       max_order::Val{MO} = Val{5}())\n\nMultistep Method. An adaptive order quasi-constant timestep NDF method. Fixed leading coefficient BDF. Utilizes Shampine's accuracy-optimal kappa values as defaults (has a keyword argument for a tuple of kappa coefficients).\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify FBDF(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- κ: TBD\ntol: TBD\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nmax_order: TBD\n\nReferences\n\n@article{shampine2002solving, title={Solving 0= F (t, y (t), y′(t)) in Matlab}, author={Shampine, Lawrence F}, year={2002}, publisher={Walter de Gruyter GmbH \\& Co. KG}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"","category":"section"},{"location":"implicit/BDF/","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"Multistep methods, good for large stiff systems.","category":"page"},{"location":"implicit/BDF/","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqBDF\", \"QNDF\")","category":"page"},{"location":"implicit/BDF/#Full-list-of-solvers","page":"OrdinaryDiffEqBDF","title":"Full list of solvers","text":"","category":"section"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.ABDF2","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.ABDF2","text":"ABDF2(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        κ = nothing,\n        tol = nothing,\n        nlsolve = NLNewton(),\n        smooth_est = true,\n        extrapolant = :linear,\n        controller = :Standard,\n        step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order 2 L-stable fixed leading coefficient multistep BDF method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ABDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- κ: TBD\ntol: TBD\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nE. Alberdi Celayaa, J. J. Anza Aguirrezabalab, P. Chatzipantelidisc. Implementation of an Adaptive BDF2 Formula and Comparison with The MATLAB Ode15s. Procedia Computer Science, 29, pp 1014-1026, 2014. doi: https://doi.org/10.1016/j.procs.2014.05.091\n\n\n\n\n\n","category":"type"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.QNDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QNDF","text":"QNDF(; chunk_size = Val{0}(),\n       autodiff = AutoForwardDiff(),\n       standardtag = Val{true}(),\n       concrete_jac = nothing,\n       linsolve = nothing,\n       precs = DEFAULT_PRECS,\n       κ = nothing,\n       tol = nothing,\n       nlsolve = NLNewton(),\n       extrapolant = :linear,\n       kappa =  promote(-0.1850, -1 // 9, -0.0823, -0.0415, 0),\n       controller = :Standard,\n       step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order quasi-constant timestep NDF method. Utilizes Shampine's accuracy-optimal kappa values as defaults (has a keyword argument for a tuple of kappa coefficients).\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify QNDF(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- κ: TBD\ntol: TBD\nnlsolve: TBD\nextrapolant: TBD\nkappa: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{shampine1997matlab, title={The matlab ode suite}, author={Shampine, Lawrence F and Reichelt, Mark W}, journal={SIAM journal on scientific computing}, volume={18}, number={1}, pages={1–22}, year={1997}, publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.QNDF1","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QNDF1","text":"QNDF1(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        nlsolve = NLNewton(),\n        extrapolant = :linear,\n        kappa = -0.1850,\n        controller = :Standard,\n        step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order 1 quasi-constant timestep L-stable numerical differentiation function (NDF) method. Optional parameter kappa defaults to Shampine's accuracy-optimal -0.1850.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify QNDF1(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\nkappa: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{shampine1997matlab, title={The matlab ode suite}, author={Shampine, Lawrence F and Reichelt, Mark W}, journal={SIAM journal on scientific computing}, volume={18}, number={1}, pages={1–22}, year={1997}, publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.QNDF2","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QNDF2","text":"QNDF2(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        nlsolve = NLNewton(),\n        extrapolant = :linear,\n        kappa =  -1 // 9,\n        controller = :Standard,\n        step_limiter! = trivial_limiter!)\n\nMultistep Method. An adaptive order 2 quasi-constant timestep L-stable numerical differentiation function (NDF) method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify QNDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\nkappa: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{shampine1997matlab, title={The matlab ode suite}, author={Shampine, Lawrence F and Reichelt, Mark W}, journal={SIAM journal on scientific computing}, volume={18}, number={1}, pages={1–22}, year={1997}, publisher={SIAM} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.QBDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QBDF","text":"QBDF: Multistep Method\n\nAn alias of QNDF with κ=0.\n\n\n\n\n\n","category":"function"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.QBDF1","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QBDF1","text":"QBDF1: Multistep Method\n\nAn alias of QNDF1 with κ=0.\n\n\n\n\n\n","category":"function"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.QBDF2","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.QBDF2","text":"QBDF2: Multistep Method\n\nAn alias of QNDF2 with κ=0.\n\n\n\n\n\n","category":"function"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.MEBDF2","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.MEBDF2","text":"MEBDF2(; chunk_size = Val{0}(),\n         autodiff = AutoForwardDiff(),\n         standardtag = Val{true}(),\n         concrete_jac = nothing,\n         linsolve = nothing,\n         precs = DEFAULT_PRECS,\n         nlsolve = NLNewton(),\n         extrapolant = :constant)\n\nMultistep Method. The second order Modified Extended BDF method,     which has improved stability properties over the standard BDF.     Fixed timestep only.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify MEBDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{cash2000modified, title={Modified extended backward differentiation formulae for the numerical solution of stiff initial value problems in ODEs and DAEs}, author={Cash, JR}, journal={Journal of Computational and Applied Mathematics}, volume={125}, number={1-2}, pages={117–130}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/BDF/#OrdinaryDiffEqBDF.FBDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.FBDF","text":"FBDF(; chunk_size = Val{0}(),\n       autodiff = AutoForwardDiff(),\n       standardtag = Val{true}(),\n       concrete_jac = nothing,\n       linsolve = nothing,\n       precs = DEFAULT_PRECS,\n       κ = nothing,\n       tol = nothing,\n       nlsolve = NLNewton(),\n       extrapolant = :linear,\n       controller = :Standard,\n       step_limiter! = trivial_limiter!,\n       max_order::Val{MO} = Val{5}())\n\nMultistep Method. An adaptive order quasi-constant timestep NDF method. Fixed leading coefficient BDF. Utilizes Shampine's accuracy-optimal kappa values as defaults (has a keyword argument for a tuple of kappa coefficients).\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify FBDF(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- κ: TBD\ntol: TBD\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nmax_order: TBD\n\nReferences\n\n@article{shampine2002solving, title={Solving 0= F (t, y (t), y′(t)) in Matlab}, author={Shampine, Lawrence F}, year={2002}, publisher={Walter de Gruyter GmbH \\& Co. KG}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/HighOrderRK/#OrdinaryDiffEqHighOrderRK","page":"OrdinaryDiffEqHighOrderRK","title":"OrdinaryDiffEqHighOrderRK","text":"","category":"section"},{"location":"explicit/HighOrderRK/","page":"OrdinaryDiffEqHighOrderRK","title":"OrdinaryDiffEqHighOrderRK","text":"Solvers for non-stiff problems at low tolerance. However, the solvers in OrdinaryDiffEqVerner generally perform better at low tolerances.","category":"page"},{"location":"explicit/HighOrderRK/","page":"OrdinaryDiffEqHighOrderRK","title":"OrdinaryDiffEqHighOrderRK","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqHighOrderRK\", \"DP8\")","category":"page"},{"location":"explicit/HighOrderRK/#Full-list-of-solvers","page":"OrdinaryDiffEqHighOrderRK","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/HighOrderRK/#OrdinaryDiffEqHighOrderRK.TanYam7","page":"OrdinaryDiffEqHighOrderRK","title":"OrdinaryDiffEqHighOrderRK.TanYam7","text":"TanYam7(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Tanaka-Yamashita 7 Runge-Kutta method. (7th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nTanaka M., Muramatsu S., Yamashita S., (1992), On the Optimization of Some Nine-Stage     Seventh-order Runge-Kutta Method, Information Processing Society of Japan,     33 (12), pp. 1512-1526.\n\n\n\n\n\n","category":"type"},{"location":"explicit/HighOrderRK/#OrdinaryDiffEqHighOrderRK.TsitPap8","page":"OrdinaryDiffEqHighOrderRK","title":"OrdinaryDiffEqHighOrderRK.TsitPap8","text":"TsitPap8(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Tsitouras-Papakostas 8/7 Runge-Kutta method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{tsitouras1999cheap, title={Cheap error estimation for Runge–Kutta methods}, author={Tsitouras, Ch and Papakostas, SN}, journal={SIAM Journal on Scientific Computing}, volume={20}, number={6}, pages={2067–2088}, year={1999}, publisher={SIAM}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/HighOrderRK/#OrdinaryDiffEqHighOrderRK.DP8","page":"OrdinaryDiffEqHighOrderRK","title":"OrdinaryDiffEqHighOrderRK.DP8","text":"DP8(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Hairer's 8/5/3 adaption of the Dormand-Prince Runge-Kutta method. (7th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I.     Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics,     Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"explicit/HighOrderRK/#OrdinaryDiffEqHighOrderRK.PFRK87","page":"OrdinaryDiffEqHighOrderRK","title":"OrdinaryDiffEqHighOrderRK.PFRK87","text":"PFRK87(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False(),\n         omega = 0.0)\n\nExplicit Runge-Kutta Method.  Phase-fitted Runge-Kutta of 8th order.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nomega: a periodicity phase estimate,              when accurate this method results in zero numerical dissipation.\n\nReferences\n\n@article{tsitouras2017phase, title={Phase-fitted Runge–Kutta pairs of orders 8 (7)}, author={Tsitouras, Ch and Famelis, I Th and Simos, TE}, journal={Journal of Computational and Applied Mathematics}, volume={321}, pages={226–231}, year={2017}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK","text":"","category":"section"},{"location":"implicit/SDIRK/","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK","text":"This article is a stub.","category":"page"},{"location":"implicit/SDIRK/","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqSDIRK\", \"PDIRK44\")","category":"page"},{"location":"implicit/SDIRK/#Full-list-of-solvers","page":"OrdinaryDiffEqSDIRK","title":"Full list of solvers","text":"","category":"section"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.ImplicitEuler","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.ImplicitEuler","text":"ImplicitEuler(; chunk_size = Val{0}(),\n                autodiff = AutoForwardDiff(),\n                standardtag = Val{true}(),\n                concrete_jac = nothing,\n                diff_type = Val{:forward}(),\n                linsolve = nothing,\n                precs = DEFAULT_PRECS,\n                nlsolve = NLNewton(),\n                extrapolant = :constant,\n                controller = :PI,\n                step_limiter! = trivial_limiter!)\n\nSDIRK Method. A 1st order implicit solver. A-B-L-stable.     Adaptive timestepping through a divided differences estimate via memory.     Strong-stability preserving (SSP).\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ImplicitEuler(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@book{wanner1996solving,     title={Solving ordinary differential equations II},     author={Wanner, Gerhard and Hairer, Ernst},     volume={375},     year={1996},     publisher={Springer Berlin Heidelberg New York}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.ImplicitMidpoint","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.ImplicitMidpoint","text":"ImplicitMidpoint(; chunk_size = Val{0}(),\n                   autodiff = AutoForwardDiff(),\n                   standardtag = Val{true}(),\n                   concrete_jac = nothing,\n                   diff_type = Val{:forward}(),\n                   linsolve = nothing,\n                   precs = DEFAULT_PRECS,\n                   nlsolve = NLNewton(),\n                   extrapolant = :linear,\n                   step_limiter! = trivial_limiter!)\n\nSDIRK Method. A second order A-stable symplectic and symmetric implicit solver.     Good for highly stiff equations which need symplectic integration.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ImplicitMidpoint(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@book{wanner1996solving,     title={Solving ordinary differential equations II},     author={Wanner, Gerhard and Hairer, Ernst},     volume={375},     year={1996},     publisher={Springer Berlin Heidelberg New York}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.Trapezoid","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.Trapezoid","text":"Trapezoid(; chunk_size = Val{0}(),\n            autodiff = AutoForwardDiff(),\n            standardtag = Val{true}(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS,\n            nlsolve = NLNewton(),\n            extrapolant = :linear,\n            controller = :PI,\n            step_limiter! = trivial_limiter!)\n\nSDIRK Method. Second order A-stable symmetric ESDIRK method. \"Almost symplectic\" without numerical dampening. Also known as Crank-Nicolson when applied to PDEs. Adaptive timestepping via divided differences approximation to the second derivative terms in the local truncation error estimate (the SPICE approximation strategy).\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Trapezoid(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nAndre Vladimirescu. 1994. The Spice Book. John Wiley & Sons, Inc., New York, NY, USA.\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.TRBDF2","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.TRBDF2","text":"TRBDF2(; chunk_size = Val{0}(),\n         autodiff = AutoForwardDiff(),\n         standardtag = Val{true}(),\n         concrete_jac = nothing,\n         diff_type = Val{:forward}(),\n         linsolve = nothing,\n         precs = DEFAULT_PRECS,\n         nlsolve = NLNewton(),\n         smooth_est = true,\n         extrapolant = :linear,\n         controller = :PI,\n         step_limiter! = trivial_limiter!)\n\nSDIRK Method. A second order A-B-L-S-stable one-step ESDIRK method.     Includes stiffness-robust error estimates for accurate adaptive timestepping,     smoothed derivatives for highly stiff and oscillatory problems.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify TRBDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{hosea1996analysis,     title={Analysis and implementation of TR-BDF2},     author={Hosea, ME and Shampine, LF},     journal={Applied Numerical Mathematics},     volume={20},     number={1-2},     pages={21–37},     year={1996},     publisher={Elsevier}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SDIRK2","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SDIRK2","text":"SDIRK2(; chunk_size = Val{0}(),\n         autodiff = AutoForwardDiff(),\n         standardtag = Val{true}(),\n         concrete_jac = nothing,\n         diff_type = Val{:forward}(),\n         linsolve = nothing,\n         precs = DEFAULT_PRECS,\n         nlsolve = NLNewton(),\n         smooth_est = true,\n         extrapolant = :linear,\n         controller = :PI,\n         step_limiter! = trivial_limiter!)\n\nSDIRK Method. SDIRK2: SDIRK Method An A-B-L stable 2nd order SDIRK method\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SDIRK2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{hindmarsh2005sundials,     title={{SUNDIALS}: Suite of nonlinear and differential/algebraic equation solvers},     author={Hindmarsh, Alan C and Brown, Peter N and Grant, Keith E and Lee, Steven L and Serban, Radu and Shumaker, Dan E and Woodward, Carol S},     journal={ACM Transactions on Mathematical Software (TOMS)},     volume={31},     number={3},     pages={363–396},     year={2005},     publisher={ACM}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SDIRK22","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SDIRK22","text":"SDIRK22(; chunk_size = Val{0}(),\n          autodiff = AutoForwardDiff(),\n          standardtag = Val{true}(),\n          concrete_jac = nothing,\n          diff_type = Val{:forward}(),\n          linsolve = nothing,\n          precs = DEFAULT_PRECS,\n          nlsolve = NLNewton(),\n          smooth_est = true,\n          extrapolant = :linear,\n          controller = :PI,\n          step_limiter! = trivial_limiter!)\n\nSDIRK Method. Description TBD\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SDIRK22(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@techreport{kennedy2016diagonally,     title={Diagonally implicit Runge-Kutta methods for ordinary differential equations. A review},     author={Kennedy, Christopher A and Carpenter, Mark H},     year={2016}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SSPSDIRK2","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SSPSDIRK2","text":"SSPSDIRK2(; chunk_size = Val{0}(),\n            autodiff = AutoForwardDiff(),\n            standardtag = Val{true}(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS,\n            nlsolve = NLNewton(),\n            smooth_est = true,\n            extrapolant = :constant,\n            controller = :PI)\n\nSDIRK Method. SSPSDIRK is an SSP-optimized SDIRK method, so it's an implicit SDIRK method for handling stiffness but if the dt is below the SSP coefficient * dt, then the SSP property of the SSP integrators (the other page) is satisified. As such this is a method which is expected to be good on advection-dominated cases where an explicit SSP integrator would be used, but where reaction equations are sufficient stiff to justify implicit integration.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SSPSDIRK2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{ketcheson2009optimal,     title={Optimal implicit strong stability preserving Runge–Kutta methods},     author={Ketcheson, David I and Macdonald, Colin B and Gottlieb, Sigal},     journal={Applied Numerical Mathematics},     volume={59},     number={2},     pages={373–392},     year={2009},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.Kvaerno3","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.Kvaerno3","text":"Kvaerno3(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           smooth_est = true,\n           extrapolant = :linear,\n           controller = :PI,\n           step_limiter! = trivial_limiter!)\n\nSDIRK Method. An A-L stable stiffly-accurate 3rd order ESDIRK method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Kvaerno3(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{kvaerno2004singly,     title={Singly diagonally implicit Runge–Kutta methods with an explicit first stage},     author={Kv{\\ae}rn{\\o}, Anne},     journal={BIT Numerical Mathematics},     volume={44},     number={3},     pages={489–502},     year={2004},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.KenCarp3","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.KenCarp3","text":"KenCarp3(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           smooth_est = true,\n           extrapolant = :linear,\n           controller = :PI,\n           step_limiter! = trivial_limiter!)\n\nSDIRK Method. An A-L stable stiffly-accurate 3rd order ESDIRK method with splitting.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify KenCarp3(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@book{kennedy2001additive,     title={Additive Runge-Kutta schemes for convection-diffusion-reaction equations},     author={Kennedy, Christopher Alan},     year={2001},     publisher={National Aeronautics and Space Administration, Langley Research Center}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.CFNLIRK3","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.CFNLIRK3","text":"CFNLIRK3(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           extrapolant = :linear)\n\nSDIRK Method. Third order method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify CFNLIRK3(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{calvo2001linearly,     title={Linearly implicit Runge–Kutta methods for advection–reaction–diffusion equations},     author={Calvo, MP and De Frutos, J and Novo, J},     journal={Applied Numerical Mathematics},     volume={37},     number={4},     pages={535–549},     year={2001},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.Cash4","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.Cash4","text":"Cash4(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        diff_type = Val{:forward}(),\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        nlsolve = NLNewton(),\n        smooth_est = true,\n        extrapolant = :linear,\n        controller = :PI,\n        embedding = 3)\n\nSDIRK Method. An A-L stable 4th order SDIRK method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Cash4(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nembedding: TBD\n\nReferences\n\n@article{hindmarsh2005sundials,     title={{SUNDIALS}: Suite of nonlinear and differential/algebraic equation solvers},     author={Hindmarsh, Alan C and Brown, Peter N and Grant, Keith E and Lee, Steven L and Serban, Radu and Shumaker, Dan E and Woodward, Carol S},     journal={ACM Transactions on Mathematical Software (TOMS)},     volume={31},     number={3},     pages={363–396},     year={2005},     publisher={ACM}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SFSDIRK4","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SFSDIRK4","text":"SFSDIRK4(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           extrapolant = :linear)\n\nSDIRK Method. Method of order 4.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SFSDIRK4(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{ferracina2008strong,     title={Strong stability of singly-diagonally-implicit Runge–Kutta methods},     author={Ferracina, Luca and Spijker, MN},     journal={Applied Numerical Mathematics},     volume={58},     number={11},     pages={1675–1686},     year={2008},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SFSDIRK5","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SFSDIRK5","text":"SFSDIRK5(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           extrapolant = :linear)\n\nSDIRK Method. Method of order 5.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SFSDIRK5(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{ferracina2008strong,     title={Strong stability of singly-diagonally-implicit Runge–Kutta methods},     author={Ferracina, Luca and Spijker, MN},     journal={Applied Numerical Mathematics},     volume={58},     number={11},     pages={1675–1686},     year={2008},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SFSDIRK6","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SFSDIRK6","text":"SFSDIRK6(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           extrapolant = :linear)\n\nSDIRK Method. Method of order 6.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SFSDIRK6(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{ferracina2008strong,     title={Strong stability of singly-diagonally-implicit Runge–Kutta methods},     author={Ferracina, Luca and Spijker, MN},     journal={Applied Numerical Mathematics},     volume={58},     number={11},     pages={1675–1686},     year={2008},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SFSDIRK7","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SFSDIRK7","text":"SFSDIRK7(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           extrapolant = :linear)\n\nSDIRK Method. Method of order 7.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SFSDIRK7(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{ferracina2008strong,     title={Strong stability of singly-diagonally-implicit Runge–Kutta methods},     author={Ferracina, Luca and Spijker, MN},     journal={Applied Numerical Mathematics},     volume={58},     number={11},     pages={1675–1686},     year={2008},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.SFSDIRK8","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.SFSDIRK8","text":"SFSDIRK8(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           extrapolant = :linear)\n\nSDIRK Method. Method of order 8.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify SFSDIRK8(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\n\nReferences\n\n@article{ferracina2008strong,     title={Strong stability of singly-diagonally-implicit Runge–Kutta methods},     author={Ferracina, Luca and Spijker, MN},     journal={Applied Numerical Mathematics},     volume={58},     number={11},     pages={1675–1686},     year={2008},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.Hairer4","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.Hairer4","text":"Hairer4(; chunk_size = Val{0}(),\n          autodiff = AutoForwardDiff(),\n          standardtag = Val{true}(),\n          concrete_jac = nothing,\n          diff_type = Val{:forward}(),\n          linsolve = nothing,\n          precs = DEFAULT_PRECS,\n          nlsolve = NLNewton(),\n          smooth_est = true,\n          extrapolant = :linear,\n          controller = :PI)\n\nSDIRK Method. An A-L stable 4th order SDIRK method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Hairer4(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and     differential-algebraic problems. Computational mathematics (2nd revised ed.),     Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.Hairer42","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.Hairer42","text":"Hairer42(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           smooth_est = true,\n           extrapolant = :linear,\n           controller = :PI)\n\nSDIRK Method. An A-L stable 4th order SDIRK method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Hairer42(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and     differential-algebraic problems. Computational mathematics (2nd revised ed.),     Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.Kvaerno4","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.Kvaerno4","text":"Kvaerno4(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           smooth_est = true,\n           extrapolant = :linear,\n           controller = :PI,\n           step_limiter! = trivial_limiter!)\n\nSDIRK Method. An A-L stable stiffly-accurate 4th order ESDIRK method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Kvaerno4(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter: TBD\n\nReferences\n\n@article{kvaerno2004singly,     title={Singly diagonally implicit Runge–Kutta methods with an explicit first stage},     author={Kv{\\ae}rn{\\o}, Anne},     journal={BIT Numerical Mathematics},     volume={44},     number={3},     pages={489–502},     year={2004},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.Kvaerno5","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.Kvaerno5","text":"Kvaerno5(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           smooth_est = true,\n           extrapolant = :linear,\n           controller = :PI,\n           step_limiter! = trivial_limiter!)\n\nSDIRK Method. An A-L stable stiffly-accurate 5th order ESDIRK method.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Kvaerno5(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter: TBD\n\nReferences\n\n@article{kvaerno2004singly,     title={Singly diagonally implicit Runge–Kutta methods with an explicit first stage},     author={Kv{\\ae}rn{\\o}, Anne},     journal={BIT Numerical Mathematics},     volume={44},     number={3},     pages={489–502},     year={2004},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#IMEX-SDIRK","page":"OrdinaryDiffEqSDIRK","title":"IMEX SDIRK","text":"","category":"section"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.KenCarp4","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.KenCarp4","text":"KenCarp4(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           smooth_est = true,\n           extrapolant = :linear,\n           controller = :PI,\n           step_limiter! = trivial_limiter!)\n\nSDIRK Method. An A-L stable stiffly-accurate 4th order ESDIRK method with splitting.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify KenCarp4(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter: TBD\n\nReferences\n\n@book{kennedy2001additive,     title={Additive Runge-Kutta schemes for convection-diffusion-reaction equations},     author={Kennedy, Christopher Alan},     year={2001},     publisher={National Aeronautics and Space Administration, Langley Research Center}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.KenCarp47","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.KenCarp47","text":"KenCarp47(; chunk_size = Val{0}(),\n            autodiff = AutoForwardDiff(),\n            standardtag = Val{true}(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS,\n            nlsolve = NLNewton(),\n            smooth_est = true,\n            extrapolant = :linear,\n            controller = :PI)\n\nSDIRK Method. An A-L stable stiffly-accurate 4th order seven-stage ESDIRK method with splitting.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify KenCarp47(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{kennedy2019higher,     title={Higher-order additive Runge–Kutta schemes for ordinary differential equations},     author={Kennedy, Christopher A and Carpenter, Mark H},     journal={Applied Numerical Mathematics},     volume={136},     pages={183–205},     year={2019},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.KenCarp5","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.KenCarp5","text":"KenCarp5(; chunk_size = Val{0}(),\n           autodiff = AutoForwardDiff(),\n           standardtag = Val{true}(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           nlsolve = NLNewton(),\n           smooth_est = true,\n           extrapolant = :linear,\n           controller = :PI,\n           step_limiter! = trivial_limiter!)\n\nSDIRK Method. An A-L stable stiffly-accurate 5th order ESDIRK method with splitting.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify KenCarp5(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\nstep_limiter: TBD\n\nReferences\n\n@book{kennedy2001additive,     title={Additive Runge-Kutta schemes for convection-diffusion-reaction equations},     author={Kennedy, Christopher Alan},     year={2001},     publisher={National Aeronautics and Space Administration, Langley Research Center}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.KenCarp58","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.KenCarp58","text":"KenCarp58(; chunk_size = Val{0}(),\n            autodiff = AutoForwardDiff(),\n            standardtag = Val{true}(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS,\n            nlsolve = NLNewton(),\n            smooth_est = true,\n            extrapolant = :linear,\n            controller = :PI)\n\nSDIRK Method. An A-L stable stiffly-accurate 5th order eight-stage ESDIRK method with splitting.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify KenCarp58(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nsmooth_est: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{kennedy2019higher,     title={Higher-order additive Runge–Kutta schemes for ordinary differential equations},     author={Kennedy, Christopher A and Carpenter, Mark H},     journal={Applied Numerical Mathematics},     volume={136},     pages={183–205},     year={2019},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.ESDIRK54I8L2SA","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.ESDIRK54I8L2SA","text":"ESDIRK54I8L2SA(; chunk_size = Val{0}(),\n                 autodiff = AutoForwardDiff(),\n                 standardtag = Val{true}(),\n                 concrete_jac = nothing,\n                 diff_type = Val{:forward}(),\n                 linsolve = nothing,\n                 precs = DEFAULT_PRECS,\n                 nlsolve = NLNewton(),\n                 extrapolant = :linear,\n                 controller = :PI)\n\nSDIRK Method. Optimized ESDIRK tableaus. Updates of the original KenCarp tableau expected to achieve lower error for the same steps in theory, but are still being fully evaluated in context.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ESDIRK54I8L2SA(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{Kennedy2019DiagonallyIR, title={Diagonally implicit Runge–Kutta methods for stiff ODEs}, author={Christopher A. Kennedy and Mark H. Carpenter}, journal={Applied Numerical Mathematics}, year={2019}, volume={146}, pages={221-244} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.ESDIRK436L2SA2","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.ESDIRK436L2SA2","text":"ESDIRK436L2SA2(; chunk_size = Val{0}(),\n                 autodiff = AutoForwardDiff(),\n                 standardtag = Val{true}(),\n                 concrete_jac = nothing,\n                 diff_type = Val{:forward}(),\n                 linsolve = nothing,\n                 precs = DEFAULT_PRECS,\n                 nlsolve = NLNewton(),\n                 extrapolant = :linear,\n                 controller = :PI)\n\nSDIRK Method. Optimized ESDIRK tableaus. Updates of the original KenCarp tableau expected to achieve lower error for the same steps in theory, but are still being fully evaluated in context.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ESDIRK436L2SA2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{Kennedy2019DiagonallyIR, title={Diagonally implicit Runge–Kutta methods for stiff ODEs}, author={Christopher A. Kennedy and Mark H. Carpenter}, journal={Applied Numerical Mathematics}, year={2019}, volume={146}, pages={221-244} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.ESDIRK437L2SA","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.ESDIRK437L2SA","text":"ESDIRK437L2SA(; chunk_size = Val{0}(),\n                autodiff = AutoForwardDiff(),\n                standardtag = Val{true}(),\n                concrete_jac = nothing,\n                diff_type = Val{:forward}(),\n                linsolve = nothing,\n                precs = DEFAULT_PRECS,\n                nlsolve = NLNewton(),\n                extrapolant = :linear,\n                controller = :PI)\n\nSDIRK Method. Optimized ESDIRK tableaus. Updates of the original KenCarp tableau expected to achieve lower error for the same steps in theory, but are still being fully evaluated in context.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ESDIRK437L2SA(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{Kennedy2019DiagonallyIR, title={Diagonally implicit Runge–Kutta methods for stiff ODEs}, author={Christopher A. Kennedy and Mark H. Carpenter}, journal={Applied Numerical Mathematics}, year={2019}, volume={146}, pages={221-244} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.ESDIRK547L2SA2","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.ESDIRK547L2SA2","text":"ESDIRK547L2SA2(; chunk_size = Val{0}(),\n                 autodiff = AutoForwardDiff(),\n                 standardtag = Val{true}(),\n                 concrete_jac = nothing,\n                 diff_type = Val{:forward}(),\n                 linsolve = nothing,\n                 precs = DEFAULT_PRECS,\n                 nlsolve = NLNewton(),\n                 extrapolant = :linear,\n                 controller = :PI)\n\nSDIRK Method. Optimized ESDIRK tableaus. Updates of the original KenCarp tableau expected to achieve lower error for the same steps in theory, but are still being fully evaluated in context.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ESDIRK547L2SA2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{Kennedy2019DiagonallyIR, title={Diagonally implicit Runge–Kutta methods for stiff ODEs}, author={Christopher A. Kennedy and Mark H. Carpenter}, journal={Applied Numerical Mathematics}, year={2019}, volume={146}, pages={221-244} }\n\n\n\n\n\n","category":"type"},{"location":"implicit/SDIRK/#OrdinaryDiffEqSDIRK.ESDIRK659L2SA","page":"OrdinaryDiffEqSDIRK","title":"OrdinaryDiffEqSDIRK.ESDIRK659L2SA","text":"ESDIRK659L2SA(; chunk_size = Val{0}(),\n                autodiff = AutoForwardDiff(),\n                standardtag = Val{true}(),\n                concrete_jac = nothing,\n                diff_type = Val{:forward}(),\n                linsolve = nothing,\n                precs = DEFAULT_PRECS,\n                nlsolve = NLNewton(),\n                extrapolant = :linear,\n                controller = :PI)\n\nSDIRK Method. Optimized ESDIRK tableaus. Updates of the original KenCarp tableau expected to achieve lower error for the same steps in theory, but are still being fully evaluated in context. Currently has STABILITY ISSUES, causing it to fail the adaptive tests. Check issue https://github.com/SciML/OrdinaryDiffEq.jl/issues/1933 for more details.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ESDIRK659L2SA(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{Kennedy2019DiagonallyIR, title={Diagonally implicit Runge–Kutta methods for stiff ODEs}, author={Christopher A. Kennedy and Mark H. Carpenter}, journal={Applied Numerical Mathematics}, year={2019}, volume={146}, pages={221-244} }\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK","text":"","category":"section"},{"location":"semiimplicit/ExponentialRK/","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK","text":"Methods for semi-linear differential equations.","category":"page"},{"location":"semiimplicit/ExponentialRK/#Installation","page":"OrdinaryDiffEqExponentialRK","title":"Installation","text":"","category":"section"},{"location":"semiimplicit/ExponentialRK/","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK","text":"To be able to access the solvers in OrdinaryDiffEqLinear, you must first install them use the Julia package manager:","category":"page"},{"location":"semiimplicit/ExponentialRK/","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK","text":"using Pkg\nPkg.add(\"OrdinaryDiffEqExponentialRK\")","category":"page"},{"location":"semiimplicit/ExponentialRK/","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK","text":"This will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.","category":"page"},{"location":"semiimplicit/ExponentialRK/#Example-usage","page":"OrdinaryDiffEqExponentialRK","title":"Example usage","text":"","category":"section"},{"location":"semiimplicit/ExponentialRK/","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqExponentialRK\", \"EPIRK5s3\")","category":"page"},{"location":"semiimplicit/ExponentialRK/#Full-list-of-solvers","page":"OrdinaryDiffEqExponentialRK","title":"Full list of solvers","text":"","category":"section"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.LawsonEuler-semiimplicit-ExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.LawsonEuler","text":"LawsonEuler(; krylov = false,\n              m = 30,\n              iop = 0)\n\nSemilinear ODE solver First order exponential Euler scheme.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.NorsettEuler-semiimplicit-ExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.NorsettEuler","text":"NorsettEuler(; krylov = false,\n               m = 30,\n               iop = 0)\n\nSemilinear ODE solver First order exponential-RK scheme. Alias: ETD1\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETD2-semiimplicit-ExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETD2","text":"ETD2: Exponential Runge-Kutta Method Second order Exponential Time Differencing method (in development).\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETDRK2-semiimplicit-ExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETDRK2","text":"ETDRK2(; krylov = false,\n         m = 30,\n         iop = 0)\n\nSemilinear ODE solver 2nd order exponential-RK scheme.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETDRK3-semiimplicit-ExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETDRK3","text":"ETDRK3(; krylov = false,\n         m = 30,\n         iop = 0)\n\nSemilinear ODE solver 3rd order exponential-RK scheme.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETDRK4-semiimplicit-ExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETDRK4","text":"ETDRK4(; krylov = false,\n         m = 30,\n         iop = 0)\n\nSemilinear ODE solver 4th order exponential-RK scheme\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.HochOst4-semiimplicit-ExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.HochOst4","text":"HochOst4(; krylov = false,\n           m = 30,\n           iop = 0)\n\nSemilinear ODE solver 4th order exponential-RK scheme with stiff order 4.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#Adaptive-Exponential-Rosenbrock-Methods","page":"OrdinaryDiffEqExponentialRK","title":"Adaptive Exponential Rosenbrock Methods","text":"","category":"section"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.Exprb32","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.Exprb32","text":"Exprb32(; m = 30,\n          iop = 0)\n\nSemilinear ODE solver 3rd order adaptive Exponential-Rosenbrock scheme.\n\nKeyword Arguments\n\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).   Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, M., & Ostermann, A. (2010). Exponential integrators. Acta Numerica, 19, 209-286. (https://doi.org/10.1017/S0962492910000048)\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#OrdinaryDiffEqExponentialRK.Exprb43","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.Exprb43","text":"Exprb43(; m = 30,\n          iop = 0)\n\nSemilinear ODE solver 4th order adaptive Exponential-Rosenbrock scheme.\n\nKeyword Arguments\n\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).   Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, M., & Ostermann, A. (2010). Exponential integrators. Acta Numerica, 19, 209-286. (https://doi.org/10.1017/S0962492910000048)\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/ExponentialRK/#Exponential-Propagation-Iterative-Runge-Kutta-Methods-(EPIRK)","page":"OrdinaryDiffEqExponentialRK","title":"Exponential Propagation Iterative Runge-Kutta Methods (EPIRK)","text":"","category":"section"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock","text":"","category":"section"},{"location":"semiimplicit/Rosenbrock/","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock","text":"Methods for small and medium sized stiff systems of differential equations. At high tolerances, >1e-2, Rosenbrock23 is a good choice. At medium tolerances >1e-8 it is recommended you use Rodas5P or Rodas4P, the former is more efficient, but the latter is more reliable. For larger systems look at multistep methods.","category":"page"},{"location":"semiimplicit/Rosenbrock/","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqRosenbrock\", \"Rodas5P\")","category":"page"},{"location":"semiimplicit/Rosenbrock/#Full-list-of-solvers","page":"OrdinaryDiffEqRosenbrock","title":"Full list of solvers","text":"","category":"section"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rosenbrock23","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rosenbrock23","text":"Rosenbrock23(; chunk_size = Val{0}(),\n               standardtag = Val{true}(),\n               autodiff = AutoForwardDiff(),\n               concrete_jac = nothing,\n               diff_type = Val{:forward}(),\n               linsolve = nothing,\n               precs = DEFAULT_PRECS,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  An Order 2/3 L-Stable Rosenbrock-W method which is good for very stiff equations with oscillations at low tolerances. 2nd order stiff-aware interpolation.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rosenbrock23(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nShampine L.F. and Reichelt M., (1997) The MATLAB ODE Suite, SIAM Journal of\n\nScientific Computing, 18 (1), pp. 1-22.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rosenbrock32","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rosenbrock32","text":"Rosenbrock32(; chunk_size = Val{0}(),\n               standardtag = Val{true}(),\n               autodiff = AutoForwardDiff(),\n               concrete_jac = nothing,\n               diff_type = Val{:forward}(),\n               linsolve = nothing,\n               precs = DEFAULT_PRECS,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  An Order 3/2 A-Stable Rosenbrock-W method which is good for mildly stiff equations without oscillations at low tolerances. Note that this method is prone to instability in the presence of oscillations, so use with caution. 2nd order stiff-aware interpolation.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rosenbrock32(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nShampine L.F. and Reichelt M., (1997) The MATLAB ODE Suite, SIAM Journal of\n\nScientific Computing, 18 (1), pp. 1-22.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3P","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3P","text":"ROS3P(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n            ForwardDiff default function-specific tags. For more information, see\n            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n            Defaults to `Val{true}()`.\n        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n            to specify whether to use automatic differentiation via\n            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n            `nothing`, which means it will be chosen true/false depending on circumstances\n            of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n          `ROS3P(linsolve = KLUFactorization()`).\n           When `nothing` is passed, uses `DefaultLinearSolver`.\n        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n          can be used as a left or right preconditioner.\n          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n          function where the arguments are defined as:\n            - `W`: the current Jacobian of the nonlinear system. Specified as either\n                ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                representation of the operator. Users can construct the W-matrix on demand\n                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                the `jac_prototype`.\n            - `du`: the current ODE derivative\n            - `u`: the current ODE state\n            - `p`: the ODE parameters\n            - `t`: the current ODE time\n            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                the last call to `precs`. It is recommended that this is checked to only\n                update the preconditioner when `newW == true`.\n            - `Plprev`: the previous `Pl`.\n            - `Prprev`: the previous `Pr`.\n            - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                Solver-dependent and subject to change.\n          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n          To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n          which is not used. Additionally, `precs` must supply the dispatch:\n          ```julia\n          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n          ```\n          which is used in the solver setup phase to construct the integrator\n          type with the preconditioners `(Pl,Pr)`.\n          The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n          is defined as:\n          ```julia\n          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n          ```\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method. Keeps high accuracy on discretizations of nonlinear parabolic PDEs.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nLang, J. & Verwer, ROS3P—An Accurate Third-Order Rosenbrock Solver Designed for Parabolic Problems J. BIT Numerical Mathematics (2001) 41: 731. doi:10.1023/A:1021900219772\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas3","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas3","text":"Rodas3(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Rodas3(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSandu, Verwer, Van Loon, Carmichael, Potra, Dabdub, Seinfeld, Benchmarking stiff ode solvers for atmospheric chemistry problems-I.    implicit vs explicit, Atmospheric Environment, 31(19), 3151-3166, 1997.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas23W","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas23W","text":"Rodas23W(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  An Order 2/3 L-Stable Rosenbrock-W method for stiff ODEs and DAEs in mass matrix form. 2nd order stiff-aware interpolation and additional error test for interpolation.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas23W(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G., Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024 https://github.com/hbrs-cse/RosenbrockMethods/blob/main/paper/JuliaPaper.pdf\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas3P","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas3P","text":"Rodas3P(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `Rodas3P(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant and additional error test for interpolation. Keeps accuracy on discretizations of linear parabolic PDEs.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G., Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024 https://github.com/hbrs-cse/RosenbrockMethods/blob/main/paper/JuliaPaper.pdf\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas4","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas4","text":"Rodas4(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Rodas4(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 4th order L-stable Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas42","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas42","text":"Rodas42(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `Rodas42(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas4P","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas4P","text":"Rodas4P(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `Rodas4P(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems (as opposed to lower if not corrected).\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach, G., Rentrop, P., An adaptive method of lines approach for modelling flow and transport in rivers.    Adaptive method of lines , Wouver, A. Vande, Sauces, Ph., Schiesser, W.E. (ed.),S. 181-205,Chapman & Hall/CRC, 2001,\nSteinebach, G., Oder-reduction of ROW-methods for DAEs and method of lines  applications.    Preprint-Nr. 1741, FB Mathematik, TH Darmstadt, 1995.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas4P2","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas4P2","text":"Rodas4P2(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems. It is an improvement of Roadas4P and in case of inexact Jacobians a second order W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas4P2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G., Improvement of Rosenbrock-Wanner Method RODASP, In: Reis T., Grundel S., Schöps S. (eds)    Progress in Differential-Algebraic Equations II. Differential-Algebraic Equations Forum. Springer, Cham., 165-184, 2020.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5","text":"Rodas5(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Rodas5(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 5th order A-stable stiffly stable Rosenbrock method with a stiff-aware 4th order interpolant.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nDi Marzo G. RODAS5(4) – Méthodes de Rosenbrock d’ordre 5(4) adaptées aux problemes différentiels-algébriques. MSc mathematics thesis, Faculty of Science, University of Geneva, Switzerland.\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5P","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5P","text":"Rodas5P(; chunk_size = Val{0}(),\n          standardtag = Val{true}(),\n          autodiff = AutoForwardDiff(),\n          concrete_jac = nothing,\n          diff_type = Val{:forward}(),\n          linsolve = nothing,\n          precs = DEFAULT_PRECS,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 5th order A-stable stiffly stable Rosenbrock method with a stiff-aware 4th order interpolant. Has improved stability in the adaptive time stepping embedding.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas5P(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G. Construction of Rosenbrock–Wanner method Rodas5P and numerical benchmarks within the Julia Differential Equations package. In: BIT Numerical Mathematics, 63(2), 2023\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5Pe","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5Pe","text":"Rodas5Pe(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  Variant of Ropdas5P with modified embedded scheme.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas5Pe(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G. Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024 https://github.com/hbrs-cse/RosenbrockMethods/blob/main/paper/JuliaPaper.pdf\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5Pr","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5Pr","text":"Rodas5Pr(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  Variant of Ropdas5P with additional residual control.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas5Pr(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G. Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024 https://github.com/hbrs-cse/RosenbrockMethods/blob/main/paper/JuliaPaper.pdf\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.RosenbrockW6S4OS","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.RosenbrockW6S4OS","text":"RosenbrockW6S4OS(; chunk_size = Val{0}(),\n                   standardtag = Val{true}(),\n                   autodiff = AutoForwardDiff(),\n                   concrete_jac = nothing,\n                   diff_type = Val{:forward}(),\n                   linsolve = nothing,\n                   precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method (fixed step only).\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify RosenbrockW6S4OS(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nhttps://doi.org/10.1016/j.cam.2009.09.017\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS2","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS2","text":"ROS2(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n           ForwardDiff default function-specific tags. For more information, see\n           [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n           Defaults to `Val{true}()`.\n       - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n           to specify whether to use automatic differentiation via\n           [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n           differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n           Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n           `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n           To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n           `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n       - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n           `nothing`, which means it will be chosen true/false depending on circumstances\n           of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n       - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n         For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n         `ROS2(linsolve = KLUFactorization()`).\n          When `nothing` is passed, uses `DefaultLinearSolver`.\n       - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n         can be used as a left or right preconditioner.\n         Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n         function where the arguments are defined as:\n           - `W`: the current Jacobian of the nonlinear system. Specified as either\n               ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n               commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n               representation of the operator. Users can construct the W-matrix on demand\n               by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n               the `jac_prototype`.\n           - `du`: the current ODE derivative\n           - `u`: the current ODE state\n           - `p`: the ODE parameters\n           - `t`: the current ODE time\n           - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n               the last call to `precs`. It is recommended that this is checked to only\n               update the preconditioner when `newW == true`.\n           - `Plprev`: the previous `Pl`.\n           - `Prprev`: the previous `Pr`.\n           - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n               Solver-dependent and subject to change.\n         The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n         To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n         which is not used. Additionally, `precs` must supply the dispatch:\n         ```julia\n         Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n         ```\n         which is used in the solver setup phase to construct the integrator\n         type with the preconditioners `(Pl,Pr)`.\n         The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n         is defined as:\n         ```julia\n         DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n         ```)\n\nRosenbrock-Wanner Method.  A 2nd order L-stable Rosenbrock method with 2 internal stages.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nJ. G. Verwer et al. (1999): A second-order Rosenbrock method applied to photochemical dispersion problems https://doi.org/10.1137/S1064827597326651\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS2PR","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS2PR","text":"ROS2PR(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `ROS2PR(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```)\n\nRosenbrock-Wanner Method.  2nd order stiffly accurate Rosenbrock method with 3 internal stages with (Rinf=0). For problems with medium stiffness the convergence behaviour is very poor and it is recommended to use ROS2S instead.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS2S","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS2S","text":"ROS2S(; chunk_size = Val{0}(),\n        standardtag = Val{true}(),\n        autodiff = AutoForwardDiff(),\n        concrete_jac = nothing,\n        diff_type = Val{:forward}(),\n        linsolve = nothing,\n        precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  2nd order stiffly accurate Rosenbrock-Wanner W-method with 3 internal stages with B_PR consistent of order 2 with (Rinf=0).\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS2S(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3","text":"ROS3(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n           ForwardDiff default function-specific tags. For more information, see\n           [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n           Defaults to `Val{true}()`.\n       - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n           to specify whether to use automatic differentiation via\n           [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n           differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n           Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n           `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n           To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n           `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n       - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n           `nothing`, which means it will be chosen true/false depending on circumstances\n           of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n       - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n         For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n         `ROS3(linsolve = KLUFactorization()`).\n          When `nothing` is passed, uses `DefaultLinearSolver`.\n       - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n         can be used as a left or right preconditioner.\n         Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n         function where the arguments are defined as:\n           - `W`: the current Jacobian of the nonlinear system. Specified as either\n               ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n               commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n               representation of the operator. Users can construct the W-matrix on demand\n               by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n               the `jac_prototype`.\n           - `du`: the current ODE derivative\n           - `u`: the current ODE state\n           - `p`: the ODE parameters\n           - `t`: the current ODE time\n           - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n               the last call to `precs`. It is recommended that this is checked to only\n               update the preconditioner when `newW == true`.\n           - `Plprev`: the previous `Pl`.\n           - `Prprev`: the previous `Pr`.\n           - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n               Solver-dependent and subject to change.\n         The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n         To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n         which is not used. Additionally, `precs` must supply the dispatch:\n         ```julia\n         Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n         ```\n         which is used in the solver setup phase to construct the integrator\n         type with the preconditioners `(Pl,Pr)`.\n         The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n         is defined as:\n         ```julia\n         DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n         ```)\n\nRosenbrock-Wanner Method.  3rd order L-stable Rosenbrock method with 3 internal stages with an embedded strongly A-stable 2nd order method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3PR","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3PR","text":"ROS3PR(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `ROS3PR(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```)\n\nRosenbrock-Wanner Method.  3nd order stiffly accurate Rosenbrock method with 3 internal stages with B_PR consistent of order 3, which is strongly A-stable with Rinf~=-0.73.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Scholz4_7","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Scholz4_7","text":"Scholz4_7(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n                ForwardDiff default function-specific tags. For more information, see\n                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n                Defaults to `Val{true}()`.\n            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n                to specify whether to use automatic differentiation via\n                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n                `nothing`, which means it will be chosen true/false depending on circumstances\n                of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n              `Scholz4_7(linsolve = KLUFactorization()`).\n               When `nothing` is passed, uses `DefaultLinearSolver`.\n            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n              can be used as a left or right preconditioner.\n              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n              function where the arguments are defined as:\n                - `W`: the current Jacobian of the nonlinear system. Specified as either\n                    ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                    representation of the operator. Users can construct the W-matrix on demand\n                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                    the `jac_prototype`.\n                - `du`: the current ODE derivative\n                - `u`: the current ODE state\n                - `p`: the ODE parameters\n                - `t`: the current ODE time\n                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                    the last call to `precs`. It is recommended that this is checked to only\n                    update the preconditioner when `newW == true`.\n                - `Plprev`: the previous `Pl`.\n                - `Prprev`: the previous `Pr`.\n                - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                    Solver-dependent and subject to change.\n              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n              To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n              which is not used. Additionally, `precs` must supply the dispatch:\n              ```julia\n              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n              ```\n              which is used in the solver setup phase to construct the integrator\n              type with the preconditioners `(Pl,Pr)`.\n              The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n              is defined as:\n              ```julia\n              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n              ```)\n\nRosenbrock-Wanner Method.  3nd order stiffly accurate Rosenbrock method with 3 internal stages with B_PR consistent of order 3, which is strongly A-stable with Rinf~=-0.73. Convergence with order 4 for the stiff case, but has a poor accuracy.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW1a","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW1a","text":"ROS34PW1a(; chunk_size = Val{0}(),\n            standardtag = Val{true}(),\n            autodiff = AutoForwardDiff(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW1a(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\n@article{rang2005new,   title={New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1},   author={Rang, Joachim and Angermann, L},   journal={BIT Numerical Mathematics},   volume={45},   pages={761–787},   year={2005},   publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW1b","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW1b","text":"ROS34PW1b(; chunk_size = Val{0}(),\n            standardtag = Val{true}(),\n            autodiff = AutoForwardDiff(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW1b(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\n@article{rang2005new,   title={New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1},   author={Rang, Joachim and Angermann, L},   journal={BIT Numerical Mathematics},   volume={45},   pages={761–787},   year={2005},   publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW2","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW2","text":"ROS34PW2(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order stiffy accurate Rosenbrock-W method for PDAEs.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\n@article{rang2005new,   title={New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1},   author={Rang, Joachim and Angermann, L},   journal={BIT Numerical Mathematics},   volume={45},   pages={761–787},   year={2005},   publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW3","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW3","text":"ROS34PW3(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order strongly A-stable (Rinf~0.63) Rosenbrock-W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW3(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\n@article{rang2005new,   title={New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1},   author={Rang, Joachim and Angermann, L},   journal={BIT Numerical Mathematics},   volume={45},   pages={761–787},   year={2005},   publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PRw","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PRw","text":"ROS34PRw(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  3rd order stiffly accurate Rosenbrock-Wanner W-method with 4 internal stages, B_PR consistent of order 2. The order of convergence decreases if medium stiff problems are considered.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PRw(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nJoachim Rang, Improved traditional Rosenbrock–Wanner methods for stiff ODEs and DAEs, Journal of Computational and Applied Mathematics, https://doi.org/10.1016/j.cam.2015.03.010\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3PRL","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3PRL","text":"ROS3PRL(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `ROS3PRL(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```)\n\nRosenbrock-Wanner Method.  3rd order stiffly accurate Rosenbrock method with 4 internal stages, B_PR consistent of order 2 with Rinf=0. The order of convergence decreases if medium stiff problems are considered, but it has good results for very stiff cases.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3PRL2","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3PRL2","text":"ROS3PRL2(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n               ForwardDiff default function-specific tags. For more information, see\n               [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n               Defaults to `Val{true}()`.\n           - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n               to specify whether to use automatic differentiation via\n               [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n               differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n               Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n               `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n               To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n               `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n           - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n               `nothing`, which means it will be chosen true/false depending on circumstances\n               of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n           - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n             For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n             `ROS3PRL2(linsolve = KLUFactorization()`).\n              When `nothing` is passed, uses `DefaultLinearSolver`.\n           - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n             can be used as a left or right preconditioner.\n             Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n             function where the arguments are defined as:\n               - `W`: the current Jacobian of the nonlinear system. Specified as either\n                   ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                   commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                   representation of the operator. Users can construct the W-matrix on demand\n                   by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                   the `jac_prototype`.\n               - `du`: the current ODE derivative\n               - `u`: the current ODE state\n               - `p`: the ODE parameters\n               - `t`: the current ODE time\n               - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                   the last call to `precs`. It is recommended that this is checked to only\n                   update the preconditioner when `newW == true`.\n               - `Plprev`: the previous `Pl`.\n               - `Prprev`: the previous `Pr`.\n               - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                   Solver-dependent and subject to change.\n             The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n             To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n             which is not used. Additionally, `precs` must supply the dispatch:\n             ```julia\n             Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n             ```\n             which is used in the solver setup phase to construct the integrator\n             type with the preconditioners `(Pl,Pr)`.\n             The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n             is defined as:\n             ```julia\n             DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n             ```)\n\nRosenbrock-Wanner Method.  3rd order stiffly accurate Rosenbrock method with 4 internal stages, B_PR consistent of order 3. The order of convergence does NOT decreases if medium stiff problems are considered as it does for ROS3PRL.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROK4a","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROK4a","text":"ROK4a(; chunk_size = Val{0}(),\n        standardtag = Val{true}(),\n        autodiff = AutoForwardDiff(),\n        concrete_jac = nothing,\n        diff_type = Val{:forward}(),\n        linsolve = nothing,\n        precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  4rd order L-stable Rosenbrock-Krylov method with 4 internal stages, with a 3rd order embedded method which is strongly A-stable with Rinf~=0.55. (when using exact Jacobians)\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROK4a(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nTranquilli, Paul and Sandu, Adrian (2014): Rosenbrock–Krylov Methods for Large Systems of Differential Equations https://doi.org/10.1137/130923336\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.RosShamp4","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.RosShamp4","text":"RosShamp4(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n                ForwardDiff default function-specific tags. For more information, see\n                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n                Defaults to `Val{true}()`.\n            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n                to specify whether to use automatic differentiation via\n                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n                `nothing`, which means it will be chosen true/false depending on circumstances\n                of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n              `RosShamp4(linsolve = KLUFactorization()`).\n               When `nothing` is passed, uses `DefaultLinearSolver`.\n            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n              can be used as a left or right preconditioner.\n              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n              function where the arguments are defined as:\n                - `W`: the current Jacobian of the nonlinear system. Specified as either\n                    ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                    representation of the operator. Users can construct the W-matrix on demand\n                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                    the `jac_prototype`.\n                - `du`: the current ODE derivative\n                - `u`: the current ODE state\n                - `p`: the ODE parameters\n                - `t`: the current ODE time\n                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                    the last call to `precs`. It is recommended that this is checked to only\n                    update the preconditioner when `newW == true`.\n                - `Plprev`: the previous `Pl`.\n                - `Prprev`: the previous `Pr`.\n                - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                    Solver-dependent and subject to change.\n              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n              To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n              which is not used. Additionally, `precs` must supply the dispatch:\n              ```julia\n              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n              ```\n              which is used in the solver setup phase to construct the integrator\n              type with the preconditioners `(Pl,Pr)`.\n              The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n              is defined as:\n              ```julia\n              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n              ```)\n\nRosenbrock-Wanner Method.  An A-stable 4th order Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nL. F. Shampine, Implementation of Rosenbrock Methods, ACM Transactions on Mathematical Software (TOMS), 8: 2, 93-113. doi:10.1145/355993.355994\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Veldd4","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Veldd4","text":"Veldd4(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Veldd4(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 4th order D-stable Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nvan Veldhuizen, D-stability and Kaps-Rentrop-methods, M. Computing (1984) 32: 229. doi:10.1007/BF02243574\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Velds4","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Velds4","text":"Velds4(; chunk_size = Val{0}(),\n         standardtag = Val{true}(),\n         autodiff = AutoForwardDiff(),\n         concrete_jac = nothing,\n         diff_type = Val{:forward}(),\n         linsolve = nothing,\n         precs = DEFAULT_PRECS,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order A-stable Rosenbrock method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Velds4(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nvan Veldhuizen, D-stability and Kaps-Rentrop-methods, M. Computing (1984) 32: 229. doi:10.1007/BF02243574\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.GRK4T","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.GRK4T","text":"GRK4T(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n            ForwardDiff default function-specific tags. For more information, see\n            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n            Defaults to `Val{true}()`.\n        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n            to specify whether to use automatic differentiation via\n            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n            `nothing`, which means it will be chosen true/false depending on circumstances\n            of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n          `GRK4T(linsolve = KLUFactorization()`).\n           When `nothing` is passed, uses `DefaultLinearSolver`.\n        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n          can be used as a left or right preconditioner.\n          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n          function where the arguments are defined as:\n            - `W`: the current Jacobian of the nonlinear system. Specified as either\n                ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                representation of the operator. Users can construct the W-matrix on demand\n                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                the `jac_prototype`.\n            - `du`: the current ODE derivative\n            - `u`: the current ODE state\n            - `p`: the ODE parameters\n            - `t`: the current ODE time\n            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                the last call to `precs`. It is recommended that this is checked to only\n                update the preconditioner when `newW == true`.\n            - `Plprev`: the previous `Pl`.\n            - `Prprev`: the previous `Pr`.\n            - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                Solver-dependent and subject to change.\n          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n          To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n          which is not used. Additionally, `precs` must supply the dispatch:\n          ```julia\n          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n          ```\n          which is used in the solver setup phase to construct the integrator\n          type with the preconditioners `(Pl,Pr)`.\n          The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n          is defined as:\n          ```julia\n          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n          ```\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  An efficient 4th order Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nKaps, P. & Rentrop, Generalized Runge-Kutta methods of order four with stepsize control for stiff ordinary differential equations. P. Numer. Math. (1979) 33: 55. doi:10.1007/BF01396495\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.GRK4A","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.GRK4A","text":"GRK4A(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n            ForwardDiff default function-specific tags. For more information, see\n            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n            Defaults to `Val{true}()`.\n        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n            to specify whether to use automatic differentiation via\n            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n            `nothing`, which means it will be chosen true/false depending on circumstances\n            of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n          `GRK4A(linsolve = KLUFactorization()`).\n           When `nothing` is passed, uses `DefaultLinearSolver`.\n        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n          can be used as a left or right preconditioner.\n          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n          function where the arguments are defined as:\n            - `W`: the current Jacobian of the nonlinear system. Specified as either\n                ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                representation of the operator. Users can construct the W-matrix on demand\n                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                the `jac_prototype`.\n            - `du`: the current ODE derivative\n            - `u`: the current ODE state\n            - `p`: the ODE parameters\n            - `t`: the current ODE time\n            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                the last call to `precs`. It is recommended that this is checked to only\n                update the preconditioner when `newW == true`.\n            - `Plprev`: the previous `Pl`.\n            - `Prprev`: the previous `Pr`.\n            - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                Solver-dependent and subject to change.\n          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n          To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n          which is not used. Additionally, `precs` must supply the dispatch:\n          ```julia\n          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n          ```\n          which is used in the solver setup phase to construct the integrator\n          type with the preconditioners `(Pl,Pr)`.\n          The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n          is defined as:\n          ```julia\n          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n          ```\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  An A-stable 4th order Rosenbrock method. Essentially \"anti-L-stable\" but efficient.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nKaps, P. & Rentrop, Generalized Runge-Kutta methods of order four with stepsize control for stiff ordinary differential equations. P. Numer. Math. (1979) 33: 55. doi:10.1007/BF01396495\n\n\n\n\n\n","category":"type"},{"location":"semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.Ros4LStab","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Ros4LStab","text":"Ros4LStab(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n                ForwardDiff default function-specific tags. For more information, see\n                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n                Defaults to `Val{true}()`.\n            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n                to specify whether to use automatic differentiation via\n                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n                `nothing`, which means it will be chosen true/false depending on circumstances\n                of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n              `Ros4LStab(linsolve = KLUFactorization()`).\n               When `nothing` is passed, uses `DefaultLinearSolver`.\n            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n              can be used as a left or right preconditioner.\n              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n              function where the arguments are defined as:\n                - `W`: the current Jacobian of the nonlinear system. Specified as either\n                    ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                    representation of the operator. Users can construct the W-matrix on demand\n                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                    the `jac_prototype`.\n                - `du`: the current ODE derivative\n                - `u`: the current ODE state\n                - `p`: the ODE parameters\n                - `t`: the current ODE time\n                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                    the last call to `precs`. It is recommended that this is checked to only\n                    update the preconditioner when `newW == true`.\n                - `Plprev`: the previous `Pl`.\n                - `Prprev`: the previous `Pr`.\n                - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                    Solver-dependent and subject to change.\n              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n              To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n              which is not used. Additionally, `precs` must supply the dispatch:\n              ```julia\n              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n              ```\n              which is used in the solver setup phase to construct the integrator\n              type with the preconditioners `(Pl,Pr)`.\n              The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n              is defined as:\n              ```julia\n              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n              ```\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"fullyimplicitdae/BDF/#OrdinaryDiffEqBDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"","category":"section"},{"location":"fullyimplicitdae/BDF/","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"Multistep BDF methods, good for large stiff systems.","category":"page"},{"location":"fullyimplicitdae/BDF/","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"using OrdinaryDiffEqBDF\n\nfunction f2(out, du, u, p, t)\n    out[1] = -0.04u[1] + 1e4 * u[2] * u[3] - du[1]\n    out[2] = +0.04u[1] - 3e7 * u[2]^2 - 1e4 * u[2] * u[3] - du[2]\n    out[3] = u[1] + u[2] + u[3] - 1.0\nend\nu₀ = [1.0, 0, 0]\ndu₀ = [-0.04, 0.04, 0.0]\ntspan = (0.0, 100000.0)\ndifferential_vars = [true, true, false]\nprob = DAEProblem(f2, du₀, u₀, tspan, differential_vars = differential_vars)\nsol = solve(prob, DFBDF())","category":"page"},{"location":"fullyimplicitdae/BDF/#Full-list-of-solvers","page":"OrdinaryDiffEqBDF","title":"Full list of solvers","text":"","category":"section"},{"location":"fullyimplicitdae/BDF/#DAE","page":"OrdinaryDiffEqBDF","title":"DAE","text":"","category":"section"},{"location":"fullyimplicitdae/BDF/#OrdinaryDiffEqBDF.DImplicitEuler","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.DImplicitEuler","text":"DImplicitEuler(; chunk_size = Val{0}(),\n                 autodiff = AutoForwardDiff(),\n                 standardtag = Val{true}(),\n                 concrete_jac = nothing,\n                 linsolve = nothing,\n                 precs = DEFAULT_PRECS,\n                 nlsolve = NLNewton(),\n                 extrapolant = :constant,\n                 controller = :Standard)\n\nMultistep Method. Implicit Euler for implicit DAE form. It uses an apriori error estimator for adaptivity based on a finite differencing approximation from SPICE.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify DImplicitEuler(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n\n\n\n\n","category":"type"},{"location":"fullyimplicitdae/BDF/#OrdinaryDiffEqBDF.DABDF2","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.DABDF2","text":"DABDF2(; chunk_size = Val{0}(),\n         autodiff = AutoForwardDiff(),\n         standardtag = Val{true}(),\n         concrete_jac = nothing,\n         linsolve = nothing,\n         precs = DEFAULT_PRECS,\n         nlsolve = NLNewton(),\n         extrapolant = :constant,\n         controller = :Standard)\n\nMultistep Method. Fully implicit implementation of BDF2.\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify DABDF2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- nlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\n\nReferences\n\n@article{celaya2014implementation, title={Implementation of an Adaptive BDF2 Formula and Comparison with the MATLAB Ode15s}, author={Celaya, E Alberdi and Aguirrezabala, JJ Anza and Chatzipantelidis, Panagiotis}, journal={Procedia Computer Science}, volume={29}, pages={1014–1026}, year={2014}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"fullyimplicitdae/BDF/#OrdinaryDiffEqBDF.DFBDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.DFBDF","text":"DFBDF(; chunk_size = Val{0}(),\n        autodiff = AutoForwardDiff(),\n        standardtag = Val{true}(),\n        concrete_jac = nothing,\n        linsolve = nothing,\n        precs = DEFAULT_PRECS,\n        κ = nothing,\n        tol = nothing,\n        nlsolve = NLNewton(),\n        extrapolant = :linear,\n        controller = :Standard,\n        max_order::Val{MO} = Val{5}())\n\nMultistep Method. Fully implicit implementation of FBDF based on Shampine's\n\nKeyword Arguments\n\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify DFBDF(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n/n- κ: TBD\ntol: TBD\nnlsolve: TBD\nextrapolant: TBD\ncontroller: TBD\nmax_order: TBD\n\nReferences\n\n@article{shampine2002solving, title={Solving 0= F (t, y (t), y′(t)) in Matlab}, author={Shampine, Lawrence F}, year={2002}, publisher={Walter de Gruyter GmbH and Co. KG} }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK","text":"","category":"section"},{"location":"explicit/LowOrderRK/","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK","text":"If OrdinaryDiffEqTsit5 is not working well for your non-stiff problem at default and higher tolerance, it can be worthwhile to explore the options in this package. In particular, when more robust error control is required, BS5 is a good choice. If at moderate tolerances and the interpolation error is very important, consider the OwrenZen5 method. For fast solving at higher tolerances, we recommend BS3, or OwrenZen3if the interpolation error is important.","category":"page"},{"location":"explicit/LowOrderRK/","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqLowOrderRK\", \"BS3\")","category":"page"},{"location":"explicit/LowOrderRK/#Full-list-of-solvers","page":"OrdinaryDiffEqLowOrderRK","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Euler","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Euler","text":"Euler()\n\nExplicit Runge-Kutta Method. The canonical forward Euler method. Fixed timestep only.\n\nKeyword Arguments\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I. Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics, Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Heun","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Heun","text":"Heun(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n       step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n       thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  The second order Heun's method. Uses embedded Euler method for adaptivity.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I. Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics, Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Ralston","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Ralston","text":"Ralston(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  The optimized second order midpoint method. Uses embedded Euler method for adaptivity.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I. Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics, Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Midpoint","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Midpoint","text":"Midpoint(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  The second order midpoint method. Uses embedded Euler method for adaptivity.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I. Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics, Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.RK4","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.RK4","text":"RK4(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  The canonical Runge-Kutta Order 4 method. Uses a defect control for adaptive stepping using maximum error over the whole interval.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{shampine2005solving,       title={Solving ODEs and DDEs with residual control},       author={Shampine, LF},       journal={Applied Numerical Mathematics},       volume={52},       number={1},       pages={113–127},       year={2005},       publisher={Elsevier}       }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.BS3","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.BS3","text":"BS3(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, four-stage FSAL method with embedded error estimator of Bogacki and Shampine.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{bogacki19893,     title={A 3 (2) pair of Runge-Kutta formulas},     author={Bogacki, Przemyslaw and Shampine, Lawrence F},     journal={Applied Mathematics Letters},     volume={2},     number={4},     pages={321–325},     year={1989},     publisher={Elsevier}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.OwrenZen3","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.OwrenZen3","text":"OwrenZen3(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Owren-Zennaro optimized interpolation 3/2 method (free 3rd order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{owren1992derivation,     title={Derivation of efficient, continuous, explicit Runge–Kutta methods},     author={Owren, Brynjulf and Zennaro, Marino},     journal={SIAM journal on scientific and statistical computing},     volume={13},     number={6},     pages={1488–1501},     year={1992},     publisher={SIAM}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.OwrenZen4","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.OwrenZen4","text":"OwrenZen4(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Owren-Zennaro optimized interpolation 4/3 method (free 4th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{owren1992derivation,     title={Derivation of efficient, continuous, explicit Runge–Kutta methods},     author={Owren, Brynjulf and Zennaro, Marino},     journal={SIAM journal on scientific and statistical computing},     volume={13},     number={6},     pages={1488–1501},     year={1992},     publisher={SIAM}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.OwrenZen5","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.OwrenZen5","text":"OwrenZen5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Owren-Zennaro optimized interpolation 5/4 method (free 5th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{owren1992derivation,     title={Derivation of efficient, continuous, explicit Runge–Kutta methods},     author={Owren, Brynjulf and Zennaro, Marino},     journal={SIAM journal on scientific and statistical computing},     volume={13},     number={6},     pages={1488–1501},     year={1992},     publisher={SIAM}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.BS5","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.BS5","text":"BS5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      thread = OrdinaryDiffEq.False(),\n      lazy = true)\n\nExplicit Runge-Kutta Method.  Bogacki-Shampine 5/4 Runge-Kutta method. (lazy 5th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nlazy: determines if the lazy interpolant is used.\n\nReferences\n\n@article{bogacki1996efficient,     title={An efficient runge-kutta (4, 5) pair},     author={Bogacki, P and Shampine, Lawrence F},     journal={Computers \\& Mathematics with Applications},     volume={32},     number={6},     pages={15–28},     year={1996},     publisher={Elsevier}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.DP5","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.DP5","text":"DP5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Dormand-Prince's 5/4 Runge-Kutta method. (free 4th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{dormand1980family,     title={A family of embedded Runge-Kutta formulae},     author={Dormand, John R and Prince, Peter J},     journal={Journal of computational and applied mathematics},     volume={6},     number={1},     pages={19–26},     year={1980},     publisher={Elsevier}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Anas5","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Anas5","text":"Anas5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False(),\n        w = 1)\n\nExplicit Runge-Kutta Method.  4th order Runge-Kutta method designed for periodic problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nw: a periodicity estimate, which when accurate the method becomes 5th order\n\n(and is otherwise 4th order with less error for better estimates).\n\nReferences\n\n@article{anastassi2005optimized, title={An optimized Runge–Kutta method for the solution of orbital problems}, author={Anastassi, ZA and Simos, TE}, journal={Journal of Computational and Applied Mathematics}, volume={175}, number={1}, pages={1–9}, year={2005}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.RKO65","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.RKO65","text":"RKO65(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  5th order method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nTsitouras, Ch. \"Explicit Runge–Kutta methods for starting integration of     Lane–Emden problem.\" Applied Mathematics and Computation 354 (2019): 353-364.     doi: https://doi.org/10.1016/j.amc.2019.02.047\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.FRK65","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.FRK65","text":"FRK65(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False(),\n        omega = 0.0)\n\nExplicit Runge-Kutta Method.  Zero Dissipation Runge-Kutta of 6th order.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nomega: a periodicity phase estimate,\n\nwhen accurate this method results in zero numerical dissipation.\n\nReferences\n\n@article{medvedev2018fitted, title={Fitted modifications of Runge-Kutta pairs of orders 6 (5)}, author={Medvedev, Maxim A and Simos, TE and Tsitouras, Ch}, journal={Mathematical Methods in the Applied Sciences}, volume={41}, number={16}, pages={6184–6194}, year={2018}, publisher={Wiley Online Library}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.RKM","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.RKM","text":"RKM(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n      thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Method designed to have good stability properties when applied to pseudospectral discretizations of hyperbolic partial differential equaitons.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{mead1999optimal,   title={Optimal Runge–Kutta methods for first order pseudospectral operators},   author={Mead, JL and Renaut, RA},   journal={Journal of Computational Physics},   volume={152},   number={1},   pages={404–419},   year={1999},   publisher={Elsevier} }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.MSRK5","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.MSRK5","text":"MSRK5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  5th order method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nMisha Stepanov - https://arxiv.org/pdf/2202.08443.pdf : Figure 3.\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.MSRK6","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.MSRK6","text":"MSRK6(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  6th order method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nMisha Stepanov - https://arxiv.org/pdf/2202.08443.pdf : Table4\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.PSRK4p7q6","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.PSRK4p7q6","text":"PSRK4p7q6(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  6-stage Pseudo-Symplectic method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Aubry1998,     author = {A. Aubry and P. Chartier},     journal = {BIT Numer. Math.},     title =  {Pseudo-symplectic {R}unge-{K}utta methods},     volume = {38},     PAGES = {439-461},     year = {1998},     },     @article{Capuano2017,     title = {Explicit {R}unge–{K}utta schemes for incompressible flow with improved energy-conservation properties},     journal = {J. Comput. Phys.},     volume = {328},     pages = {86-94},     year = {2017},     issn = {0021-9991},     doi = {https://doi.org/10.1016/j.jcp.2016.10.040},     author = {F. Capuano and G. Coppola and L. Rández and L. {de Luca}},}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.PSRK3p5q4","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.PSRK3p5q4","text":"PSRK3p5q4(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  4-stage Pseudo-Symplectic method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Aubry1998,     author = {A. Aubry and P. Chartier},     journal = {BIT Numer. Math.},     title =  {Pseudo-symplectic {R}unge-{K}utta methods},     year = {1998},     },     @article{Capuano2017,     title = {Explicit {R}unge–{K}utta schemes for incompressible flow with improved energy-conservation properties},     journal = {J. Comput. Phys.},     year = {2017},     author = {F. Capuano and G. Coppola and L. Rández and L. {de Luca}},}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.PSRK3p6q5","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.PSRK3p6q5","text":"PSRK3p6q5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  5-stage Pseudo-Symplectic method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Aubry1998,     author = {A. Aubry and P. Chartier},     journal = {BIT Numer. Math.},     title =  {Pseudo-symplectic {R}unge-{K}utta methods},     year = {1998},     },     @article{Capuano2017,     title = {Explicit {R}unge–{K}utta schemes for incompressible flow with improved energy-conservation properties},     journal = {J. Comput. Phys.},     year = {2017},     author = {F. Capuano and G. Coppola and L. Rández and L. {de Luca}},}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Stepanov5","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Stepanov5","text":"Stepanov5(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  5th order method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Stepanov2021Embedded5,     title={Embedded (4, 5) pairs of explicit 7-stage Runge–Kutta methods with FSAL property},     author={Misha Stepanov},     journal={Calcolo},     year={2021},     volume={59}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.SIR54","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.SIR54","text":"SIR54(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  5th order method suited for SIR-type epidemic models.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Kovalnogov2020RungeKuttaPS,     title={Runge–Kutta pairs suited for SIR‐type epidemic models},     author={Vladislav N. Kovalnogov and Theodore E. Simos and Ch. Tsitouras},     journal={Mathematical Methods in the Applied Sciences},     year={2020},     volume={44},     pages={5210 - 5216}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Alshina2","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Alshina2","text":"Alshina2(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  2nd order, 2-stage Method with optimal parameters.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Alshina2008,     doi = {10.1134/s0965542508030068},     url = {https://doi.org/10.1134/s0965542508030068},     year = {2008},     month = mar,     publisher = {Pleiades Publishing Ltd},     volume = {48},     number = {3},     pages = {395–405},     author = {E. A. Alshina and E. M. Zaks and N. N. Kalitkin},     title = {Optimal first- to sixth-order accurate Runge-Kutta schemes},     journal = {Computational Mathematics and Mathematical Physics}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Alshina3","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Alshina3","text":"Alshina3(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  3rd order, 3-stage Method with optimal parameters.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Alshina2008,     doi = {10.1134/s0965542508030068},     url = {https://doi.org/10.1134/s0965542508030068},     year = {2008},     month = mar,     publisher = {Pleiades Publishing Ltd},     volume = {48},     number = {3},     pages = {395–405},     author = {E. A. Alshina and E. M. Zaks and N. N. Kalitkin},     title = {Optimal first- to sixth-order accurate Runge-Kutta schemes},     journal = {Computational Mathematics and Mathematical Physics}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowOrderRK/#OrdinaryDiffEqLowOrderRK.Alshina6","page":"OrdinaryDiffEqLowOrderRK","title":"OrdinaryDiffEqLowOrderRK.Alshina6","text":"Alshina6(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  6th order, 7-stage Method with optimal parameters.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{Alshina2008,     doi = {10.1134/s0965542508030068},     url = {https://doi.org/10.1134/s0965542508030068},     year = {2008},     month = mar,     publisher = {Pleiades Publishing Ltd},     volume = {48},     number = {3},     pages = {395–405},     author = {E. A. Alshina and E. M. Zaks and N. N. Kalitkin},     title = {Optimal first- to sixth-order accurate Runge-Kutta schemes},     journal = {Computational Mathematics and Mathematical Physics}     }\n\n\n\n\n\n","category":"type"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK","text":"","category":"section"},{"location":"semilinear/ExponentialRK/","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK","text":"Methods for semi-linear differential equations.","category":"page"},{"location":"semilinear/ExponentialRK/#Installation","page":"OrdinaryDiffEqExponentialRK","title":"Installation","text":"","category":"section"},{"location":"semilinear/ExponentialRK/","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK","text":"To be able to access the solvers in OrdinaryDiffEqLinear, you must first install them use the Julia package manager:","category":"page"},{"location":"semilinear/ExponentialRK/","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK","text":"using Pkg\nPkg.add(\"OrdinaryDiffEqExponentialRK\")","category":"page"},{"location":"semilinear/ExponentialRK/","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK","text":"This will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.","category":"page"},{"location":"semilinear/ExponentialRK/#Example-usage","page":"OrdinaryDiffEqExponentialRK","title":"Example usage","text":"","category":"section"},{"location":"semilinear/ExponentialRK/","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK","text":"using OrdinaryDiffEqExponentialRK, SciMLOperators\nA = [2.0 -1.0; -1.0 2.0]\nlinnonlin_f1 = MatrixOperator(A)\nlinnonlin_f2 = (du, u, p, t) -> du .= 1.01 .* u\nlinnonlin_fun_iip = SplitFunction(linnonlin_f1, linnonlin_f2)\ntspan = (0.0, 1.0)\nu0 = [0.1, 0.1]\nprob = SplitODEProblem(linnonlin_fun_iip, u0, tspan)\nsol = solve(prob, ETDRK4(), dt = 1 / 4)","category":"page"},{"location":"semilinear/ExponentialRK/#Full-list-of-solvers","page":"OrdinaryDiffEqExponentialRK","title":"Full list of solvers","text":"","category":"section"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK.LawsonEuler","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.LawsonEuler","text":"LawsonEuler(; krylov = false,\n              m = 30,\n              iop = 0)\n\nSemilinear ODE solver First order exponential Euler scheme.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK.NorsettEuler","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.NorsettEuler","text":"NorsettEuler(; krylov = false,\n               m = 30,\n               iop = 0)\n\nSemilinear ODE solver First order exponential-RK scheme. Alias: ETD1\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETD2","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETD2","text":"ETD2: Exponential Runge-Kutta Method Second order Exponential Time Differencing method (in development).\n\n\n\n\n\n","category":"type"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETDRK2","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETDRK2","text":"ETDRK2(; krylov = false,\n         m = 30,\n         iop = 0)\n\nSemilinear ODE solver 2nd order exponential-RK scheme.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETDRK3","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETDRK3","text":"ETDRK3(; krylov = false,\n         m = 30,\n         iop = 0)\n\nSemilinear ODE solver 3rd order exponential-RK scheme.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK.ETDRK4","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.ETDRK4","text":"ETDRK4(; krylov = false,\n         m = 30,\n         iop = 0)\n\nSemilinear ODE solver 4th order exponential-RK scheme\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"semilinear/ExponentialRK/#OrdinaryDiffEqExponentialRK.HochOst4","page":"OrdinaryDiffEqExponentialRK","title":"OrdinaryDiffEqExponentialRK.HochOst4","text":"HochOst4(; krylov = false,\n           m = 30,\n           iop = 0)\n\nSemilinear ODE solver 4th order exponential-RK scheme with stiff order 4.\n\nKeyword Arguments\n\nkrylov: Determines whether Krylov approximation or operator caching is used, the latter only available for semilinear problems.   krylov=true is much faster for larger systems and is thus recommended whenever there are >100 ODEs.\nm: Controls the size of Krylov subspace.\niop: If not zero, determines the length of the incomplete orthogonalization procedure (IOP).       Note that if the linear operator/Jacobian is hermitian, then the Lanczos algorithm will always be used and the IOP setting is ignored.\n\nReferences\n\nHochbruck, Marlis, and Alexander Ostermann. “Exponential Integrators.” Acta   Numerica 19 (2010): 209–286. doi:10.1017/S0962492910000048.\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton","text":"","category":"section"},{"location":"explicit/AdamsBashforthMoulton/","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton","text":"Multistep methods, useful for integrating a very expensive to evaluate non-stiff system of differential equations.","category":"page"},{"location":"explicit/AdamsBashforthMoulton/","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqAdamsBashforthMoulton\", \"VCABM\")","category":"page"},{"location":"explicit/AdamsBashforthMoulton/#Full-list-of-solvers","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#Explicit-Multistep-Methods","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Explicit Multistep Methods","text":"","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.AB3","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.AB3","text":"AB3(; thread = OrdinaryDiffEq.False())\n\nAdams-Bashforth Explicit Method The 3-step third order multistep method.         Ralston's Second Order Method is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.AB4","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.AB4","text":"AB4(; thread = OrdinaryDiffEq.False())\n\nAdams-Bashforth Explicit Method The 4-step fourth order multistep method.     Runge-Kutta method of order 4 is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.AB5","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.AB5","text":"AB5(; thread = OrdinaryDiffEq.False())\n\nAdams-Bashforth Explicit Method The 5-step fifth order multistep method.     Ralston's 3rd order Runge-Kutta method is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#Predictor-Corrector-Methods","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"Predictor-Corrector Methods","text":"","category":"section"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.ABM32","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.ABM32","text":"ABM32(; thread = OrdinaryDiffEq.False())\n\nAdams-Bashforth Explicit Method It is third order method.     In ABM32, AB3 works as predictor and Adams Moulton 2-steps method works as Corrector.     Ralston's Second Order Method is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.ABM43","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.ABM43","text":"ABM43(; thread = OrdinaryDiffEq.False())\n\nAdams-Bashforth Explicit Method It is fourth order method.     In ABM43, AB4 works as predictor and Adams Moulton 3-steps method works as Corrector.     Runge-Kutta method of order 4 is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.ABM54","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.ABM54","text":"ABM54(; thread = OrdinaryDiffEq.False())\n\nAdams-Bashforth Explicit Method It is fifth order method.     In ABM54, AB5 works as predictor and Adams Moulton 4-steps method works as Corrector.     Runge-Kutta method of order 4 is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.VCAB3","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.VCAB3","text":"VCAB3(; thread = OrdinaryDiffEq.False())\n\nAdams explicit Method The 3rd order Adams method.     Bogacki-Shampine 3/2 method is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.VCAB4","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.VCAB4","text":"VCAB4(; thread = OrdinaryDiffEq.False())\n\nAdams explicit Method The 4th order Adams method.     Runge-Kutta 4 is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.VCAB5","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.VCAB5","text":"VCAB5(; thread = OrdinaryDiffEq.False())\n\nAdams explicit Method The 5th order Adams method.     Runge-Kutta 4 is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.VCABM3","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.VCABM3","text":"VCABM3(; thread = OrdinaryDiffEq.False())\n\nAdams explicit Method The 3rd order Adams-Moulton method.     Bogacki-Shampine 3/2 method is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.VCABM4","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.VCABM4","text":"VCABM4(; thread = OrdinaryDiffEq.False())\n\nAdams explicit Method The 4th order Adams-Moulton method.     Runge-Kutta 4 is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.VCABM5","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.VCABM5","text":"VCABM5(; thread = OrdinaryDiffEq.False())\n\nAdams explicit Method The 5th order Adams-Moulton method.     Runge-Kutta 4 is used to calculate starting values.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"explicit/AdamsBashforthMoulton/#OrdinaryDiffEqAdamsBashforthMoulton.VCABM","page":"OrdinaryDiffEqAdamsBashforthMoulton","title":"OrdinaryDiffEqAdamsBashforthMoulton.VCABM","text":"VCABM(; thread = OrdinaryDiffEq.False())\n\nadaptive order Adams explicit Method An adaptive order adaptive time Adams Moulton method.     It uses an order adaptivity algorithm is derived from Shampine's DDEABM.\n\nKeyword Arguments\n\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nE. Hairer, S. P. Norsett, G. Wanner, Solving Ordinary Differential Equations I, Nonstiff Problems. Computational Mathematics (2nd revised ed.), Springer (1996) doi: https://doi.org/10.1007/978-3-540-78862-1\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN","text":"","category":"section"},{"location":"dynamicalodeexplicit/RKN/","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN","text":"Second order solvers.","category":"page"},{"location":"dynamicalodeexplicit/RKN/","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN","text":"To be able to access the solvers in OrdinaryDiffEqRKN, you must first install them use the Julia package manager:","category":"page"},{"location":"dynamicalodeexplicit/RKN/","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN","text":"using Pkg\nPkg.add(\"OrdinaryDiffEqRKN\")","category":"page"},{"location":"dynamicalodeexplicit/RKN/","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN","text":"This will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.","category":"page"},{"location":"dynamicalodeexplicit/RKN/#Example-usage","page":"OrdinaryDiffEqRKN","title":"Example usage","text":"","category":"section"},{"location":"dynamicalodeexplicit/RKN/","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN","text":"using OrdinaryDiffEqOrdinaryDiffEqRKN\nfunction HH_acceleration!(dv, v, u, p, t)\n    x, y = u\n    dx, dy = dv\n    dv[1] = -x - 2x * y\n    dv[2] = y^2 - y - x^2\nend\ninitial_positions = [0.0, 0.1]\ninitial_velocities = [0.5, 0.0]\ntspan = (0.0, 1.0)\nprob = SecondOrderODEProblem(HH_acceleration!, initial_velocities, initial_positions, tspan)\nsol = solve(prob, Nystrom4(), dt = 1 / 10)","category":"page"},{"location":"dynamicalodeexplicit/RKN/#Full-list-of-solvers","page":"OrdinaryDiffEqRKN","title":"Full list of solvers","text":"","category":"section"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.IRKN3","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.IRKN3","text":"IRKN3()\n\nImproved Runge-Kutta-Nyström method Method of order three, which minimizes the amount of evaluated functions in each step. Fixed time steps only. Second order ODE should not depend on the first derivative.\n\nKeyword Arguments\n\nReferences\n\n@article{rabiei2012numerical,     title={Numerical Solution of Second-Order Ordinary Differential Equations by Improved Runge-Kutta Nystrom Method},     author={Rabiei, Faranak and Ismail, Fudziah and Norazak, S and Emadi, Saeid},     publisher={Citeseer}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.IRKN4","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.IRKN4","text":"IRKN4()\n\nImproved Runge-Kutta-Nyström method Improves Runge-Kutta-Nyström method of order four,     which minimizes the amount of evaluated functions in each step.     Fixed time steps only.     Second order ODE should not be dependent on the first derivative.     Recommended for smooth problems with expensive functions to evaluate.\n\nKeyword Arguments\n\nReferences\n\n@article{rabiei2012numerical,     title={Numerical Solution of Second-Order Ordinary Differential Equations by Improved Runge-Kutta Nystrom Method},     author={Rabiei, Faranak and Ismail, Fudziah and Norazak, S and Emadi, Saeid},     publisher={Citeseer}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.Nystrom4","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.Nystrom4","text":"Nystrom4()\n\nImproved Runge-Kutta-Nyström method A 4th order explicit method which can be applied directly on second order ODEs. Can only be used with fixed time steps. In case the ODE Problem is not dependent on the first derivative consider using Nystrom4VelocityIndependent to increase performance.\n\nKeyword Arguments\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I.     Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics,     Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.Nystrom4VelocityIndependent","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.Nystrom4VelocityIndependent","text":"Nystrom4VelocityIndependent()\n\nImproved Runge-Kutta-Nyström method A 4th order explicit method. Used directly on second order ODEs, where the acceleration is independent from velocity (ODE Problem is not dependent on the first derivative).\n\nKeyword Arguments\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I.     Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics,     Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.Nystrom5VelocityIndependent","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.Nystrom5VelocityIndependent","text":"Nystrom5VelocityIndependent()\n\nImproved Runge-Kutta-Nyström method A 5th order explicit method. Used directly on second order ODEs, where the acceleration is independent from velocity (ODE Problem is not dependent on the first derivative).\n\nKeyword Arguments\n\nReferences\n\nE. Hairer, S.P. Norsett, G. Wanner, (1993) Solving Ordinary Differential Equations I.     Nonstiff Problems. 2nd Edition. Springer Series in Computational Mathematics,     Springer-Verlag.\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.FineRKN4","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.FineRKN4","text":"FineRKN4()\n\nImproved Runge-Kutta-Nyström method A 4th order explicit method which can be applied directly to second order ODEs. In particular, this method allows the acceleration equation to depend on the velocity.\n\nKeyword Arguments\n\nReferences\n\n@article{fine1987low,     title={Low order practical {R}unge-{K}utta-{N}ystr{\"o}m methods},     author={Fine, Jerry Michael},     journal={Computing},     volume={38},     number={4},     pages={281–297},     year={1987},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.FineRKN5","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.FineRKN5","text":"FineRKN5()\n\nImproved Runge-Kutta-Nyström method A 5th order explicit method which can be applied directly to second order ODEs. In particular, this method allows the acceleration equation to depend on the velocity.\n\nKeyword Arguments\n\nReferences\n\n@article{fine1987low,     title={Low order practical {R}unge-{K}utta-{N}ystr{\"o}m methods},     author={Fine, Jerry Michael},     journal={Computing},     volume={38},     number={4},     pages={281–297},     year={1987},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.DPRKN4","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.DPRKN4","text":"DPRKN4()\n\nImproved Runge-Kutta-Nyström method 4th order explicit method.     The second order ODE should not depend on the first derivative.\n\nKeyword Arguments\n\nReferences\n\n@article{Dormand1987FamiliesOR,     title={Families of Runge-Kutta-Nystrom Formulae},     author={J. R. Dormand and Moawwad E. A. El-Mikkawy and P. J. Prince},     journal={Ima Journal of Numerical Analysis},     year={1987},     volume={7},     pages={235-250}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.DPRKN5","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.DPRKN5","text":"DPRKN5()\n\nImproved Runge-Kutta-Nyström method 5th order explicit method.     The second order ODE should not depend on the first derivative.\n\nKeyword Arguments\n\nReferences\n\n@article{Bettis1973ARN,     title={A Runge-Kutta Nystrom algorithm},     author={Dale G. Bettis},     journal={Celestial mechanics},     year={1973},     volume={8},     pages={229-233},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.DPRKN6","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.DPRKN6","text":"DPRKN6()\n\nImproved Runge-Kutta-Nyström method 6th order explicit method. The second order ODE should not depend on the first derivative. Free 6th order interpolant\n\nKeyword Arguments\n\nReferences\n\n@article{Dormand1987FamiliesOR,     title={Families of Runge-Kutta-Nystrom Formulae},     author={J. R. Dormand and Moawwad E. A. El-Mikkawy and P. J. Prince},     journal={Ima Journal of Numerical Analysis},     year={1987},     volume={7},     pages={235-250}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.DPRKN6FM","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.DPRKN6FM","text":"DPRKN6FM()\n\nImproved Runge-Kutta-Nyström method 6th order explicit method.     The second order ODE should not depend on the first derivative.     Compared to DPRKN6, this method has smaller truncation error coefficients     which leads to performance gain when only the main solution points are considered.\n\nKeyword Arguments\n\nReferences\n\n@article{Dormand1987FamiliesOR,     title={Families of Runge-Kutta-Nystrom Formulae},     author={J. R. Dormand and Moawwad E. A. El-Mikkawy and P. J. Prince},     journal={Ima Journal of Numerical Analysis},     year={1987},     volume={7},     pages={235-250}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.DPRKN8","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.DPRKN8","text":"DPRKN8()\n\nImproved Runge-Kutta-Nyström method 8th order explicit method.     The second order ODE should not depend on the first derivative.     Not as efficient as DPRKN12 when high accuracy is needed,     however this solver is competitive with DPRKN6 at lax tolerances and,     depending on the problem, might be a good option between performance and accuracy.\n\nKeyword Arguments\n\nReferences\n\n@article{dormand1987high,     title={High-order embedded Runge-Kutta-Nystrom formulae},     author={Dormand, JR and El-Mikkawy, MEA and Prince, PJ},     journal={IMA Journal of Numerical Analysis},     volume={7},     number={4},     pages={423–430},     year={1987},     publisher={Oxford University Press}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.DPRKN12","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.DPRKN12","text":"DPRKN12()\n\nImproved Runge-Kutta-Nyström method 12th order explicit method.     The second order ODE should not depend on the first derivative.     Most efficient when high accuracy is needed.\n\nKeyword Arguments\n\nReferences\n\n@article{dormand1987high,     title={High-order embedded Runge-Kutta-Nystrom formulae},     author={Dormand, JR and El-Mikkawy, MEA and Prince, PJ},     journal={IMA Journal of Numerical Analysis},     volume={7},     number={4},     pages={423–430},     year={1987},     publisher={Oxford University Press}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.ERKN4","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.ERKN4","text":"ERKN4()\n\nImproved Runge-Kutta-Nyström method Embedded 4(3) pair of explicit methods.     Integrates the periodic properties of the harmonic oscillator exactly.     The second order ODE should not depend on the first derivative.     Uses adaptive step size control. This method is extra efficient on periodic problems.\n\nKeyword Arguments\n\nReferences\n\n@article{demba2017embedded,     title={An Embedded 4 (3) Pair of Explicit Trigonometrically-Fitted Runge-Kutta-Nystr{\"o}m Method for Solving Periodic Initial Value Problems},     author={Demba, MA and Senu, N and Ismail, F},     journal={Applied Mathematical Sciences},     volume={11},     number={17},     pages={819–838},     year={2017}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.ERKN5","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.ERKN5","text":"ERKN5()\n\nImproved Runge-Kutta-Nyström method Embedded 5(4) pair of explicit methods.     Integrates the periodic properties of the harmonic oscillator exactly.     The second order ODE should not depend on the first derivative.     Uses adaptive step size control. This method is extra efficient on periodic problems.\n\nKeyword Arguments\n\nReferences\n\n@article{demba20165,     title={A 5 (4) Embedded Pair of Explicit Trigonometrically-Fitted Runge–Kutta–Nystr{\"o}m Methods for the Numerical Solution of Oscillatory Initial Value     Problems},     author={Demba, Musa A and Senu, Norazak and Ismail, Fudziah},     journal={Mathematical and Computational Applications},     volume={21},     number={4},     pages={46},     year={2016},     publisher={Multidisciplinary Digital Publishing Institute}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.ERKN7","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.ERKN7","text":"ERKN7()\n\nImproved Runge-Kutta-Nyström method Embedded pair of explicit methods.     Integrates the periodic properties of the harmonic oscillator exactly.     The second order ODE should not depend on the first derivative.     Uses adaptive step size control. This method is extra efficient on periodic problems.\n\nKeyword Arguments\n\nReferences\n\n@article{SimosOnHO,     title={On high order Runge-Kutta-Nystr{\"o}m pairs},     author={Theodore E. Simos and Ch. Tsitouras},     journal={J. Comput. Appl. Math.},     volume={400},     pages={113753}}\n\n\n\n\n\n","category":"type"},{"location":"dynamicalodeexplicit/RKN/#OrdinaryDiffEqRKN.RKN4","page":"OrdinaryDiffEqRKN","title":"OrdinaryDiffEqRKN.RKN4","text":"RKN4()\n\nImproved Runge-Kutta-Nyström method 3 stage fourth order method to solve second order linear inhomogeneous IVPs. Does not include an adaptive method. Solves for for d-dimensional differential systems of second order linear inhomogeneous equations.\n\nwarning: Warning\n\n\nThis method is only fourth order for these systems, the method is second order otherwise!\n\nKeyword Arguments\n\nReferences\n\n@article{MONTIJANO2024115533,     title = {Explicit Runge–Kutta–Nyström methods for the numerical solution of second order linear inhomogeneous IVPs},     author = {J.I. Montijano and L. Rández and M. Calvo},     journal = {Journal of Computational and Applied Mathematics},     volume = {438},     pages = {115533},     year = {2024},}\n\n\n\n\n\n","category":"type"},{"location":"explicit/QPRK/#OrdinaryDiffEqQPRK","page":"OrdinaryDiffEqQPRK","title":"OrdinaryDiffEqQPRK","text":"","category":"section"},{"location":"explicit/QPRK/","page":"OrdinaryDiffEqQPRK","title":"OrdinaryDiffEqQPRK","text":"Explicit solvers optimized for a certain number of parallel calls of the system of ordinary differential equations f. Particularly good at low tolerances, when using quad-precision arithmetic, Float128.","category":"page"},{"location":"explicit/QPRK/","page":"OrdinaryDiffEqQPRK","title":"OrdinaryDiffEqQPRK","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqQPRK\", \"QPRK98\")","category":"page"},{"location":"explicit/QPRK/#Full-list-of-solvers","page":"OrdinaryDiffEqQPRK","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/QPRK/#OrdinaryDiffEqQPRK.QPRK98","page":"OrdinaryDiffEqQPRK","title":"OrdinaryDiffEqQPRK.QPRK98","text":"QPRK98(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Runge–Kutta pairs of orders 9(8) for use in quadruple precision computations\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nKovalnogov VN, Fedorov RV, Karpukhina TV, Simos TE, Tsitouras C. Runge–Kutta pairs      of orders 9 (8) for use in quadruple precision computations. Numerical Algorithms, 2023.      doi: https://doi.org/10.1007/s11075-023-01632-8\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock","text":"","category":"section"},{"location":"massmatrixdae/Rosenbrock/","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock","text":"Methods for small and medium sized stiff systems of differential equations. At high tolerances, >1e-2, Rosenbrock23 is a good choice. At medium tolerances >1e-8 it is recommended you use Rodas5P or Rodas4P, the former is more efficient, but the latter is more reliable. For larger systems look at multistep methods.","category":"page"},{"location":"massmatrixdae/Rosenbrock/","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock","text":"warn: Warn\nIn order to use OrdinaryDiffEqRosenbrock with DAEs that require a non-trivial consistent initialization, a nonlinear solver is required and thus using OrdinaryDiffEqNonlinearSolve is required or you must pass an initializealg with a valid nlsolve choice.","category":"page"},{"location":"massmatrixdae/Rosenbrock/#Example-usage","page":"OrdinaryDiffEqRosenbrock","title":"Example usage","text":"","category":"section"},{"location":"massmatrixdae/Rosenbrock/","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock","text":"using LinearAlgebra: Diagonal\nfunction rober(du, u, p, t)\n    y₁, y₂, y₃ = u\n    k₁, k₂, k₃ = p\n    du[1] = -k₁ * y₁ + k₃ * y₂ * y₃\n    du[2] = k₁ * y₁ - k₃ * y₂ * y₃ - k₂ * y₂^2\n    du[3] = y₁ + y₂ + y₃ - 1\n    nothing\nend\nM = Diagonal([1.0, 1.0, 0])\nf = ODEFunction(rober, mass_matrix = M)\nprob_mm = ODEProblem(f, [1.0, 0.0, 0.0], (0.0, 1e5), (0.04, 3e7, 1e4))\nsol = solve(prob_mm, Rodas5(), reltol = 1e-8, abstol = 1e-8)","category":"page"},{"location":"massmatrixdae/Rosenbrock/#Full-list-of-solvers","page":"OrdinaryDiffEqRosenbrock","title":"Full list of solvers","text":"","category":"section"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rosenbrock23-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rosenbrock23","text":"Rosenbrock23(; chunk_size = Val{0}(),\n               standardtag = Val{true}(),\n               autodiff = AutoForwardDiff(),\n               concrete_jac = nothing,\n               diff_type = Val{:forward}(),\n               linsolve = nothing,\n               precs = DEFAULT_PRECS,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  An Order 2/3 L-Stable Rosenbrock-W method which is good for very stiff equations with oscillations at low tolerances. 2nd order stiff-aware interpolation.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rosenbrock23(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nShampine L.F. and Reichelt M., (1997) The MATLAB ODE Suite, SIAM Journal of\n\nScientific Computing, 18 (1), pp. 1-22.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rosenbrock32-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rosenbrock32","text":"Rosenbrock32(; chunk_size = Val{0}(),\n               standardtag = Val{true}(),\n               autodiff = AutoForwardDiff(),\n               concrete_jac = nothing,\n               diff_type = Val{:forward}(),\n               linsolve = nothing,\n               precs = DEFAULT_PRECS,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  An Order 3/2 A-Stable Rosenbrock-W method which is good for mildly stiff equations without oscillations at low tolerances. Note that this method is prone to instability in the presence of oscillations, so use with caution. 2nd order stiff-aware interpolation.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rosenbrock32(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nShampine L.F. and Reichelt M., (1997) The MATLAB ODE Suite, SIAM Journal of\n\nScientific Computing, 18 (1), pp. 1-22.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3P-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3P","text":"ROS3P(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n            ForwardDiff default function-specific tags. For more information, see\n            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n            Defaults to `Val{true}()`.\n        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n            to specify whether to use automatic differentiation via\n            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n            `nothing`, which means it will be chosen true/false depending on circumstances\n            of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n          `ROS3P(linsolve = KLUFactorization()`).\n           When `nothing` is passed, uses `DefaultLinearSolver`.\n        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n          can be used as a left or right preconditioner.\n          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n          function where the arguments are defined as:\n            - `W`: the current Jacobian of the nonlinear system. Specified as either\n                ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                representation of the operator. Users can construct the W-matrix on demand\n                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                the `jac_prototype`.\n            - `du`: the current ODE derivative\n            - `u`: the current ODE state\n            - `p`: the ODE parameters\n            - `t`: the current ODE time\n            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                the last call to `precs`. It is recommended that this is checked to only\n                update the preconditioner when `newW == true`.\n            - `Plprev`: the previous `Pl`.\n            - `Prprev`: the previous `Pr`.\n            - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                Solver-dependent and subject to change.\n          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n          To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n          which is not used. Additionally, `precs` must supply the dispatch:\n          ```julia\n          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n          ```\n          which is used in the solver setup phase to construct the integrator\n          type with the preconditioners `(Pl,Pr)`.\n          The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n          is defined as:\n          ```julia\n          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n          ```\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method. Keeps high accuracy on discretizations of nonlinear parabolic PDEs.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nLang, J. & Verwer, ROS3P—An Accurate Third-Order Rosenbrock Solver Designed for Parabolic Problems J. BIT Numerical Mathematics (2001) 41: 731. doi:10.1023/A:1021900219772\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas3-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas3","text":"Rodas3(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Rodas3(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSandu, Verwer, Van Loon, Carmichael, Potra, Dabdub, Seinfeld, Benchmarking stiff ode solvers for atmospheric chemistry problems-I.    implicit vs explicit, Atmospheric Environment, 31(19), 3151-3166, 1997.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas23W-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas23W","text":"Rodas23W(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  An Order 2/3 L-Stable Rosenbrock-W method for stiff ODEs and DAEs in mass matrix form. 2nd order stiff-aware interpolation and additional error test for interpolation.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas23W(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G., Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024 https://github.com/hbrs-cse/RosenbrockMethods/blob/main/paper/JuliaPaper.pdf\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas3P-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas3P","text":"Rodas3P(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `Rodas3P(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant and additional error test for interpolation. Keeps accuracy on discretizations of linear parabolic PDEs.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G., Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024 https://github.com/hbrs-cse/RosenbrockMethods/blob/main/paper/JuliaPaper.pdf\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas4-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas4","text":"Rodas4(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Rodas4(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 4th order L-stable Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas42-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas42","text":"Rodas42(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `Rodas42(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas4P-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas4P","text":"Rodas4P(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `Rodas4P(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems (as opposed to lower if not corrected).\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach, G., Rentrop, P., An adaptive method of lines approach for modelling flow and transport in rivers.    Adaptive method of lines , Wouver, A. Vande, Sauces, Ph., Schiesser, W.E. (ed.),S. 181-205,Chapman & Hall/CRC, 2001,\nSteinebach, G., Oder-reduction of ROW-methods for DAEs and method of lines  applications.    Preprint-Nr. 1741, FB Mathematik, TH Darmstadt, 1995.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas4P2-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas4P2","text":"Rodas4P2(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems. It is an improvement of Roadas4P and in case of inexact Jacobians a second order W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas4P2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G., Improvement of Rosenbrock-Wanner Method RODASP, In: Reis T., Grundel S., Schöps S. (eds)    Progress in Differential-Algebraic Equations II. Differential-Algebraic Equations Forum. Springer, Cham., 165-184, 2020.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5","text":"Rodas5(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Rodas5(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 5th order A-stable stiffly stable Rosenbrock method with a stiff-aware 4th order interpolant.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nDi Marzo G. RODAS5(4) – Méthodes de Rosenbrock d’ordre 5(4) adaptées aux problemes différentiels-algébriques. MSc mathematics thesis, Faculty of Science, University of Geneva, Switzerland.\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5P-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5P","text":"Rodas5P(; chunk_size = Val{0}(),\n          standardtag = Val{true}(),\n          autodiff = AutoForwardDiff(),\n          concrete_jac = nothing,\n          diff_type = Val{:forward}(),\n          linsolve = nothing,\n          precs = DEFAULT_PRECS,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 5th order A-stable stiffly stable Rosenbrock method with a stiff-aware 4th order interpolant. Has improved stability in the adaptive time stepping embedding.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas5P(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G. Construction of Rosenbrock–Wanner method Rodas5P and numerical benchmarks within the Julia Differential Equations package. In: BIT Numerical Mathematics, 63(2), 2023\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5Pe-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5Pe","text":"Rodas5Pe(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  Variant of Ropdas5P with modified embedded scheme.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas5Pe(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G. Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024 https://github.com/hbrs-cse/RosenbrockMethods/blob/main/paper/JuliaPaper.pdf\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Rodas5Pr-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Rodas5Pr","text":"Rodas5Pr(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  Variant of Ropdas5P with additional residual control.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Rodas5Pr(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nSteinebach G. Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024 https://github.com/hbrs-cse/RosenbrockMethods/blob/main/paper/JuliaPaper.pdf\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.RosenbrockW6S4OS-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.RosenbrockW6S4OS","text":"RosenbrockW6S4OS(; chunk_size = Val{0}(),\n                   standardtag = Val{true}(),\n                   autodiff = AutoForwardDiff(),\n                   concrete_jac = nothing,\n                   diff_type = Val{:forward}(),\n                   linsolve = nothing,\n                   precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method (fixed step only).\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify RosenbrockW6S4OS(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nhttps://doi.org/10.1016/j.cam.2009.09.017\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS2-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS2","text":"ROS2(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n           ForwardDiff default function-specific tags. For more information, see\n           [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n           Defaults to `Val{true}()`.\n       - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n           to specify whether to use automatic differentiation via\n           [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n           differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n           Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n           `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n           To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n           `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n       - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n           `nothing`, which means it will be chosen true/false depending on circumstances\n           of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n       - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n         For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n         `ROS2(linsolve = KLUFactorization()`).\n          When `nothing` is passed, uses `DefaultLinearSolver`.\n       - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n         can be used as a left or right preconditioner.\n         Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n         function where the arguments are defined as:\n           - `W`: the current Jacobian of the nonlinear system. Specified as either\n               ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n               commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n               representation of the operator. Users can construct the W-matrix on demand\n               by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n               the `jac_prototype`.\n           - `du`: the current ODE derivative\n           - `u`: the current ODE state\n           - `p`: the ODE parameters\n           - `t`: the current ODE time\n           - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n               the last call to `precs`. It is recommended that this is checked to only\n               update the preconditioner when `newW == true`.\n           - `Plprev`: the previous `Pl`.\n           - `Prprev`: the previous `Pr`.\n           - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n               Solver-dependent and subject to change.\n         The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n         To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n         which is not used. Additionally, `precs` must supply the dispatch:\n         ```julia\n         Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n         ```\n         which is used in the solver setup phase to construct the integrator\n         type with the preconditioners `(Pl,Pr)`.\n         The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n         is defined as:\n         ```julia\n         DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n         ```)\n\nRosenbrock-Wanner Method.  A 2nd order L-stable Rosenbrock method with 2 internal stages.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nJ. G. Verwer et al. (1999): A second-order Rosenbrock method applied to photochemical dispersion problems https://doi.org/10.1137/S1064827597326651\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS2PR-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS2PR","text":"ROS2PR(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `ROS2PR(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```)\n\nRosenbrock-Wanner Method.  2nd order stiffly accurate Rosenbrock method with 3 internal stages with (Rinf=0). For problems with medium stiffness the convergence behaviour is very poor and it is recommended to use ROS2S instead.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS2S-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS2S","text":"ROS2S(; chunk_size = Val{0}(),\n        standardtag = Val{true}(),\n        autodiff = AutoForwardDiff(),\n        concrete_jac = nothing,\n        diff_type = Val{:forward}(),\n        linsolve = nothing,\n        precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  2nd order stiffly accurate Rosenbrock-Wanner W-method with 3 internal stages with B_PR consistent of order 2 with (Rinf=0).\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS2S(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3","text":"ROS3(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n           ForwardDiff default function-specific tags. For more information, see\n           [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n           Defaults to `Val{true}()`.\n       - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n           to specify whether to use automatic differentiation via\n           [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n           differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n           Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n           `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n           To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n           `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n       - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n           `nothing`, which means it will be chosen true/false depending on circumstances\n           of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n       - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n         For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n         `ROS3(linsolve = KLUFactorization()`).\n          When `nothing` is passed, uses `DefaultLinearSolver`.\n       - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n         can be used as a left or right preconditioner.\n         Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n         function where the arguments are defined as:\n           - `W`: the current Jacobian of the nonlinear system. Specified as either\n               ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n               commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n               representation of the operator. Users can construct the W-matrix on demand\n               by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n               the `jac_prototype`.\n           - `du`: the current ODE derivative\n           - `u`: the current ODE state\n           - `p`: the ODE parameters\n           - `t`: the current ODE time\n           - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n               the last call to `precs`. It is recommended that this is checked to only\n               update the preconditioner when `newW == true`.\n           - `Plprev`: the previous `Pl`.\n           - `Prprev`: the previous `Pr`.\n           - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n               Solver-dependent and subject to change.\n         The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n         To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n         which is not used. Additionally, `precs` must supply the dispatch:\n         ```julia\n         Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n         ```\n         which is used in the solver setup phase to construct the integrator\n         type with the preconditioners `(Pl,Pr)`.\n         The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n         is defined as:\n         ```julia\n         DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n         ```)\n\nRosenbrock-Wanner Method.  3rd order L-stable Rosenbrock method with 3 internal stages with an embedded strongly A-stable 2nd order method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3PR-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3PR","text":"ROS3PR(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `ROS3PR(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```)\n\nRosenbrock-Wanner Method.  3nd order stiffly accurate Rosenbrock method with 3 internal stages with B_PR consistent of order 3, which is strongly A-stable with Rinf~=-0.73.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Scholz4_7-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Scholz4_7","text":"Scholz4_7(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n                ForwardDiff default function-specific tags. For more information, see\n                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n                Defaults to `Val{true}()`.\n            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n                to specify whether to use automatic differentiation via\n                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n                `nothing`, which means it will be chosen true/false depending on circumstances\n                of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n              `Scholz4_7(linsolve = KLUFactorization()`).\n               When `nothing` is passed, uses `DefaultLinearSolver`.\n            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n              can be used as a left or right preconditioner.\n              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n              function where the arguments are defined as:\n                - `W`: the current Jacobian of the nonlinear system. Specified as either\n                    ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                    representation of the operator. Users can construct the W-matrix on demand\n                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                    the `jac_prototype`.\n                - `du`: the current ODE derivative\n                - `u`: the current ODE state\n                - `p`: the ODE parameters\n                - `t`: the current ODE time\n                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                    the last call to `precs`. It is recommended that this is checked to only\n                    update the preconditioner when `newW == true`.\n                - `Plprev`: the previous `Pl`.\n                - `Prprev`: the previous `Pr`.\n                - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                    Solver-dependent and subject to change.\n              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n              To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n              which is not used. Additionally, `precs` must supply the dispatch:\n              ```julia\n              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n              ```\n              which is used in the solver setup phase to construct the integrator\n              type with the preconditioners `(Pl,Pr)`.\n              The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n              is defined as:\n              ```julia\n              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n              ```)\n\nRosenbrock-Wanner Method.  3nd order stiffly accurate Rosenbrock method with 3 internal stages with B_PR consistent of order 3, which is strongly A-stable with Rinf~=-0.73. Convergence with order 4 for the stiff case, but has a poor accuracy.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW1a-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW1a","text":"ROS34PW1a(; chunk_size = Val{0}(),\n            standardtag = Val{true}(),\n            autodiff = AutoForwardDiff(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW1a(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\n@article{rang2005new,   title={New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1},   author={Rang, Joachim and Angermann, L},   journal={BIT Numerical Mathematics},   volume={45},   pages={761–787},   year={2005},   publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW1b-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW1b","text":"ROS34PW1b(; chunk_size = Val{0}(),\n            standardtag = Val{true}(),\n            autodiff = AutoForwardDiff(),\n            concrete_jac = nothing,\n            diff_type = Val{:forward}(),\n            linsolve = nothing,\n            precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW1b(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\n@article{rang2005new,   title={New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1},   author={Rang, Joachim and Angermann, L},   journal={BIT Numerical Mathematics},   volume={45},   pages={761–787},   year={2005},   publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW2-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW2","text":"ROS34PW2(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order stiffy accurate Rosenbrock-W method for PDAEs.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW2(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\n@article{rang2005new,   title={New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1},   author={Rang, Joachim and Angermann, L},   journal={BIT Numerical Mathematics},   volume={45},   pages={761–787},   year={2005},   publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PW3-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PW3","text":"ROS34PW3(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order strongly A-stable (Rinf~0.63) Rosenbrock-W method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PW3(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\n@article{rang2005new,   title={New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1},   author={Rang, Joachim and Angermann, L},   journal={BIT Numerical Mathematics},   volume={45},   pages={761–787},   year={2005},   publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS34PRw-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS34PRw","text":"ROS34PRw(; chunk_size = Val{0}(),\n           standardtag = Val{true}(),\n           autodiff = AutoForwardDiff(),\n           concrete_jac = nothing,\n           diff_type = Val{:forward}(),\n           linsolve = nothing,\n           precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  3rd order stiffly accurate Rosenbrock-Wanner W-method with 4 internal stages, B_PR consistent of order 2. The order of convergence decreases if medium stiff problems are considered.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROS34PRw(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nJoachim Rang, Improved traditional Rosenbrock–Wanner methods for stiff ODEs and DAEs, Journal of Computational and Applied Mathematics, https://doi.org/10.1016/j.cam.2015.03.010\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3PRL-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3PRL","text":"ROS3PRL(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n              ForwardDiff default function-specific tags. For more information, see\n              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n              Defaults to `Val{true}()`.\n          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n              to specify whether to use automatic differentiation via\n              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n              `nothing`, which means it will be chosen true/false depending on circumstances\n              of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n            `ROS3PRL(linsolve = KLUFactorization()`).\n             When `nothing` is passed, uses `DefaultLinearSolver`.\n          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n            can be used as a left or right preconditioner.\n            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n            function where the arguments are defined as:\n              - `W`: the current Jacobian of the nonlinear system. Specified as either\n                  ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                  representation of the operator. Users can construct the W-matrix on demand\n                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                  the `jac_prototype`.\n              - `du`: the current ODE derivative\n              - `u`: the current ODE state\n              - `p`: the ODE parameters\n              - `t`: the current ODE time\n              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                  the last call to `precs`. It is recommended that this is checked to only\n                  update the preconditioner when `newW == true`.\n              - `Plprev`: the previous `Pl`.\n              - `Prprev`: the previous `Pr`.\n              - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                  Solver-dependent and subject to change.\n            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n            To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n            which is not used. Additionally, `precs` must supply the dispatch:\n            ```julia\n            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n            ```\n            which is used in the solver setup phase to construct the integrator\n            type with the preconditioners `(Pl,Pr)`.\n            The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n            is defined as:\n            ```julia\n            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n            ```)\n\nRosenbrock-Wanner Method.  3rd order stiffly accurate Rosenbrock method with 4 internal stages, B_PR consistent of order 2 with Rinf=0. The order of convergence decreases if medium stiff problems are considered, but it has good results for very stiff cases.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3PRL2-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROS3PRL2","text":"ROS3PRL2(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n               ForwardDiff default function-specific tags. For more information, see\n               [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n               Defaults to `Val{true}()`.\n           - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n               to specify whether to use automatic differentiation via\n               [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n               differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n               Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n               `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n               To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n               `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n           - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n               `nothing`, which means it will be chosen true/false depending on circumstances\n               of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n           - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n             For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n             `ROS3PRL2(linsolve = KLUFactorization()`).\n              When `nothing` is passed, uses `DefaultLinearSolver`.\n           - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n             can be used as a left or right preconditioner.\n             Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n             function where the arguments are defined as:\n               - `W`: the current Jacobian of the nonlinear system. Specified as either\n                   ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                   commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                   representation of the operator. Users can construct the W-matrix on demand\n                   by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                   the `jac_prototype`.\n               - `du`: the current ODE derivative\n               - `u`: the current ODE state\n               - `p`: the ODE parameters\n               - `t`: the current ODE time\n               - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                   the last call to `precs`. It is recommended that this is checked to only\n                   update the preconditioner when `newW == true`.\n               - `Plprev`: the previous `Pl`.\n               - `Prprev`: the previous `Pr`.\n               - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                   Solver-dependent and subject to change.\n             The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n             To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n             which is not used. Additionally, `precs` must supply the dispatch:\n             ```julia\n             Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n             ```\n             which is used in the solver setup phase to construct the integrator\n             type with the preconditioners `(Pl,Pr)`.\n             The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n             is defined as:\n             ```julia\n             DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n             ```)\n\nRosenbrock-Wanner Method.  3rd order stiffly accurate Rosenbrock method with 4 internal stages, B_PR consistent of order 3. The order of convergence does NOT decreases if medium stiff problems are considered as it does for ROS3PRL.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nRang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROK4a-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.ROK4a","text":"ROK4a(; chunk_size = Val{0}(),\n        standardtag = Val{true}(),\n        autodiff = AutoForwardDiff(),\n        concrete_jac = nothing,\n        diff_type = Val{:forward}(),\n        linsolve = nothing,\n        precs = DEFAULT_PRECS)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  4rd order L-stable Rosenbrock-Krylov method with 4 internal stages, with a 3rd order embedded method which is strongly A-stable with Rinf~=0.55. (when using exact Jacobians)\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify ROK4a(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n\nReferences\n\nTranquilli, Paul and Sandu, Adrian (2014): Rosenbrock–Krylov Methods for Large Systems of Differential Equations https://doi.org/10.1137/130923336\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.RosShamp4-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.RosShamp4","text":"RosShamp4(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n                ForwardDiff default function-specific tags. For more information, see\n                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n                Defaults to `Val{true}()`.\n            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n                to specify whether to use automatic differentiation via\n                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n                `nothing`, which means it will be chosen true/false depending on circumstances\n                of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n              `RosShamp4(linsolve = KLUFactorization()`).\n               When `nothing` is passed, uses `DefaultLinearSolver`.\n            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n              can be used as a left or right preconditioner.\n              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n              function where the arguments are defined as:\n                - `W`: the current Jacobian of the nonlinear system. Specified as either\n                    ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                    representation of the operator. Users can construct the W-matrix on demand\n                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                    the `jac_prototype`.\n                - `du`: the current ODE derivative\n                - `u`: the current ODE state\n                - `p`: the ODE parameters\n                - `t`: the current ODE time\n                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                    the last call to `precs`. It is recommended that this is checked to only\n                    update the preconditioner when `newW == true`.\n                - `Plprev`: the previous `Pl`.\n                - `Prprev`: the previous `Pr`.\n                - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                    Solver-dependent and subject to change.\n              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n              To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n              which is not used. Additionally, `precs` must supply the dispatch:\n              ```julia\n              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n              ```\n              which is used in the solver setup phase to construct the integrator\n              type with the preconditioners `(Pl,Pr)`.\n              The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n              is defined as:\n              ```julia\n              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n              ```)\n\nRosenbrock-Wanner Method.  An A-stable 4th order Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\n\nReferences\n\nL. F. Shampine, Implementation of Rosenbrock Methods, ACM Transactions on Mathematical Software (TOMS), 8: 2, 93-113. doi:10.1145/355993.355994\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Veldd4-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Veldd4","text":"Veldd4(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n             ForwardDiff default function-specific tags. For more information, see\n             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n             Defaults to `Val{true}()`.\n         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n             to specify whether to use automatic differentiation via\n             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n             `nothing`, which means it will be chosen true/false depending on circumstances\n             of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n           `Veldd4(linsolve = KLUFactorization()`).\n            When `nothing` is passed, uses `DefaultLinearSolver`.\n         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n           can be used as a left or right preconditioner.\n           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n           function where the arguments are defined as:\n             - `W`: the current Jacobian of the nonlinear system. Specified as either\n                 ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                 representation of the operator. Users can construct the W-matrix on demand\n                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                 the `jac_prototype`.\n             - `du`: the current ODE derivative\n             - `u`: the current ODE state\n             - `p`: the ODE parameters\n             - `t`: the current ODE time\n             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                 the last call to `precs`. It is recommended that this is checked to only\n                 update the preconditioner when `newW == true`.\n             - `Plprev`: the previous `Pl`.\n             - `Prprev`: the previous `Pr`.\n             - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                 Solver-dependent and subject to change.\n           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n           To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n           which is not used. Additionally, `precs` must supply the dispatch:\n           ```julia\n           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n           ```\n           which is used in the solver setup phase to construct the integrator\n           type with the preconditioners `(Pl,Pr)`.\n           The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n           is defined as:\n           ```julia\n           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n           ```\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 4th order D-stable Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nvan Veldhuizen, D-stability and Kaps-Rentrop-methods, M. Computing (1984) 32: 229. doi:10.1007/BF02243574\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Velds4-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Velds4","text":"Velds4(; chunk_size = Val{0}(),\n         standardtag = Val{true}(),\n         autodiff = AutoForwardDiff(),\n         concrete_jac = nothing,\n         diff_type = Val{:forward}(),\n         linsolve = nothing,\n         precs = DEFAULT_PRECS,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner-W(olfbrandt) Method.  A 4th order A-stable Rosenbrock method.\n\nKeyword Arguments\n\nstandardtag: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   this blog post.   Defaults to Val{true}().\nautodiff: Uses ADTypes.jl    to specify whether to use automatic differentiation via   ForwardDiff.jl or finite   differencing via FiniteDiff.jl.    Defaults to AutoForwardDiff() for automatic differentiation, which by default uses   chunksize = 0, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use FiniteDiff.jl, the AutoFiniteDiff() ADType can be used, which has a keyword argument   fdtype with default value Val{:forward}(), and alternatives Val{:central}() and Val{:complex}().\nconcrete_jac: Specifies whether a Jacobian should be constructed. Defaults to   nothing, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for linsolve.\nlinsolve: Any LinearSolve.jl compatible linear solver. For example, to use KLU.jl, specify Velds4(linsolve = KLUFactorization()).  When nothing is passed, uses DefaultLinearSolver.\nprecs: Any LinearSolve.jl-compatible preconditioner can be used as a left or right preconditioner. Preconditioners are specified by the Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata) function where the arguments are defined as:\nW: the current Jacobian of the nonlinear system. Specified as either   I - gamma J or Igamma - J depending on the algorithm. This will   commonly be a WOperator type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling convert(AbstractMatrix,W) to receive an AbstractMatrix matching   the jac_prototype.\ndu: the current ODE derivative\nu: the current ODE state\np: the ODE parameters\nt: the current ODE time\nnewW: a Bool which specifies whether the W matrix has been updated since   the last call to precs. It is recommended that this is checked to only   update the preconditioner when newW == true.\nPlprev: the previous Pl.\nPrprev: the previous Pr.\nsolverdata: Optional extra data the solvers can give to the precs function.   Solver-dependent and subject to change.\nThe return is a tuple (Pl,Pr) of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return nothing for the preconditioner which is not used. Additionally, precs must supply the dispatch:\nPl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\nwhich is used in the solver setup phase to construct the integrator type with the preconditioners (Pl,Pr). The default is precs=DEFAULT_PRECS where the default preconditioner function is defined as:\nDEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nvan Veldhuizen, D-stability and Kaps-Rentrop-methods, M. Computing (1984) 32: 229. doi:10.1007/BF02243574\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.GRK4T-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.GRK4T","text":"GRK4T(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n            ForwardDiff default function-specific tags. For more information, see\n            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n            Defaults to `Val{true}()`.\n        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n            to specify whether to use automatic differentiation via\n            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n            `nothing`, which means it will be chosen true/false depending on circumstances\n            of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n          `GRK4T(linsolve = KLUFactorization()`).\n           When `nothing` is passed, uses `DefaultLinearSolver`.\n        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n          can be used as a left or right preconditioner.\n          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n          function where the arguments are defined as:\n            - `W`: the current Jacobian of the nonlinear system. Specified as either\n                ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                representation of the operator. Users can construct the W-matrix on demand\n                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                the `jac_prototype`.\n            - `du`: the current ODE derivative\n            - `u`: the current ODE state\n            - `p`: the ODE parameters\n            - `t`: the current ODE time\n            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                the last call to `precs`. It is recommended that this is checked to only\n                update the preconditioner when `newW == true`.\n            - `Plprev`: the previous `Pl`.\n            - `Prprev`: the previous `Pr`.\n            - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                Solver-dependent and subject to change.\n          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n          To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n          which is not used. Additionally, `precs` must supply the dispatch:\n          ```julia\n          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n          ```\n          which is used in the solver setup phase to construct the integrator\n          type with the preconditioners `(Pl,Pr)`.\n          The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n          is defined as:\n          ```julia\n          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n          ```\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  An efficient 4th order Rosenbrock method.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nKaps, P. & Rentrop, Generalized Runge-Kutta methods of order four with stepsize control for stiff ordinary differential equations. P. Numer. Math. (1979) 33: 55. doi:10.1007/BF01396495\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.GRK4A-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.GRK4A","text":"GRK4A(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n            ForwardDiff default function-specific tags. For more information, see\n            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n            Defaults to `Val{true}()`.\n        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n            to specify whether to use automatic differentiation via\n            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n            `nothing`, which means it will be chosen true/false depending on circumstances\n            of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n          `GRK4A(linsolve = KLUFactorization()`).\n           When `nothing` is passed, uses `DefaultLinearSolver`.\n        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n          can be used as a left or right preconditioner.\n          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n          function where the arguments are defined as:\n            - `W`: the current Jacobian of the nonlinear system. Specified as either\n                ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                representation of the operator. Users can construct the W-matrix on demand\n                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                the `jac_prototype`.\n            - `du`: the current ODE derivative\n            - `u`: the current ODE state\n            - `p`: the ODE parameters\n            - `t`: the current ODE time\n            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                the last call to `precs`. It is recommended that this is checked to only\n                update the preconditioner when `newW == true`.\n            - `Plprev`: the previous `Pl`.\n            - `Prprev`: the previous `Pr`.\n            - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                Solver-dependent and subject to change.\n          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n          To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n          which is not used. Additionally, `precs` must supply the dispatch:\n          ```julia\n          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n          ```\n          which is used in the solver setup phase to construct the integrator\n          type with the preconditioners `(Pl,Pr)`.\n          The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n          is defined as:\n          ```julia\n          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n          ```\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  An A-stable 4th order Rosenbrock method. Essentially \"anti-L-stable\" but efficient.\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nKaps, P. & Rentrop, Generalized Runge-Kutta methods of order four with stepsize control for stiff ordinary differential equations. P. Numer. Math. (1979) 33: 55. doi:10.1007/BF01396495\n\n\n\n\n\n","category":"type"},{"location":"massmatrixdae/Rosenbrock/#OrdinaryDiffEqRosenbrock.Ros4LStab-massmatrixdae-Rosenbrock","page":"OrdinaryDiffEqRosenbrock","title":"OrdinaryDiffEqRosenbrock.Ros4LStab","text":"Ros4LStab(; - `standardtag`: Specifies whether to use package-specific tags instead of the\n                ForwardDiff default function-specific tags. For more information, see\n                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).\n                Defaults to `Val{true}()`.\n            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) \n                to specify whether to use automatic differentiation via\n                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite\n                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). \n                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses\n                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.\n                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument\n                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.\n            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to\n                `nothing`, which means it will be chosen true/false depending on circumstances\n                of the solver, such as whether a Krylov subspace method is used for `linsolve`.\n            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.\n              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify\n              `Ros4LStab(linsolve = KLUFactorization()`).\n               When `nothing` is passed, uses `DefaultLinearSolver`.\n            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)\n              can be used as a left or right preconditioner.\n              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`\n              function where the arguments are defined as:\n                - `W`: the current Jacobian of the nonlinear system. Specified as either\n                    ``I - \\gamma J`` or ``I/\\gamma - J`` depending on the algorithm. This will\n                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy\n                    representation of the operator. Users can construct the W-matrix on demand\n                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching\n                    the `jac_prototype`.\n                - `du`: the current ODE derivative\n                - `u`: the current ODE state\n                - `p`: the ODE parameters\n                - `t`: the current ODE time\n                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since\n                    the last call to `precs`. It is recommended that this is checked to only\n                    update the preconditioner when `newW == true`.\n                - `Plprev`: the previous `Pl`.\n                - `Prprev`: the previous `Pr`.\n                - `solverdata`: Optional extra data the solvers can give to the `precs` function.\n                    Solver-dependent and subject to change.\n              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.\n              To specify one-sided preconditioning, simply return `nothing` for the preconditioner\n              which is not used. Additionally, `precs` must supply the dispatch:\n              ```julia\n              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)\n              ```\n              which is used in the solver setup phase to construct the integrator\n              type with the preconditioners `(Pl,Pr)`.\n              The default is `precs=DEFAULT_PRECS` where the default preconditioner function\n              is defined as:\n              ```julia\n              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing\n              ```\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nRosenbrock-Wanner Method.  A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant\n\nKeyword Arguments\n\nchunk_size: TBD\nstandardtag: TBD\nautodiff: boolean to control if the Jacobian should be computed via AD or not\nconcrete_jac: function of the form jac!(J, u, p, t)\ndiff_type: TBD\nlinsolve: custom solver for the inner linear systems\nprecs: custom preconditioner for the inner linear solver\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\nE. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)\n\n\n\n\n\n","category":"type"},{"location":"usage/#Usage","page":"Usage","title":"Usage","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"OrdinaryDiffEq.jl is part of the SciML common interface, but can be used independently of DifferentialEquations.jl. The only requirement is that the user passes an OrdinaryDiffEq.jl algorithm to solve. For example, we can solve the ODE tutorial from the docs using the Tsit5() algorithm:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using OrdinaryDiffEq\nf(u, p, t) = 1.01 * u\nu0 = 1 / 2\ntspan = (0.0, 1.0)\nprob = ODEProblem(f, u0, tspan)\nsol = solve(prob, Tsit5(), reltol = 1e-8, abstol = 1e-8)\nusing Plots\nplot(sol, linewidth = 5, title = \"Solution to the linear ODE with a thick line\",\n    xaxis = \"Time (t)\", yaxis = \"u(t) (in μm)\", label = \"My Thick Line!\") # legend=false\nplot!(sol.t, t -> 0.5 * exp(1.01t), lw = 3, ls = :dash, label = \"True Solution!\")","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"That example uses the out-of-place syntax f(u,p,t), while the inplace syntax (more efficient for systems of equations) is shown in the Lorenz example:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using OrdinaryDiffEq\nfunction lorenz(du, u, p, t)\n    du[1] = 10.0(u[2] - u[1])\n    du[2] = u[1] * (28.0 - u[3]) - u[2]\n    du[3] = u[1] * u[2] - (8 / 3) * u[3]\nend\nu0 = [1.0; 0.0; 0.0]\ntspan = (0.0, 100.0)\nprob = ODEProblem(lorenz, u0, tspan)\nsol = solve(prob, Tsit5())\nusing Plots;\nplot(sol, vars = (1, 2, 3));","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Very fast static array versions can be specifically compiled to the size of your model. For example:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"using OrdinaryDiffEq, StaticArrays\nfunction lorenz(u, p, t)\n    SA[10.0(u[2] - u[1]), u[1] * (28.0 - u[3]) - u[2], u[1] * u[2] - (8 / 3) * u[3]]\nend\nu0 = SA[1.0; 0.0; 0.0]\ntspan = (0.0, 100.0)\nprob = ODEProblem(lorenz, u0, tspan)\nsol = solve(prob, Tsit5())","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"For “refined ODEs”, like dynamical equations and SecondOrderODEProblems, refer to the DiffEqDocs. For example, in DiffEqTutorials.jl we show how to solve equations of motion using symplectic methods:","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"function HH_acceleration(dv, v, u, p, t)\n    x, y = u\n    dx, dy = dv\n    dv[1] = -x - 2x * y\n    dv[2] = y^2 - y - x^2\nend\ninitial_positions = [0.0, 0.1]\ninitial_velocities = [0.5, 0.0]\nprob = SecondOrderODEProblem(HH_acceleration, initial_velocities, initial_positions, tspan)\nsol2 = solve(prob, KahanLi8(), dt = 1 / 10);","category":"page"},{"location":"usage/","page":"Usage","title":"Usage","text":"Other refined forms are IMEX and semi-linear ODEs (for exponential integrators).","category":"page"},{"location":"usage/#Available-Solvers","page":"Usage","title":"Available Solvers","text":"","category":"section"},{"location":"usage/","page":"Usage","title":"Usage","text":"For the list of available solvers, please refer to the DifferentialEquations.jl ODE Solvers, Dynamical ODE Solvers, and the Split ODE Solvers pages.","category":"page"},{"location":"explicit/Feagin/#OrdinaryDiffEqFeagin","page":"OrdinaryDiffEqFeagin","title":"OrdinaryDiffEqFeagin","text":"","category":"section"},{"location":"explicit/Feagin/","page":"OrdinaryDiffEqFeagin","title":"OrdinaryDiffEqFeagin","text":"Preferred solvers for non-stiff problems at very low tolerance, <1e-30. Best combined with preciser than Float64 number types for the state, such as the BigFloat number type. Note that the Feagin methods have a less robust error estimator than the Verner methods, and thus even for very low tolerance problems the Verner methods (Vern9) may still be more efficient. In addition, at extremely low tolerances the explicit extrapolation methods allow for arbitrarily high variable order stepping which will also outperform the Feagin methods. As such, the Feagin methods may be useful in the Float128 precision range but should be tested against other algorithms.","category":"page"},{"location":"explicit/Feagin/","page":"OrdinaryDiffEqFeagin","title":"OrdinaryDiffEqFeagin","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqFeagin\", \"Feagin14\")","category":"page"},{"location":"explicit/Feagin/#Full-list-of-solvers","page":"OrdinaryDiffEqFeagin","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/Feagin/#OrdinaryDiffEqFeagin.Feagin10","page":"OrdinaryDiffEqFeagin","title":"OrdinaryDiffEqFeagin.Feagin10","text":"Feagin10(; step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nExplicit Runge-Kutta Method.  Feagin's 10th-order method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{feagin2012high, title={High-order explicit Runge-Kutta methods using m-symmetry}, author={Feagin, Terry}, year={2012}, publisher={Neural, Parallel \\& Scientific Computations} }\n\n\n\n\n\n","category":"type"},{"location":"explicit/Feagin/#OrdinaryDiffEqFeagin.Feagin12","page":"OrdinaryDiffEqFeagin","title":"OrdinaryDiffEqFeagin.Feagin12","text":"Feagin12(; step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nExplicit Runge-Kutta Method.  Feagin's 12th-order method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{feagin2012high, title={High-order explicit Runge-Kutta methods using m-symmetry}, author={Feagin, Terry}, year={2012}, publisher={Neural, Parallel \\& Scientific Computations} }\n\n\n\n\n\n","category":"type"},{"location":"explicit/Feagin/#OrdinaryDiffEqFeagin.Feagin14","page":"OrdinaryDiffEqFeagin","title":"OrdinaryDiffEqFeagin.Feagin14","text":"Feagin14(; step_limiter! = OrdinaryDiffEq.trivial_limiter!)\n\nExplicit Runge-Kutta Method.  Feagin's 14th-order method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\n\nReferences\n\n@article{feagin2009explicit, title={An Explicit Runge-Kutta Method of Order Fourteen}, author={Feagin, Terry}, year={2009}, publisher={Numerical Algorithms} }\n\n\n\n\n\n","category":"type"},{"location":"imex/IMEXBDF/#OrdinaryDiffEqBDF","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"","category":"section"},{"location":"imex/IMEXBDF/","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"Solvers if your system of ordinary differential equations can be split up into the sum of a stiff and non-stiff part. These are IMEX extensions of common BDF schemes.","category":"page"},{"location":"imex/IMEXBDF/#Installation","page":"OrdinaryDiffEqBDF","title":"Installation","text":"","category":"section"},{"location":"imex/IMEXBDF/","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"To be able to access the solvers in OrdinaryDiffEqBDF, you must first install them use the Julia package manager:","category":"page"},{"location":"imex/IMEXBDF/","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"using Pkg\nPkg.add(\"OrdinaryDiffEqBDF\")","category":"page"},{"location":"imex/IMEXBDF/","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"This will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.","category":"page"},{"location":"imex/IMEXBDF/#Example-usage","page":"OrdinaryDiffEqBDF","title":"Example usage","text":"","category":"section"},{"location":"imex/IMEXBDF/","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"using OrdinaryDiffEqBDF\nf1 = (u, p, t) -> 2u\nf2 = (u, p, t) -> 2u\nu0 = 1.0\ntspan = (0.0, 1.0)\nprob = SplitODEProblem(f1, f2, u0, tspan)\nsol = solve(prob, SBDF2(), dt = 1 / 10)","category":"page"},{"location":"imex/IMEXBDF/#Full-list-of-solvers","page":"OrdinaryDiffEqBDF","title":"Full list of solvers","text":"","category":"section"},{"location":"imex/IMEXBDF/#IMEX-Multistep","page":"OrdinaryDiffEqBDF","title":"IMEX Multistep","text":"","category":"section"},{"location":"imex/IMEXBDF/#OrdinaryDiffEqBDF.SBDF2","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.SBDF2","text":"SBDF2(;kwargs...)\n\nThe two-step version of the IMEX multistep methods of\n\nUri M. Ascher, Steven J. Ruuth, Brian T. R. Wetton. Implicit-Explicit Methods for Time-Dependent Partial Differential Equations. Society for Industrial and Applied Mathematics. Journal on Numerical Analysis, 32(3), pp 797-823, 1995. doi: https://doi.org/10.1137/0732037\n\nSee also SBDF.\n\n\n\n\n\n","category":"function"},{"location":"imex/IMEXBDF/#OrdinaryDiffEqBDF.SBDF3","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.SBDF3","text":"SBDF3(;kwargs...)\n\nThe three-step version of the IMEX multistep methods of\n\nUri M. Ascher, Steven J. Ruuth, Brian T. R. Wetton. Implicit-Explicit Methods for Time-Dependent Partial Differential Equations. Society for Industrial and Applied Mathematics. Journal on Numerical Analysis, 32(3), pp 797-823, 1995. doi: https://doi.org/10.1137/0732037\n\nSee also SBDF.\n\n\n\n\n\n","category":"function"},{"location":"imex/IMEXBDF/#OrdinaryDiffEqBDF.SBDF4","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.SBDF4","text":"SBDF4(;kwargs...)\n\nThe four-step version of the IMEX multistep methods of\n\nUri M. Ascher, Steven J. Ruuth, Brian T. R. Wetton. Implicit-Explicit Methods for Time-Dependent Partial Differential Equations. Society for Industrial and Applied Mathematics. Journal on Numerical Analysis, 32(3), pp 797-823, 1995. doi: https://doi.org/10.1137/0732037\n\nSee also SBDF.\n\n\n\n\n\n","category":"function"},{"location":"imex/IMEXBDF/#IMEX-SDIRK","page":"OrdinaryDiffEqBDF","title":"IMEX SDIRK","text":"","category":"section"},{"location":"imex/IMEXBDF/","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF","text":"Note that Implicit Euler is the 1st order BDF method, and is thus implemented here using the same machinery.","category":"page"},{"location":"imex/IMEXBDF/#OrdinaryDiffEqBDF.IMEXEuler","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.IMEXEuler","text":"IMEXEuler(;kwargs...)\n\nThe one-step version of the IMEX multistep methods of\n\nUri M. Ascher, Steven J. Ruuth, Brian T. R. Wetton. Implicit-Explicit Methods for Time-Dependent Partial Differential Equations. Society for Industrial and Applied Mathematics. Journal on Numerical Analysis, 32(3), pp 797-823, 1995. doi: https://doi.org/10.1137/0732037\n\nWhen applied to a SplitODEProblem of the form\n\nu'(t) = f1(u) + f2(u)\n\nThe default IMEXEuler() method uses an update of the form\n\nunew = uold + dt * (f1(unew) + f2(uold))\n\nSee also SBDF, IMEXEulerARK.\n\n\n\n\n\n","category":"function"},{"location":"imex/IMEXBDF/#OrdinaryDiffEqBDF.IMEXEulerARK","page":"OrdinaryDiffEqBDF","title":"OrdinaryDiffEqBDF.IMEXEulerARK","text":"IMEXEulerARK(;kwargs...)\n\nThe one-step version of the IMEX multistep methods of\n\nUri M. Ascher, Steven J. Ruuth, Brian T. R. Wetton. Implicit-Explicit Methods for Time-Dependent Partial Differential Equations. Society for Industrial and Applied Mathematics. Journal on Numerical Analysis, 32(3), pp 797-823, 1995. doi: https://doi.org/10.1137/0732037\n\nWhen applied to a SplitODEProblem of the form\n\nu'(t) = f1(u) + f2(u)\n\nA classical additive Runge-Kutta method in the sense of Araújo, Murua, Sanz-Serna (1997) consisting of the implicit and the explicit Euler method given by\n\ny1   = uold + dt * f1(y1)\nunew = uold + dt * (f1(unew) + f2(y1))\n\nSee also SBDF, IMEXEuler.\n\n\n\n\n\n","category":"function"},{"location":"imex/StabilizedIRK/#OrdinaryDiffEqStabilizedIRK","page":"OrdinaryDiffEqStabilizedIRK","title":"OrdinaryDiffEqStabilizedIRK","text":"","category":"section"},{"location":"imex/StabilizedIRK/","page":"OrdinaryDiffEqStabilizedIRK","title":"OrdinaryDiffEqStabilizedIRK","text":"Stabilized Explicit Runge-Kutta methods, like Runge-Kutta-Chebyshev methods and ROCK methods are explicit methods which chain together many stages in a specific way to get large stability regions. they are made in such a way to converge to a large stability region, and thus suitable to stiff equations. However, they converge to having a large stability region in the direction of the negative real axis, and thus are only stable on a subset of stiff equations which are not dominated by large complex eigenvalues in the Jacobian.","category":"page"},{"location":"imex/StabilizedIRK/","page":"OrdinaryDiffEqStabilizedIRK","title":"OrdinaryDiffEqStabilizedIRK","text":"Stabilized implicit methods try to mitigate this problem by being an IMEX type scheme, requiring a SplitODEProblem where the splitting is designed to treat the large complex eigenvalues implicitly while treating the large real eigenvalues using a fast explicit stabilized RK type of method.","category":"page"},{"location":"imex/StabilizedIRK/","page":"OrdinaryDiffEqStabilizedIRK","title":"OrdinaryDiffEqStabilizedIRK","text":"These methods utilize an upper bound on the spectral radius of the Jacobian. Users can supply an upper bound by specifying the keyword argument eigen_est, for example","category":"page"},{"location":"imex/StabilizedIRK/","page":"OrdinaryDiffEqStabilizedIRK","title":"OrdinaryDiffEqStabilizedIRK","text":"`eigen_est = (integrator) -> integrator.eigen_est = upper_bound`","category":"page"},{"location":"imex/StabilizedIRK/#Installation","page":"OrdinaryDiffEqStabilizedIRK","title":"Installation","text":"","category":"section"},{"location":"imex/StabilizedIRK/","page":"OrdinaryDiffEqStabilizedIRK","title":"OrdinaryDiffEqStabilizedIRK","text":"To be able to access the solvers in OrdinaryDiffEqStabilizedIRK, you must first install them use the Julia package manager:","category":"page"},{"location":"imex/StabilizedIRK/","page":"OrdinaryDiffEqStabilizedIRK","title":"OrdinaryDiffEqStabilizedIRK","text":"using Pkg\nPkg.add(\"OrdinaryDiffEqStabilizedIRK\")","category":"page"},{"location":"imex/StabilizedIRK/","page":"OrdinaryDiffEqStabilizedIRK","title":"OrdinaryDiffEqStabilizedIRK","text":"This will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.","category":"page"},{"location":"imex/StabilizedIRK/#Example-usage","page":"OrdinaryDiffEqStabilizedIRK","title":"Example usage","text":"","category":"section"},{"location":"imex/StabilizedIRK/","page":"OrdinaryDiffEqStabilizedIRK","title":"OrdinaryDiffEqStabilizedIRK","text":"using OrdinaryDiffEqStabilizedIRK\nA = randn(20, 20)\nB = randn(20, 20)\nf1 = (u, p, t) -> A * u\nf2 = (u, p, t) -> B * u\nu0 = randn(20, 1)\ntspan = (0.0, 1.0)\nprob = SplitODEProblem(f1, f2, u0, tspan)\nsol = solve(prob, IRKC())","category":"page"},{"location":"imex/StabilizedIRK/#Full-list-of-solvers","page":"OrdinaryDiffEqStabilizedIRK","title":"Full list of solvers","text":"","category":"section"},{"location":"imex/StabilizedIRK/#OrdinaryDiffEqStabilizedIRK.IRKC","page":"OrdinaryDiffEqStabilizedIRK","title":"OrdinaryDiffEqStabilizedIRK.IRKC","text":"IRKC(; eigen_est = nothing)\n\nStabilized Implicit Runge Kutta method. Implicit Runge-Kutta-Chebyshev method.\n\nKeyword Arguments\n\neigen_est: function of the form   (integrator) -> integrator.eigen_est = upper_bound,   where upper_bound is an estimated upper bound on the spectral radius of the Jacobian matrix.   If eigen_est is not provided, upper_bound will be estimated using the power iteration.\n\nReferences\n\nREF TBD\n\n\n\n\n\n","category":"type"},{"location":"explicit/Extrapolation/#OrdinaryDiffEqExtrapolation","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation","text":"","category":"section"},{"location":"explicit/Extrapolation/","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation","text":"Solvers based on within method parallelism, allowing multithreading of the solution across different values of f. The explicit extrapolation solvers are generally outclassed by other explicit methods. However, some stiff extrapolation methods perform very well if the problem is sufficiently stiff.","category":"page"},{"location":"explicit/Extrapolation/","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqExtrapolation\", \"ExtrapolationMidpointDeuflhard\")","category":"page"},{"location":"explicit/Extrapolation/#Full-list-of-solvers","page":"OrdinaryDiffEqExtrapolation","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/Extrapolation/#OrdinaryDiffEqExtrapolation.AitkenNeville","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation.AitkenNeville","text":"AitkenNeville(; max_order::Int = 10,\n                min_order::Int = 1,\n                init_order = 3,\n                thread = OrdinaryDiffEq.False())\n\nParallelized Explicit Extrapolation Method. Euler extrapolation using Aitken-Neville with the Romberg Sequence.\n\nKeyword Arguments\n\nmax_order: maximum order of the adaptive order algorithm.\nmin_order: minimum order of the adaptive order algorithm.\ninit_order: initial order of the adaptive order algorithm.\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@inproceedings{elrod2022parallelizing,   title={Parallelizing explicit and implicit extrapolation methods for ordinary differential equations},   author={Elrod, Chris and Ma, Yingbo and Althaus, Konstantin and Rackauckas, Christopher and others},   booktitle={2022 IEEE High Performance Extreme Computing Conference (HPEC)},   pages={1–9},   year={2022},   organization={IEEE}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/Extrapolation/#OrdinaryDiffEqExtrapolation.ExtrapolationMidpointDeuflhard","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation.ExtrapolationMidpointDeuflhard","text":"ExtrapolationMidpointDeuflhard(; max_order = 10,\n                                 min_order = 1,\n                                 init_order = 5,\n                                 thread = OrdinaryDiffEq.True(),\n                                 sequence = :harmonic,\n                                 sequence_factor = 2)\n\nParallelized Explicit Extrapolation Method. Midpoint extrapolation using Barycentric coordinates.\n\nKeyword Arguments\n\nmax_order: maximum order of the adaptive order algorithm.\nmin_order: minimum order of the adaptive order algorithm.\ninit_order: initial order of the adaptive order algorithm.\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nsequence: the step-number sequences, also called the subdividing sequence. Possible values are :harmonic, :romberg or :bulirsch.\nsequence_factor: denotes which even multiple of sequence to take while evaluating internal discretizations.\n\nReferences\n\n@inproceedings{elrod2022parallelizing,   title={Parallelizing explicit and implicit extrapolation methods for ordinary differential equations},   author={Elrod, Chris and Ma, Yingbo and Althaus, Konstantin and Rackauckas, Christopher and others},   booktitle={2022 IEEE High Performance Extreme Computing Conference (HPEC)},   pages={1–9},   year={2022},   organization={IEEE}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/Extrapolation/#OrdinaryDiffEqExtrapolation.ExtrapolationMidpointHairerWanner","page":"OrdinaryDiffEqExtrapolation","title":"OrdinaryDiffEqExtrapolation.ExtrapolationMidpointHairerWanner","text":"ExtrapolationMidpointHairerWanner(; max_order = 10,\n                                    min_order = 2,\n                                    init_order = 5,\n                                    thread = OrdinaryDiffEq.True(),\n                                    sequence = :harmonic,\n                                    sequence_factor = 2)\n\nParallelized Explicit Extrapolation Method. Midpoint extrapolation using Barycentric coordinates,     following Hairer's ODEX in the adaptivity behavior.\n\nKeyword Arguments\n\nmax_order: maximum order of the adaptive order algorithm.\nmin_order: minimum order of the adaptive order algorithm.\ninit_order: initial order of the adaptive order algorithm.\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nsequence: the step-number sequences, also called the subdividing sequence. Possible values are :harmonic, :romberg or :bulirsch.\nsequence_factor: denotes which even multiple of sequence to take while evaluating internal discretizations.\n\nReferences\n\n@inproceedings{elrod2022parallelizing,   title={Parallelizing explicit and implicit extrapolation methods for ordinary differential equations},   author={Elrod, Chris and Ma, Yingbo and Althaus, Konstantin and Rackauckas, Christopher and others},   booktitle={2022 IEEE High Performance Extreme Computing Conference (HPEC)},   pages={1–9},   year={2022},   organization={IEEE}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK","text":"","category":"section"},{"location":"explicit/LowStorageRK/","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK","text":"These methods are designed to have reduced register requirements, allowing for larger sets of ODEs to more easily fit into RAM. For example, while the 5th order Tsit5 requires around 9 concurrent instantiations of the ODE state u, RDPK3Sp510 can achieve 5th order with 3 registers, effectively requiring 1/3 of the memory. However, there are some efficiency trade-offs used in the design of the low-storage RK methods, and thus they are generally only recommended in situations which are RAM bound, like large-scale PDE discretizations.","category":"page"},{"location":"explicit/LowStorageRK/","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqLowStorageRK\", \"CarpenterKennedy2N54\")","category":"page"},{"location":"explicit/LowStorageRK/#Full-list-of-solvers","page":"OrdinaryDiffEqLowStorageRK","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ORK256","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ORK256","text":"ORK256(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False(),\n         williamson_condition = true)\n\nExplicit Runge-Kutta Method.  A second-order, five-stage method for wave propagation equations. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nMatteo Bernardini, Sergio Pirozzoli.     A General Strategy for the Optimization of Runge-Kutta Schemes for Wave     Propagation Phenomena.     Journal of Computational Physics, 228(11), pp 4182-4199, 2009.     doi: https://doi.org/10.1016/j.jcp.2009.02.032\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.DGLDDRK73_C","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.DGLDDRK73_C","text":"DGLDDRK73_C(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False(),\n              williamson_condition = true)\n\nExplicit Runge-Kutta Method.  7-stage, third order low-storage low-dissipation, low-dispersion scheme for discontinuous Galerkin space discretizations applied to wave propagation problems. Optimized for PDE discretizations when maximum spatial step is small due to geometric features of computational domain. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nT. Toulorge, W. Desmet.     Optimal Runge–Kutta Schemes for Discontinuous Galerkin Space Discretizations     Applied to Wave Propagation Problems.     Journal of Computational Physics, 231(4), pp 2067-2091, 2012.     doi: https://doi.org/10.1016/j.jcp.2011.11.024\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CarpenterKennedy2N54","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CarpenterKennedy2N54","text":"CarpenterKennedy2N54(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                       step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                       thread = OrdinaryDiffEq.False(),\n                       williamson_condition = true)\n\nExplicit Runge-Kutta Method.  A fourth-order, five-stage low-storage method of Carpenter and Kennedy (free 3rd order Hermite interpolant). Fixed timestep only. Designed for hyperbolic PDEs (stability properties).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\n@article{carpenter1994fourth,     title={Fourth-order 2N-storage Runge-Kutta schemes},     author={Carpenter, Mark H and Kennedy, Christopher A},     year={1994}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.NDBLSRK124","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.NDBLSRK124","text":"NDBLSRK124(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False(),\n             williamson_condition = true)\n\nExplicit Runge-Kutta Method.  12-stage, fourth order low-storage method with optimized stability regions for advection-dominated problems. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nJens Niegemann, Richard Diehl, Kurt Busch.     Efficient Low-Storage Runge–Kutta Schemes with Optimized Stability Regions.     Journal of Computational Physics, 231, pp 364-372, 2012.     doi: https://doi.org/10.1016/j.jcp.2011.09.003\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.NDBLSRK144","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.NDBLSRK144","text":"NDBLSRK144(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False(),\n             williamson_condition = true)\n\nExplicit Runge-Kutta Method.  14-stage, fourth order low-storage method with optimized stability regions for advection-dominated problems. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nJens Niegemann, Richard Diehl, Kurt Busch.     Efficient Low-Storage Runge–Kutta Schemes with Optimized Stability Regions.     Journal of Computational Physics, 231, pp 364-372, 2012.     doi: https://doi.org/10.1016/j.jcp.2011.09.003\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CFRLDDRK64","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CFRLDDRK64","text":"CFRLDDRK64(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 6-stage, fourth order low-storage, low-dissipation, low-dispersion scheme. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nM. Calvo, J. M. Franco, L. Randez. A New Minimum Storage Runge–Kutta Scheme     for Computational Acoustics. Journal of Computational Physics, 201, pp 1-12, 2004.     doi: https://doi.org/10.1016/j.jcp.2004.05.012\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.TSLDDRK74","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.TSLDDRK74","text":"TSLDDRK74(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 7-stage, fourth order low-storage low-dissipation, low-dispersion scheme with maximal accuracy and stability limit along the imaginary axes. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nKostas Tselios, T. E. Simos. Optimized Runge–Kutta Methods with Minimal Dispersion and Dissipation     for Problems arising from Computational Acoustics. Physics Letters A, 393(1-2), pp 38-47, 2007.     doi: https://doi.org/10.1016/j.physleta.2006.10.072\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.DGLDDRK84_C","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.DGLDDRK84_C","text":"DGLDDRK84_C(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False(),\n              williamson_condition = true)\n\nExplicit Runge-Kutta Method.  8-stage, fourth order low-storage low-dissipation, low-dispersion scheme for discontinuous Galerkin space discretizations applied to wave propagation problems. Optimized for PDE discretizations when maximum spatial step is small due to geometric features of computational domain. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nT. Toulorge, W. Desmet.     Optimal Runge–Kutta Schemes for Discontinuous Galerkin Space Discretizations     Applied to Wave Propagation Problems.     Journal of Computational Physics, 231(4), pp 2067-2091, 2012.     doi: https://doi.org/10.1016/j.jcp.2011.11.024\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.DGLDDRK84_F","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.DGLDDRK84_F","text":"DGLDDRK84_F(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False(),\n              williamson_condition = true)\n\nExplicit Runge-Kutta Method.  8-stage, fourth order low-storage low-dissipation, low-dispersion scheme for discontinuous Galerkin space discretizations applied to wave propagation problems. Optimized for PDE discretizations when the maximum spatial step size is not constrained. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nT. Toulorge, W. Desmet.     Optimal Runge–Kutta Schemes for Discontinuous Galerkin Space Discretizations     Applied to Wave Propagation Problems.     Journal of Computational Physics, 231(4), pp 2067-2091, 2012.     doi: https://doi.org/10.1016/j.jcp.2011.11.024\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.SHLDDRK64","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.SHLDDRK64","text":"SHLDDRK64(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False(),\n            williamson_condition = true)\n\nExplicit Runge-Kutta Method.  A fourth-order, six-stage low-storage method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nD. Stanescu, W. G. Habashi.     2N-Storage Low Dissipation and Dispersion Runge-Kutta Schemes for Computational     Acoustics.     Journal of Computational Physics, 143(2), pp 674-681, 1998.     doi: https://doi.org/10.1006/jcph.1998.5986     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.RK46NL","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.RK46NL","text":"RK46NL(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n         thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  6-stage, fourth order low-stage, low-dissipation, low-dispersion scheme. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nJulien Berland, Christophe Bogey, Christophe Bailly. Low-Dissipation and Low-Dispersion Fourth-Order Runge-Kutta Algorithm. Computers & Fluids, 35(10), pp 1459-1463, 2006. doi: https://doi.org/10.1016/j.compfluid.2005.04.003\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S32","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S32","text":"ParsaniKetchesonDeconinck3S32(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 3-stage, second order (3S) low-storage scheme, optimized  the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S82","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S82","text":"ParsaniKetchesonDeconinck3S82(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 8-stage, second order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S53","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S53","text":"ParsaniKetchesonDeconinck3S53(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 5-stage, third order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S173","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S173","text":"ParsaniKetchesonDeconinck3S173(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 17-stage, third order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S94","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S94","text":"ParsaniKetchesonDeconinck3S94(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 9-stage, fourth order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S184","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S184","text":"ParsaniKetchesonDeconinck3S184(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 18-stage, fourth order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S105","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S105","text":"ParsaniKetchesonDeconinck3S105(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 10-stage, fifth order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S205","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.ParsaniKetchesonDeconinck3S205","text":"ParsaniKetchesonDeconinck3S205(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                                 thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 20-stage, fifth order (3S) low-storage scheme, optimized for the spectral difference method applied to wave propagation problems.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nParsani, Matteo, David I. Ketcheson, and W. Deconinck.     Optimized explicit Runge–Kutta schemes for the spectral difference method applied to wave propagation problems.     SIAM Journal on Scientific Computing 35.2 (2013): A957-A986.     doi: https://doi.org/10.1137/120885899\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK43_2","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK43_2","text":"CKLLSRK43_2(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 4-stage, third order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK54_3C","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK54_3C","text":"CKLLSRK54_3C(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK95_4S","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK95_4S","text":"CKLLSRK95_4S(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 9-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK95_4C","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK95_4C","text":"CKLLSRK95_4C(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 9-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK95_4M","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK95_4M","text":"CKLLSRK95_4M(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n               thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 9-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK54_3C_3R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK54_3C_3R","text":"CKLLSRK54_3C_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK54_3M_3R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK54_3M_3R","text":"CKLLSRK54_3M_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK54_3N_3R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK54_3N_3R","text":"CKLLSRK54_3N_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK85_4C_3R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK85_4C_3R","text":"CKLLSRK85_4C_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 8-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK85_4M_3R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK85_4M_3R","text":"CKLLSRK85_4M_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 8-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK85_4P_3R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK85_4P_3R","text":"CKLLSRK85_4P_3R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 8-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK54_3N_4R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK54_3N_4R","text":"CKLLSRK54_3N_4R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK54_3M_4R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK54_3M_4R","text":"CKLLSRK54_3M_4R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 5-stage, fourth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK65_4M_4R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK65_4M_4R","text":"CKLLSRK65_4M_4R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  6-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK85_4FM_4R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK85_4FM_4R","text":"CKLLSRK85_4FM_4R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                   step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                   thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low-Storage Method 8-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.CKLLSRK75_4M_5R","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.CKLLSRK75_4M_5R","text":"CKLLSRK75_4M_5R(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                  thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  CKLLSRK754M5R: Low-Storage Method 7-stage, fifth order low-storage scheme, optimized for compressible Navier–Stokes equations.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kennedy2000low, title={Low-storage, explicit Runge–Kutta schemes for the compressible Navier–Stokes equations}, author={Kennedy, Christopher A and Carpenter, Mark H and Lewis, R Michael}, journal={Applied numerical mathematics}, volume={35}, number={3}, pages={177–219}, year={2000}, publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.RDPK3Sp35","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.RDPK3Sp35","text":"RDPK3Sp35(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, five-stage method with embedded error estimator designed for spectral element discretizations of compressible fluid mechanics.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021)     Optimized Runge-Kutta Methods with Automatic Step Size Control for     Compressible Computational Fluid Dynamics     arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.RDPK3SpFSAL35","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.RDPK3SpFSAL35","text":"RDPK3SpFSAL35(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, five-stage method with embedded error estimator using the FSAL property designed for spectral element discretizations of compressible fluid mechanics.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021)     Optimized Runge-Kutta Methods with Automatic Step Size Control for     Compressible Computational Fluid Dynamics     arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.RDPK3Sp49","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.RDPK3Sp49","text":"RDPK3Sp49(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A fourth-order, nine-stage method with embedded error estimator designed for spectral element discretizations of compressible fluid mechanics.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021)     Optimized Runge-Kutta Methods with Automatic Step Size Control for     Compressible Computational Fluid Dynamics     arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.RDPK3SpFSAL49","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.RDPK3SpFSAL49","text":"RDPK3SpFSAL49(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A fourth-order, nine-stage method with embedded error estimator using the FSAL property designed for spectral element discretizations of compressible fluid mechanics.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021)     Optimized Runge-Kutta Methods with Automatic Step Size Control for     Compressible Computational Fluid Dynamics     arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.RDPK3Sp510","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.RDPK3Sp510","text":"RDPK3Sp510(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A fifth-order, ten-stage method with embedded error estimator designed for spectral element discretizations of compressible fluid mechanics.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021)     Optimized Runge-Kutta Methods with Automatic Step Size Control for     Compressible Computational Fluid Dynamics     arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.RDPK3SpFSAL510","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.RDPK3SpFSAL510","text":"RDPK3SpFSAL510(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                 step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                 thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A fifth-order, ten-stage method with embedded error estimator using the FSAL property designed for spectral element discretizations of compressible fluid mechanics.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRanocha, Dalcin, Parsani, Ketcheson (2021)     Optimized Runge-Kutta Methods with Automatic Step Size Control for     Compressible Computational Fluid Dynamics     arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.HSLDDRK64","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.HSLDDRK64","text":"HSLDDRK64(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False(),\n            williamson_condition = true)\n\nExplicit Runge-Kutta Method.  Low-Storage Method 6-stage, fourth order low-stage, low-dissipation, low-dispersion scheme. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nD. Stanescu, W. G. Habashi.     2N-Storage Low Dissipation and Dispersion Runge-Kutta Schemes for Computational     Acoustics.     Journal of Computational Physics, 143(2), pp 674-681, 1998.     doi: https://doi.org/10.1006/jcph.1998.5986     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.NDBLSRK134","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.NDBLSRK134","text":"NDBLSRK134(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False(),\n             williamson_condition = true)\n\nExplicit Runge-Kutta Method.  13-stage, fourth order low-storage method with optimized stability regions for advection-dominated problems. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nwilliamson_condition: allows for an optimization that allows fusing broadcast expressions with the function call f. However, it only works for Array types.\n\nReferences\n\nJens Niegemann, Richard Diehl, Kurt Busch.     Efficient Low-Storage Runge–Kutta Schemes with Optimized Stability Regions.     Journal of Computational Physics, 231, pp 364-372, 2012.     doi: https://doi.org/10.1016/j.jcp.2011.09.003\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.SHLDDRK_2N","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.SHLDDRK_2N","text":"SHLDDRK_2N(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low dissipation and dispersion Runge-Kutta schemes for computational acoustics\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{stanescu19982n,     title={2N-storage low dissipation and dispersion Runge-Kutta schemes for computational acoustics},     author={Stanescu, D and Habashi, WG},     journal={Journal of Computational Physics},     volume={143},     number={2},     pages={674–681},     year={1998},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/LowStorageRK/#OrdinaryDiffEqLowStorageRK.SHLDDRK52","page":"OrdinaryDiffEqLowStorageRK","title":"OrdinaryDiffEqLowStorageRK.SHLDDRK52","text":"SHLDDRK52(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Low dissipation and dispersion Runge-Kutta schemes for computational acoustics\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{stanescu19982n,     title={2N-storage low dissipation and dispersion Runge-Kutta schemes for computational acoustics},     author={Stanescu, D and Habashi, WG},     journal={Journal of Computational Physics},     volume={143},     number={2},     pages={674–681},     year={1998},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner","text":"","category":"section"},{"location":"explicit/Verner/","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner","text":"Preferred solvers for non-stiff problems at low tolerance. Vern6, Vern7, or Vern8 are good methods for tolerances between ~1e-8-1e-12, and using Float64 numbers for the state of the differential equation. For even lower tolerances,Vern9 should be used, combined with the more precise BigFloat number type.","category":"page"},{"location":"explicit/Verner/","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqVerner\", \"Vern6\")","category":"page"},{"location":"explicit/Verner/#Full-list-of-solvers","page":"OrdinaryDiffEqVerner","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.Vern6","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.Vern6","text":"Vern6(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False(),\n        lazy = true)\n\nExplicit Runge-Kutta Method.  Verner's “Most Efficient” 6/5 Runge-Kutta method. (lazy 6th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nlazy: determines if the lazy interpolant is used.\n\nReferences\n\n@article{verner2010numerically,     title={Numerically optimal Runge–Kutta pairs with interpolants},     author={Verner, James H},     journal={Numerical Algorithms},     volume={53},     number={2-3},     pages={383–396},     year={2010},     publisher={Springer}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.Vern7","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.Vern7","text":"Vern7(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False(),\n        lazy = true)\n\nExplicit Runge-Kutta Method.  Verner's “Most Efficient” 7/6 Runge-Kutta method. (lazy 7th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nlazy: determines if the lazy interpolant is used.\n\nReferences\n\n@article{verner2010numerically,     title={Numerically optimal Runge–Kutta pairs with interpolants},     author={Verner, James H},     journal={Numerical Algorithms},     volume={53},     number={2-3},     pages={383–396},     year={2010},     publisher={Springer}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.Vern8","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.Vern8","text":"Vern8(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False(),\n        lazy = true)\n\nExplicit Runge-Kutta Method.  Verner's “Most Efficient” 8/7 Runge-Kutta method. (lazy 8th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nlazy: determines if the lazy interpolant is used.\n\nReferences\n\n@article{verner2010numerically,     title={Numerically optimal Runge–Kutta pairs with interpolants},     author={Verner, James H},     journal={Numerical Algorithms},     volume={53},     number={2-3},     pages={383–396},     year={2010},     publisher={Springer}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.Vern9","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.Vern9","text":"Vern9(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n        thread = OrdinaryDiffEq.False(),\n        lazy = true)\n\nExplicit Runge-Kutta Method.  Verner's “Most Efficient” 9/8 Runge-Kutta method. (lazy9th order interpolant).\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\nlazy: determines if the lazy interpolant is used.\n\nReferences\n\n@article{verner2010numerically,     title={Numerically optimal Runge–Kutta pairs with interpolants},     author={Verner, James H},     journal={Numerical Algorithms},     volume={53},     number={2-3},     pages={383–396},     year={2010},     publisher={Springer}     }\n\n\n\n\n\n","category":"type"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.AutoVern6","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.AutoVern6","text":"Automatic switching algorithm that can switch between the (non-stiff) Vern6() and stiff_alg.\n\nAutoVern6(stiff_alg; kwargs...)\n\nThis method is equivalent to AutoAlgSwitch(Vern6(), stiff_alg; kwargs...). To gain access to stiff algorithms you might have to install additional libraries, such as OrdinaryDiffEqRosenbrock.\n\n\n\n\n\n","category":"function"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.AutoVern7","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.AutoVern7","text":"Automatic switching algorithm that can switch between the (non-stiff) Vern7() and stiff_alg.\n\nAutoVern7(stiff_alg; kwargs...)\n\nThis method is equivalent to AutoAlgSwitch(Vern7(), stiff_alg; kwargs...). To gain access to stiff algorithms you might have to install additional libraries, such as OrdinaryDiffEqRosenbrock.\n\n\n\n\n\n","category":"function"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.AutoVern8","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.AutoVern8","text":"Automatic switching algorithm that can switch between the (non-stiff) Vern8() and stiff_alg.\n\nAutoVern8(stiff_alg; kwargs...)\n\nThis method is equivalent to AutoAlgSwitch(Vern8(), stiff_alg; kwargs...). To gain access to stiff algorithms you might have to install additional libraries, such as OrdinaryDiffEqRosenbrock.\n\n\n\n\n\n","category":"function"},{"location":"explicit/Verner/#OrdinaryDiffEqVerner.AutoVern9","page":"OrdinaryDiffEqVerner","title":"OrdinaryDiffEqVerner.AutoVern9","text":"Automatic switching algorithm that can switch between the (non-stiff) Vern9() and stiff_alg.\n\nAutoVern9(stiff_alg; kwargs...)\n\nThis method is equivalent to AutoAlgSwitch(Vern9(), stiff_alg; kwargs...). To gain access to stiff algorithms you might have to install additional libraries, such as OrdinaryDiffEqRosenbrock.\n\n\n\n\n\n","category":"function"},{"location":"#OrdinaryDiffEq.jl","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl","text":"","category":"section"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"OrdinaryDiffEq.jl is a component package in the DifferentialEquations ecosystem. It holds the ordinary differential equation solvers and utilities. While completely independent and usable on its own, users interested in using this functionality should check out DifferentialEquations.jl.","category":"page"},{"location":"#Installation","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"Installation","text":"","category":"section"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"Assuming that you already have Julia correctly installed, it suffices to import OrdinaryDiffEq.jl in the standard way:","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"import Pkg;\nPkg.add(\"OrdinaryDiffEq\");","category":"page"},{"location":"#Reproducibility","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"Reproducibility","text":"","category":"section"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"<details><summary>The documentation of this SciML package was built using these direct dependencies,</summary>","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"using Pkg # hide\nPkg.status() # hide","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"</details>","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"<details><summary>and using this machine and Julia version.</summary>","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"using InteractiveUtils # hide\nversioninfo() # hide","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"</details>","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"<details><summary>A more complete overview of all dependencies and their versions is also provided.</summary>","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"using Pkg # hide\nPkg.status(; mode = PKGMODE_MANIFEST) # hide","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"</details>","category":"page"},{"location":"","page":"OrdinaryDiffEq.jl: ODE solvers and utilities","title":"OrdinaryDiffEq.jl: ODE solvers and utilities","text":"using TOML\nusing Markdown\nversion = TOML.parse(read(\"../../Project.toml\", String))[\"version\"]\nname = TOML.parse(read(\"../../Project.toml\", String))[\"name\"]\nlink_manifest = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n                \"/assets/Manifest.toml\"\nlink_project = \"https://github.com/SciML/\" * name * \".jl/tree/gh-pages/v\" * version *\n               \"/assets/Project.toml\"\nMarkdown.parse(\"\"\"You can also download the\n[manifest]($link_manifest)\nfile and the\n[project]($link_project)\nfile.\n\"\"\")","category":"page"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK","text":"","category":"section"},{"location":"explicit/SSPRK/","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK","text":"SSPRK methods are Runge-Kutta methods which support the \"strongly preserving property\" (SSP). They are designed for the use in discretizations of hyperbolic partial differential equations and conservation laws as they have extra stability properties ( e.g., stability with respect to total variation, the maximum norm, or other convex functionals) when step-size restrictions are respected. In particular, these properties are granted if the step-size is kept to a level where the CFL coefficients are less than the SSP coefficient.","category":"page"},{"location":"explicit/SSPRK/","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK","text":"Note that for SSPRK methods, a algorithm utility OrdinaryDiffEqCore.ssp_coefficient(alg) exists that allows for querying the SSP coefficient for use in step size calculations.","category":"page"},{"location":"explicit/SSPRK/","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK","text":"first_steps = evalfile(\"./common_first_steps.jl\")\nfirst_steps(\"OrdinaryDiffEqSSPRK\", \"SSPRK22\")","category":"page"},{"location":"explicit/SSPRK/#Full-list-of-solvers","page":"OrdinaryDiffEqSSPRK","title":"Full list of solvers","text":"","category":"section"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK22","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK22","text":"SSPRK22(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A second-order, two-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nShu, Chi-Wang, and Stanley Osher.     Efficient implementation of essentially non-oscillatory shock-capturing schemes.     Journal of Computational Physics 77.2 (1988): 439-471.     https://doi.org/10.1016/0021-9991(88)90177-5\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK33","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK33","text":"SSPRK33(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, three-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nShu, Chi-Wang, and Stanley Osher.     Efficient implementation of essentially non-oscillatory shock-capturing schemes.     Journal of Computational Physics 77.2 (1988): 439-471.     https://doi.org/10.1016/0021-9991(88)90177-5\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK53","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK53","text":"SSPRK53(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, five-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRuuth, Steven.     Global optimization of explicit strong-stability-preserving Runge-Kutta methods.     Mathematics of Computation 75.253 (2006): 183-207\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.KYKSSPRK42","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.KYKSSPRK42","text":"KYKSSPRK42(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n             thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Optimal strong-stability-preserving Runge-Kutta time discretizations for discontinuous Galerkin methods\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kubatko2014optimal,     title={Optimal strong-stability-preserving Runge–Kutta time discretizations for discontinuous Galerkin methods},     author={Kubatko, Ethan J and Yeager, Benjamin A and Ketcheson, David I},     journal={Journal of Scientific Computing},     volume={60},     pages={313–344},     year={2014},     publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.KYK2014DGSSPRK_3S2","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.KYK2014DGSSPRK_3S2","text":"KYK2014DGSSPRK_3S2(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                     step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n                     thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  Optimal strong-stability-preserving Runge-Kutta time discretizations for discontinuous Galerkin methods\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\n@article{kubatko2014optimal, title={Optimal strong-stability-preserving Runge–Kutta time discretizations for discontinuous Galerkin methods}, author={Kubatko, Ethan J and Yeager, Benjamin A and Ketcheson, David I}, journal={Journal of Scientific Computing}, volume={60}, pages={313–344}, year={2014}, publisher={Springer}}\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK53_2N1","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK53_2N1","text":"SSPRK53_2N1(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, five-stage explicit strong stability preserving (SSP) low-storage method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nHigueras and T. Roldán.     New third order low-storage SSP explicit Runge–Kutta methods     arXiv:1809.04807v1.\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK53_2N2","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK53_2N2","text":"SSPRK53_2N2(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, five-stage explicit strong stability preserving (SSP) low-storage method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nHigueras and T. Roldán.     New third order low-storage SSP explicit Runge–Kutta methods     arXiv:1809.04807v1.\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK53_H","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK53_H","text":"SSPRK53_H(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n            thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, five-stage explicit strong stability preserving (SSP) low-storage method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nHigueras and T. Roldán.     New third order low-storage SSP explicit Runge–Kutta methods     arXiv:1809.04807v1.\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK63","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK63","text":"SSPRK63(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, six-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRuuth, Steven.     Global optimization of explicit strong-stability-preserving Runge-Kutta methods.     Mathematics of Computation 75.253 (2006): 183-207\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK73","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK73","text":"SSPRK73(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, seven-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRuuth, Steven.     Global optimization of explicit strong-stability-preserving Runge-Kutta methods.     Mathematics of Computation 75.253 (2006): 183-207\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK83","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK83","text":"SSPRK83(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, eight-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRuuth, Steven.     Global optimization of explicit strong-stability-preserving Runge-Kutta methods.     Mathematics of Computation 75.253 (2006): 183-207\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK43","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK43","text":"SSPRK43(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, four-stage explicit strong stability preserving (SSP) method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nOptimal third-order explicit SSP method with four stages discovered by\n\nJ. F. B. M. Kraaijevanger. \"Contractivity of Runge-Kutta methods.\" In: BIT Numerical Mathematics 31.3 (1991), pp. 482–528. DOI: 10.1007/BF01933264.\n\nEmbedded method constructed by\n\nSidafa Conde, Imre Fekete, John N. Shadid. \"Embedded error estimation and adaptive step-size control for optimal explicit strong stability preserving Runge–Kutta methods.\" arXiv: 1806.08693\n\nEfficient implementation (and optimized controller) developed by\n\nHendrik Ranocha, Lisandro Dalcin, Matteo Parsani, David I. Ketcheson (2021) Optimized Runge-Kutta Methods with Automatic Step Size Control for Compressible Computational Fluid Dynamics arXiv:2104.06836\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK432","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK432","text":"SSPRK432(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, four-stage explicit strong stability preserving (SSP) method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nGottlieb, Sigal, David I. Ketcheson, and Chi-Wang Shu.     Strong stability preserving Runge-Kutta and multistep time discretizations.     World Scientific, 2011.     Example 6.1\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRKMSVS43","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRKMSVS43","text":"SSPRKMSVS43(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, four-step explicit strong stability preserving (SSP) linear multistep method. This method does not come with an error estimator and requires a fixed time step size.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nShu, Chi-Wang.     Total-variation-diminishing time discretizations.     SIAM Journal on Scientific and Statistical Computing 9, no. 6 (1988): 1073-1084.     DOI: 10.1137/0909073\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRKMSVS32","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRKMSVS32","text":"SSPRKMSVS32(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n              thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A second-order, three-step explicit strong stability preserving (SSP) linear multistep method. This method does not come with an error estimator and requires a fixed time step size.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nShu, Chi-Wang.     Total-variation-diminishing time discretizations.     SIAM Journal on Scientific and Statistical Computing 9, no. 6 (1988): 1073-1084.     DOI: 10.1137/0909073\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK932","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK932","text":"SSPRK932(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A third-order, nine-stage explicit strong stability preserving (SSP) method.\n\nConsider using SSPRK43 instead, which uses the same main method and an improved embedded method.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nGottlieb, Sigal, David I. Ketcheson, and Chi-Wang Shu.     Strong stability preserving Runge-Kutta and multistep time discretizations.     World Scientific, 2011.\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK54","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK54","text":"SSPRK54(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n          thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A fourth-order, five-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nRuuth, Steven.     Global optimization of explicit strong-stability-preserving Runge-Kutta methods.     Mathematics of Computation 75.253 (2006): 183-207.\n\n\n\n\n\n","category":"type"},{"location":"explicit/SSPRK/#OrdinaryDiffEqSSPRK.SSPRK104","page":"OrdinaryDiffEqSSPRK","title":"OrdinaryDiffEqSSPRK.SSPRK104","text":"SSPRK104(; stage_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           step_limiter! = OrdinaryDiffEq.trivial_limiter!,\n           thread = OrdinaryDiffEq.False())\n\nExplicit Runge-Kutta Method.  A fourth-order, ten-stage explicit strong stability preserving (SSP) method. Fixed timestep only.\n\nKeyword Arguments\n\nstage_limiter!: function of the form limiter!(u, integrator, p, t)\nstep_limiter!: function of the form limiter!(u, integrator, p, t)\nthread: determines whether internal broadcasting on appropriate CPU arrays should be serial (thread = OrdinaryDiffEq.False()) or use multiple threads (thread = OrdinaryDiffEq.True()) when Julia is started with multiple threads.\n\nReferences\n\nKetcheson, David I.     Highly efficient strong stability-preserving Runge–Kutta methods with     low-storage implementations.     SIAM Journal on Scientific Computing 30.4 (2008): 2113-2136.\n\n\n\n\n\n","category":"type"},{"location":"imex/IMEXMultistep/#OrdinaryDiffEqIMEXMultistep","page":"OrdinaryDiffEqIMEXMultistep","title":"OrdinaryDiffEqIMEXMultistep","text":"","category":"section"},{"location":"imex/IMEXMultistep/","page":"OrdinaryDiffEqIMEXMultistep","title":"OrdinaryDiffEqIMEXMultistep","text":"Solvers if your system of ordinary differential equations can be split up into the sum of a stiff and non-stiff part. These are \"standard\" low order IMEX methods common in many naive partial differential equation applications.","category":"page"},{"location":"imex/IMEXMultistep/#Installation","page":"OrdinaryDiffEqIMEXMultistep","title":"Installation","text":"","category":"section"},{"location":"imex/IMEXMultistep/","page":"OrdinaryDiffEqIMEXMultistep","title":"OrdinaryDiffEqIMEXMultistep","text":"To be able to access the solvers in OrdinaryDiffEqIMEXMultistep, you must first install them use the Julia package manager:","category":"page"},{"location":"imex/IMEXMultistep/","page":"OrdinaryDiffEqIMEXMultistep","title":"OrdinaryDiffEqIMEXMultistep","text":"using Pkg\nPkg.add(\"OrdinaryDiffEqIMEXMultistep\")","category":"page"},{"location":"imex/IMEXMultistep/","page":"OrdinaryDiffEqIMEXMultistep","title":"OrdinaryDiffEqIMEXMultistep","text":"This will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.","category":"page"},{"location":"imex/IMEXMultistep/#Example-usage","page":"OrdinaryDiffEqIMEXMultistep","title":"Example usage","text":"","category":"section"},{"location":"imex/IMEXMultistep/","page":"OrdinaryDiffEqIMEXMultistep","title":"OrdinaryDiffEqIMEXMultistep","text":"using OrdinaryDiffEqIMEXMultistep\nf1 = (u, p, t) -> 2u\nf2 = (u, p, t) -> 2u\nu0 = 1.0\ntspan = (0.0, 1.0)\nprob = SplitODEProblem(f1, f2, u0, tspan)\nsol = solve(prob, CNAB2(), dt = 1 / 10)","category":"page"},{"location":"imex/IMEXMultistep/#Full-list-of-solvers","page":"OrdinaryDiffEqIMEXMultistep","title":"Full list of solvers","text":"","category":"section"},{"location":"imex/IMEXMultistep/#OrdinaryDiffEqIMEXMultistep.CNAB2","page":"OrdinaryDiffEqIMEXMultistep","title":"OrdinaryDiffEqIMEXMultistep.CNAB2","text":"CNAB2()\n\nIMEX Multistep method. Crank-Nicholson Adams-Bashforth 2.\n\nKeyword Arguments\n\nReferences\n\n@article{jorgenson2014unconditional,     title={Unconditional stability of a Crank-Nicolson Adams-Bashforth 2 numerical method},     author={JORGENSON, ANDREW D},     journal={A (A- C)},     volume={1},     number={2},     pages={1},     year={2014}}     @article{he2010numerical,     title={Numerical implementation of the Crank–Nicolson/Adams–Bashforth scheme for the time-dependent Navier–Stokes equations},     author={He, Yinnian and Li, Jian},     journal={International journal for numerical methods in fluids},     volume={62},     number={6},     pages={647–659},     year={2010},     publisher={Wiley Online Library}}\n\n\n\n\n\n","category":"type"},{"location":"imex/IMEXMultistep/#OrdinaryDiffEqIMEXMultistep.CNLF2","page":"OrdinaryDiffEqIMEXMultistep","title":"OrdinaryDiffEqIMEXMultistep.CNLF2","text":"CNLF2()\n\nIMEX Multistep method. Crank-Nicholson Leapfrong 2.\n\nKeyword Arguments\n\nReferences\n\n@article{han2020second,     title={A second order, linear, unconditionally stable, Crank–Nicolson–Leapfrog scheme for phase field models of two-phase incompressible flows},     author={Han, Daozhi and Jiang, Nan},     journal={Applied Mathematics Letters},     volume={108},     pages={106521},     year={2020},     publisher={Elsevier}}     @article{jiang2015crank,     title={A Crank–Nicolson Leapfrog stabilization: Unconditional stability and two applications},     author={Jiang, Nan and Kubacki, Michaela and Layton, William and Moraiti, Marina and Tran, Hoang},     journal={Journal of Computational and Applied Mathematics},     volume={281},     pages={263–276},     year={2015},     publisher={Elsevier}}\n\n\n\n\n\n","category":"type"}]
}
