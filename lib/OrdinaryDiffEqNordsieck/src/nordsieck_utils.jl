function nordsieck_adjust!(integrator, cache::T) where {T}
    @unpack nextorder, order = cache
    if nextorder != order
        # TODO: optimize?
        nordsieck_adjust_order!(cache, nextorder - order)
        cache.order = cache.nextorder
        cache.L = cache.order + 1
        cache.n_wait = cache.L
    end
    nordsieck_rescale!(cache)
    return nothing
end

# TODO: SUNDIALS NLsolve handling

function nordsieck_finalize!(integrator, cache::T) where {T}
    isconst = T <: OrdinaryDiffEqConstantCache
    @unpack order, dts = cache
    update_nordsieck_vector!(cache)
    cache.n_wait -= 1
    if is_nordsieck_change_order(cache, 1) && cache.order != 12
        if isconst
            cache.z[end] = cache.Œî
        else
            @.. broadcast=false cache.z[end]=cache.Œî
        end
        cache.prev_ùíü = cache.c_ùíü
    end
end

function nordsieck_prepare_next!(integrator, cache::T) where {T}
    isconst = T <: OrdinaryDiffEqConstantCache
    @unpack maxŒ∑, order, L = cache
    # TODO: further clean up
    @unpack bias1, bias2, bias3, addon = integrator.alg
    if integrator.EEst > one(integrator.EEst)
        nordsieck_rewind!(cache)
        cache.n_wait = max(2, cache.n_wait)
        cache.nextorder = order
        cache.Œ∑ = inv((bias2 * integrator.EEst)^inv(L) + addon)
        return nothing
    end
    cache.Œ∑q = inv((bias2 * integrator.EEst)^inv(L) + addon)
    stepsize_Œ∑!(integrator, cache, cache.order)
    if !is_nordsieck_change_order(cache)
        cache.Œ∑ = cache.Œ∑q
        cache.nextorder = order
        setŒ∑!(integrator, cache)
        return nothing
    end
    # On an order change (cache.n_wait == 0), we are going to compute the Œ∑ for
    # order q+1 and q-1, where Œ∑ = dt_next/dt
    cache.n_wait = 2
    stepsize_Œ∑‚Çä‚ÇÅ!(integrator, cache, order)
    stepsize_Œ∑‚Çã‚ÇÅ!(integrator, cache, order)
    chooseŒ∑!(integrator, cache)
    setŒ∑!(integrator, cache)
    # TODO: Maybe not here
    if isconst
        cache.Œî = cache.c_LTE * cache.Œî
    else
        @.. broadcast=false cache.Œî=cache.c_LTE * cache.Œî
    end
    return nothing
end

##############################################################
# Lower level functions
##############################################################

# This function computes the integral, from -1 to 0, of a polynomial
# `P(x)` from the coefficients of `P` with an offset `k`.
function ‚à´‚Çã‚ÇÅ‚Å∞dx(a, deg, k)
    @inbounds begin
        int = zero(eltype(a))
        sign = 1
        for i in 0:deg
            int += flipsign(a[i + 1] / (i + k), sign)
            sign = -sign
        end
        return int
    end
end

# `l` is the coefficients of the polynomial `Œõ` that satisfies conditions
# Œõ(0) = 1, Œõ(-1) = 0, and ŒõÃá(-Œæ·µ¢) = 0, where Œæ·µ¢ = (t‚Çô-t‚Çô‚Çã‚ÇÅ)/dt.
# It is described in the paper "A Polyalgorithm for the Numerical Solution
# of Ordinary Differential Equations" by G. D. Byrne and A. C. Hindmarsh in
# the page 86.
# https://dl.acm.org/citation.cfm?id=355636

# More implementation details are in the
# https://github.com/JuliaDiffEq/DiffEqDevMaterials repository
function calc_coeff!(cache::T) where {T}
    isvode = (T <: JVODECache || T <: JVODEConstantCache)
    @inbounds begin
        isconst = T <: OrdinaryDiffEqConstantCache
        isvarorder = is_nordsieck_change_order(cache, 1)
        @unpack m, l, dts, order = cache
        dtsum = dt = dts[1]
        if order == 1
            l[1] = l[2] = cache.c_LTE‚Çã‚ÇÅ = cache.c_ùíü = 1
            cache.c_LTE = 1 // 2
            cache.c_LTE‚Çä‚ÇÅ = 1 // 12
            cache.c_conv = 1 // 10 / cache.c_LTE
            return nothing
        end
        m[1] = 1
        for i in 2:(order + 1)
            m[i] = 0
        end
        # initialize Œæ_inv
        Œæ_inv = dt / dtsum
        # compute coefficients from the Newton polynomial
        # check the `JuliaDiffEq/DiffEqDevMaterials` repository for more details
        for j in 1:(order - 1)
            if isvarorder && j == order - 1
                M‚Çã‚ÇÅ = ‚à´‚Çã‚ÇÅ‚Å∞dx(m, order - 2, 2)
                # It is the same with `tq[1]` in SUNDIALS cvode.c
                cache.c_LTE‚Çã‚ÇÅ = order * M‚Çã‚ÇÅ / m[order - 1]
            end
            Œæ_inv = dt / dtsum
            for i in j:-1:1
                m[i + 1] = muladd(m[i], Œæ_inv, m[i + 1])
            end
            dtsum += dts[j + 1]
        end
        Œæ_inv = dt / dtsum

        M0 = ‚à´‚Çã‚ÇÅ‚Å∞dx(m, order - 1, 1)
        M1 = ‚à´‚Çã‚ÇÅ‚Å∞dx(m, order - 1, 2)
        M0_inv = inv(M0)
        l[1] = 1
        for i in 1:order
            l[i + 1] = M0_inv * m[i] / i
        end
        # TODO: simplify LTE calculation
        # This is the error estimation coefficient for the current order `q`
        # ||Œî||‚ãÖc_LTE yields the difference between a `q` degree interpolating
        # polynomial and a `q+1` degree interpolating polynomial at time `t`.
        # It is the same with `tq[2]` in SUNDIALS cvode.c
        cache.c_LTE = M1 * M0_inv * Œæ_inv
        # It is the same with `tq[5]` in SUNDIALS cvode.c
        isvode && (cache.c_ùíü = inv(Œæ_inv) / l[order + 1])
        if isvarorder
            for i in order:-1:1
                m[i + 1] = muladd(Œæ_inv, m[i], m[i + 1])
            end
            M2 = ‚à´‚Çã‚ÇÅ‚Å∞dx(m, order, 2)
            # It is the same with `tq[3]` in SUNDIALS cvode.c
            cache.c_LTE‚Çä‚ÇÅ = M2 * M0_inv / (order + 1)
        end # endif isvarorder
        # It is the same with `tq[4]` in SUNDIALS cvode.c
        cache.c_conv = 1 // 10 / cache.c_LTE
        return nothing
    end # end @inbounds
end

# Apply the Pascal linear operator
function perform_predict!(cache::T, rewind = false) where {T}
    @inbounds begin
        isconst = T <: OrdinaryDiffEqConstantCache
        @unpack z, order = cache
        # This can be parallelized
        if !rewind
            if isconst
                for i in 1:order, j in order:-1:i
                    z[j] = z[j] + z[j + 1]
                end
            else
                for i in 1:order, j in order:-1:i
                    @.. broadcast=false z[j]=z[j] + z[j + 1]
                end
            end # endif const cache
        else
            if isconst
                for i in 1:order, j in order:-1:i
                    z[j] = z[j] - z[j + 1]
                end
            else
                for i in 1:order, j in order:-1:i
                    @.. broadcast=false z[j]=z[j] - z[j + 1]
                end
            end # endif const cache
        end # endif !rewind
    end # end @inbounds
end

# Apply corrections on the Nordsieck vector
function update_nordsieck_vector!(cache::T) where {T}
    isvode = (T <: JVODECache || T <: JVODEConstantCache)
    @inbounds begin
        isconst = T <: OrdinaryDiffEqConstantCache
        @unpack z, Œî, l, order = cache
        if isconst
            for i in 1:(order + 1)
                z[i] = muladd.(l[i], Œî, z[i])
            end
        else
            for i in 1:(order + 1)
                @.. broadcast=false z[i]=muladd(l[i], Œî, z[i])
            end
        end # endif not const cache
    end # end @inbounds
end

function nlsolve_functional!(integrator, cache::T) where {T}
    @unpack f, dt, t, p = integrator
    isconstcache = T <: OrdinaryDiffEqConstantCache
    @unpack z, l, c_conv, Œî = cache
    if isconstcache
        ratetmp = integrator.f(z[1], p, dt + t)
    else
        @unpack ratetmp = cache
        integrator.f(ratetmp, z[1], p, dt + t)
    end
    OrdinaryDiffEqCore.increment_nf!(integrator.stats, 1)
    maxiters = 3
    div_rate = 2
    # Zero out the difference vector
    isconstcache ? (cache.Œî = zero(cache.Œî)) : (Œî .= zero(eltype(Œî)))
    # `k` is a counter for convergence test
    k = 0
    # `conv_rate` is used in convergence rate estimation
    conv_rate = 1.0
    # initialize `Œ¥_prev`
    Œ¥_prev = 0
    # Start the functional iteration & store the difference into `Œî`
    for k in 1:maxiters
        if isconstcache
            ratetmp = inv(l[2]) * muladd.(dt, ratetmp, -z[2])
            integrator.u = ratetmp + z[1]
            cache.Œî = ratetmp - cache.Œî
        else
            @.. broadcast=false integrator.u=-z[2]
            @.. broadcast=false ratetmp=inv(l[2]) * muladd(dt, ratetmp, integrator.u)
            @.. broadcast=false integrator.u=ratetmp + z[1]
            @.. broadcast=false cache.Œî=ratetmp - cache.Œî
        end
        # @show norm(dt*ratetmp - ( z[2] + (integrator.u - z[1])*l[2] ))
        # @show norm(cache.Œî - (integrator.u - z[1]))
        # It only makes sense to calculate convergence rate in the second iteration
        Œ¥ = integrator.opts.internalnorm(cache.Œî, t)
        isconstcache ? (cache.Œî = copy(ratetmp)) : copyto!(cache.Œî, ratetmp)
        if k >= 1
            conv_rate = max(1 // 10 * conv_rate, Œ¥ / Œ¥_prev)
        end
        test_rate = Œ¥ * min(one(conv_rate), conv_rate) / c_conv
        if test_rate <= one(test_rate)
            return true
        end
        # Divergence criteria
        if ((k == maxiters) || (k >= 2 && Œ¥ > div_rate * Œ¥_prev))
            return false
        end
        Œ¥_prev = Œ¥
        OrdinaryDiffEqCore.increment_nf!(integrator.stats, 1)
        isconstcache ? (ratetmp = integrator.f(integrator.u, p, dt + t)) :
        integrator.f(ratetmp, integrator.u, p, dt + t)
    end
end

function nordsieck_rescale!(cache::T, rewind = false) where {T}
    isconstcache = T <: OrdinaryDiffEqConstantCache
    @unpack z, dts, order = cache
    eta = rewind ? dts[2] / dts[1] : dts[1] / dts[2]
    factor = eta
    for i in 2:(order + 1)
        if isconstcache
            z[i] = z[i] * factor
        else
            rmul!(z[i], factor)
        end
        factor *= eta
    end
    return nothing
end

function nordsieck_rewind!(cache)
    perform_predict!(cache, true)
    nordsieck_rescale!(cache, true)
end

function is_nordsieck_change_order(cache::T, n = 0) where {T}
    isconstcache = T <: OrdinaryDiffEqConstantCache
    isvode = (T <: JVODECache || T <: JVODEConstantCache)
    isvode || return false
    cache.n_wait == 0 + n
end

function nordsieck_decrement_wait!(cache::T) where {T}
    isvode = (T <: JVODECache || T <: JVODEConstantCache)
    isvode || return nothing
    isconstcache = T <: OrdinaryDiffEqConstantCache
    cache.n_wait = max(0, cache.n_wait - 1)
    return nothing
end

function nordsieck_adjust_order!(cache::T, dorder) where {T}
    isconstcache = T <: OrdinaryDiffEqConstantCache
    @unpack order, dts = cache
    # WIP: uncomment when finished
    #@inbound begin
    begin
        # Adams order increase
        if dorder == 1
            if isconstcache
                cache.z[order + 2] = zero(cache.z[order + 2])
            else
                cache.z[order + 2] .= 0
            end
        else
            # Adams order decrease
            # One needs to rescale the Nordsieck vector on an order decrease
            cache.l .= 0
            cache.l[2] = 1
            dt = dts[1]
            hsum = zero(eltype(cache.dts))
            for j in 1:(order - 2)
                hsum += cache.dts[j + 1]
                # TODO: `hscale`?
                Œæ = hsum / dt
                for i in (j + 1):-1:1
                    cache.l[i + 1] = cache.l[i + 1] * Œæ + cache.l[i]
                end # for i
            end # for j

            for j in 2:(order - 1)
                cache.l[j + 1] = order * cache.l[j] / j
            end
            for j in 3:order
                if isconstcache
                    cache.z[j] = muladd.(-cache.l[j], cache.z[order + 1], cache.z[j])
                else
                    @.. broadcast=false cache.z[j]=muladd(-cache.l[j], cache.z[order + 1],
                        cache.z[j])
                end
            end # for j
        end # else
    end # @inbound
end

# `Œ∑` is `dt‚Çô‚Çä‚ÇÅ/dt‚Çô`
function setŒ∑!(integrator, cache::T) where {T}
    if cache.Œ∑ < integrator.opts.qsteady_max
        cache.Œ∑ = 1
    else
        # TODO: Not the same with SUNDIALS
        (integrator.iter == 1 || integrator.u_modified) &&
            (cache.Œ∑ = min(1e5, cache.Œ∑); return nothing)
        cache.Œ∑ = min(integrator.opts.qmax, max(integrator.opts.qmin, cache.Œ∑))
    end
    return nothing
end

function chooseŒ∑!(integrator, cache::T) where {T}
    isconst = T <: OrdinaryDiffEqConstantCache
    @unpack Œ∑q, Œ∑‚Çã‚ÇÅ, Œ∑‚Çä‚ÇÅ, order, z, Œî = cache
    Œ∑ = max(Œ∑q, Œ∑‚Çã‚ÇÅ, Œ∑‚Çä‚ÇÅ)
    if Œ∑ < integrator.opts.qsteady_max
        cache.Œ∑ = 1
        cache.nextorder = order
    end

    if Œ∑ == Œ∑q
        cache.Œ∑ = cache.Œ∑q
        cache.nextorder = order
    elseif Œ∑ == Œ∑‚Çã‚ÇÅ
        cache.Œ∑ = cache.Œ∑‚Çã‚ÇÅ
        cache.nextorder = order - 1
    else
        cache.Œ∑ = cache.Œ∑‚Çä‚ÇÅ
        cache.nextorder = order + 1
        # TODO: BDF
        if integrator.alg.algorithm == :BDF
            if isconst
                z[end] = Œî
            else
                @.. broadcast=false z[end]=Œî
            end
        end #endif BDF
    end # endif Œ∑ == Œ∑q
    return nothing
end

function stepsize_Œ∑!(integrator, cache, order)
    bias2 = integrator.alg.bias2
    addon = integrator.alg.addon
    L = order + 1
    cache.Œ∑q = inv((bias2 * integrator.EEst)^inv(L) + addon)
    return cache.Œ∑q
end

# TODO: Check them
function stepsize_Œ∑‚Çä‚ÇÅ!(integrator, cache::T, order) where {T}
    isconstcache = T <: OrdinaryDiffEqConstantCache
    isconstcache || (@unpack atmp, ratetmp = cache)
    @unpack uprev, t, u = integrator
    @unpack z, c_LTE‚Çä‚ÇÅ, dts, c_ùíü = cache
    bias3 = integrator.alg.bias3
    addon = integrator.alg.addon
    q = order
    cache.Œ∑‚Çä‚ÇÅ = 0
    qmax = length(z) - 1
    L = q + 1
    if q != qmax
        cache.prev_ùíü == 0 && return cache.Œ∑‚Çä‚ÇÅ
        cquot = (c_ùíü / cache.prev_ùíü) * (dts[1] / dts[2])^L
        if isconstcache
            atmp = muladd.(-cquot, z[end], cache.Œî)
            atmp = calculate_residuals(atmp, uprev, u, integrator.opts.abstol,
                integrator.opts.reltol, integrator.opts.internalnorm,
                t)
        else
            @.. broadcast=false ratetmp=muladd(-cquot, z[end], cache.Œî)
            calculate_residuals!(atmp, ratetmp, uprev, u, integrator.opts.abstol,
                integrator.opts.reltol, integrator.opts.internalnorm, t)
        end
        dup = integrator.opts.internalnorm(atmp, t) * c_LTE‚Çä‚ÇÅ
        cache.Œ∑‚Çä‚ÇÅ = inv((bias3 * dup)^inv(L + 1) + addon)
    end
    return cache.Œ∑‚Çä‚ÇÅ
end

function stepsize_Œ∑‚Çã‚ÇÅ!(integrator, cache::T, order) where {T}
    isconstcache = T <: OrdinaryDiffEqConstantCache
    isconstcache || (atmp = cache.atmp)
    @unpack uprev, t, u = integrator
    @unpack z, c_LTE‚Çã‚ÇÅ = cache
    bias1 = integrator.alg.bias1
    addon = integrator.alg.addon
    cache.Œ∑‚Çã‚ÇÅ = 0
    if order > 1
        if isconstcache
            atmp = calculate_residuals(z[order + 1], uprev, u, integrator.opts.abstol,
                integrator.opts.reltol, integrator.opts.internalnorm,
                t)
        else
            calculate_residuals!(atmp, z[order + 1], uprev, u, integrator.opts.abstol,
                integrator.opts.reltol, integrator.opts.internalnorm, t)
        end
        approx = integrator.opts.internalnorm(atmp, t) * c_LTE‚Çã‚ÇÅ
        cache.Œ∑‚Çã‚ÇÅ = inv((bias1 * approx)^inv(order) + addon)
    end
    return cache.Œ∑‚Çã‚ÇÅ
end
