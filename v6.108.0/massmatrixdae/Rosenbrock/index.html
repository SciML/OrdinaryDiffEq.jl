<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>OrdinaryDiffEqRosenbrock · OrdinaryDiffEq.jl</title><meta name="title" content="OrdinaryDiffEqRosenbrock · OrdinaryDiffEq.jl"/><meta property="og:title" content="OrdinaryDiffEqRosenbrock · OrdinaryDiffEq.jl"/><meta property="twitter:title" content="OrdinaryDiffEqRosenbrock · OrdinaryDiffEq.jl"/><meta name="description" content="Documentation for OrdinaryDiffEq.jl."/><meta property="og:description" content="Documentation for OrdinaryDiffEq.jl."/><meta property="twitter:description" content="Documentation for OrdinaryDiffEq.jl."/><meta property="og:url" content="https://ordinarydiffeq.sciml.ai/stable/massmatrixdae/Rosenbrock/"/><meta property="twitter:url" content="https://ordinarydiffeq.sciml.ai/stable/massmatrixdae/Rosenbrock/"/><link rel="canonical" href="https://ordinarydiffeq.sciml.ai/stable/massmatrixdae/Rosenbrock/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="OrdinaryDiffEq.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">OrdinaryDiffEq.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">OrdinaryDiffEq.jl: ODE solvers and utilities</a></li><li><a class="tocitem" href="../../usage/">Usage</a></li><li><span class="tocitem">Explicit Solvers</span><ul><li><a class="tocitem" href="../../explicit/Tsit5/">OrdinaryDiffEqTsit5</a></li><li><a class="tocitem" href="../../explicit/Verner/">OrdinaryDiffEqVerner</a></li><li><a class="tocitem" href="../../explicit/AdamsBashforthMoulton/">OrdinaryDiffEqAdamsBashforthMoulton</a></li><li><a class="tocitem" href="../../explicit/LowStorageRK/">OrdinaryDiffEqLowStorageRK</a></li><li><a class="tocitem" href="../../explicit/SSPRK/">OrdinaryDiffEqSSPRK</a></li><li><a class="tocitem" href="../../explicit/LowOrderRK/">OrdinaryDiffEqLowOrderRK</a></li><li><a class="tocitem" href="../../explicit/HighOrderRK/">OrdinaryDiffEqHighOrderRK</a></li><li><a class="tocitem" href="../../explicit/Feagin/">OrdinaryDiffEqFeagin</a></li><li><a class="tocitem" href="../../explicit/PRK/">OrdinaryDiffEqPRK</a></li><li><a class="tocitem" href="../../explicit/QPRK/">OrdinaryDiffEqQPRK</a></li><li><a class="tocitem" href="../../explicit/TaylorSeries/">OrdinaryDiffEqTaylorSeries</a></li><li><a class="tocitem" href="../../explicit/Extrapolation/">OrdinaryDiffEqExtrapolation</a></li></ul></li><li><span class="tocitem">Semi-Implicit Solvers</span><ul><li><a class="tocitem" href="../../semiimplicit/Rosenbrock/">OrdinaryDiffEqRosenbrock</a></li><li><a class="tocitem" href="../../semiimplicit/StabilizedRK/">OrdinaryDiffEqStabilizedRK</a></li><li><a class="tocitem" href="../../semiimplicit/ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li></ul></li><li><span class="tocitem">Implicit Solvers</span><ul><li><a class="tocitem" href="../../implicit/SDIRK/">OrdinaryDiffEqSDIRK</a></li><li><a class="tocitem" href="../../implicit/FIRK/">OrdinaryDiffEqFIRK</a></li><li><a class="tocitem" href="../../implicit/BDF/">OrdinaryDiffEqBDF</a></li><li><a class="tocitem" href="../../implicit/Extrapolation/">OrdinaryDiffEqExtrapolation</a></li><li><a class="tocitem" href="../../implicit/PDIRK/">OrdinaryDiffEqPDIRK</a></li><li><a class="tocitem" href="../../implicit/Nordsieck/">OrdinaryDiffEqNordsieck</a></li></ul></li><li><span class="tocitem">IMEX Solvers</span><ul><li><a class="tocitem" href="../../imex/IMEXMultistep/">OrdinaryDiffEqIMEXMultistep</a></li><li><a class="tocitem" href="../../imex/StabilizedIRK/">OrdinaryDiffEqStabilizedIRK</a></li><li><a class="tocitem" href="../../imex/IMEXBDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><span class="tocitem">Dynamical ODE Explicit Solvers</span><ul><li><a class="tocitem" href="../../dynamicalodeexplicit/RKN/">OrdinaryDiffEqRKN</a></li><li><a class="tocitem" href="../../dynamicalodeexplicit/SymplecticRK/">OrdinaryDiffEqSymplecticRK</a></li></ul></li><li><span class="tocitem">Semilinear ODE Solvers</span><ul><li><a class="tocitem" href="../../semilinear/ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li><li><a class="tocitem" href="../../semilinear/Linear/">OrdinaryDiffEqLinear</a></li></ul></li><li><span class="tocitem">Mass Matrix DAE Solvers</span><ul><li class="is-active"><a class="tocitem" href>OrdinaryDiffEqRosenbrock</a><ul class="internal"><li><a class="tocitem" href="#Key-Properties"><span>Key Properties</span></a></li><li><a class="tocitem" href="#When-to-Use-Mass-Matrix-Rosenbrock-Methods"><span>When to Use Mass Matrix Rosenbrock Methods</span></a></li><li><a class="tocitem" href="#Mathematical-Background"><span>Mathematical Background</span></a></li><li><a class="tocitem" href="#Solver-Selection-Guide"><span>Solver Selection Guide</span></a></li><li><a class="tocitem" href="#Performance-Guidelines"><span>Performance Guidelines</span></a></li><li><a class="tocitem" href="#Important-DAE-Considerations"><span>Important DAE Considerations</span></a></li><li><a class="tocitem" href="#Alternative-Approaches"><span>Alternative Approaches</span></a></li><li><a class="tocitem" href="#Example-Usage"><span>Example Usage</span></a></li><li><a class="tocitem" href="#Full-list-of-solvers"><span>Full list of solvers</span></a></li></ul></li><li><a class="tocitem" href="../BDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><span class="tocitem">Fully Implicit DAE Solvers</span><ul><li><a class="tocitem" href="../../fullyimplicitdae/BDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><span class="tocitem">Misc Solvers</span><ul><li><a class="tocitem" href="../../misc/">Miscellaneous Solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Mass Matrix DAE Solvers</a></li><li class="is-active"><a href>OrdinaryDiffEqRosenbrock</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>OrdinaryDiffEqRosenbrock</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/OrdinaryDiffEq.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/master/docs/src/massmatrixdae/Rosenbrock.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="OrdinaryDiffEqRosenbrock"><a class="docs-heading-anchor" href="#OrdinaryDiffEqRosenbrock">OrdinaryDiffEqRosenbrock</a><a id="OrdinaryDiffEqRosenbrock-1"></a><a class="docs-heading-anchor-permalink" href="#OrdinaryDiffEqRosenbrock" title="Permalink"></a></h1><p>Rosenbrock methods for mass matrix differential-algebraic equations (DAEs) and stiff ODEs with singular mass matrices. These methods provide efficient integration for moderately stiff systems with algebraic constraints, offering excellent performance for small to medium-sized DAE problems.</p><h2 id="Key-Properties"><a class="docs-heading-anchor" href="#Key-Properties">Key Properties</a><a id="Key-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Properties" title="Permalink"></a></h2><p>Mass matrix Rosenbrock methods provide:</p><ul><li><strong>DAE capability</strong> for index-1 differential-algebraic equations</li><li><strong>W-method efficiency</strong> using approximate Jacobians for computational savings</li><li><strong>Mass matrix support</strong> for singular and non-diagonal mass matrices</li><li><strong>Moderate to high order accuracy</strong> (2nd to 6th order available)</li><li><strong>Good stability properties</strong> with stiffly accurate behavior</li><li><strong>Embedded error estimation</strong> for adaptive timestepping</li></ul><h2 id="When-to-Use-Mass-Matrix-Rosenbrock-Methods"><a class="docs-heading-anchor" href="#When-to-Use-Mass-Matrix-Rosenbrock-Methods">When to Use Mass Matrix Rosenbrock Methods</a><a id="When-to-Use-Mass-Matrix-Rosenbrock-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-Mass-Matrix-Rosenbrock-Methods" title="Permalink"></a></h2><p>These methods are recommended for:</p><ul><li><strong>Index-1 DAE systems</strong> with moderate stiffness</li><li><strong>Small to medium constrained systems</strong> (&lt; 1000 equations)</li><li><strong>Semi-explicit DAEs</strong> arising from discretized PDEs</li><li><strong>Problems requiring good accuracy</strong> with moderate computational cost</li><li><strong>DAEs with moderate nonlinearity</strong> where W-methods are efficient</li><li><strong>Electrical circuits</strong> and <strong>mechanical systems</strong> with constraints</li></ul><div class="admonition is-category-warn" id="Warn-b94721a3a6ee53e9"><header class="admonition-header">Warn<a class="admonition-anchor" href="#Warn-b94721a3a6ee53e9" title="Permalink"></a></header><div class="admonition-body"><p>In order to use OrdinaryDiffEqRosenbrock with DAEs that require a non-trivial consistent initialization, a nonlinear solver is required and thus <code>using OrdinaryDiffEqNonlinearSolve</code> is required or you must pass an <code>initializealg</code> with a valid <code>nlsolve</code> choice.</p></div></div><h2 id="Mathematical-Background"><a class="docs-heading-anchor" href="#Mathematical-Background">Mathematical Background</a><a id="Mathematical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background" title="Permalink"></a></h2><p>Mass matrix DAEs have the form: <code>M du/dt = f(u,t)</code></p><p>Rosenbrock methods linearize around the current solution and solve linear systems of the form: <code>(M/γh - J) k_i = ...</code></p><p>where J is the Jacobian of f and γ is a method parameter.</p><h2 id="Solver-Selection-Guide"><a class="docs-heading-anchor" href="#Solver-Selection-Guide">Solver Selection Guide</a><a id="Solver-Selection-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-Selection-Guide" title="Permalink"></a></h2><h3 id="Recommended-Methods-by-Tolerance"><a class="docs-heading-anchor" href="#Recommended-Methods-by-Tolerance">Recommended Methods by Tolerance</a><a id="Recommended-Methods-by-Tolerance-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-Methods-by-Tolerance" title="Permalink"></a></h3><ul><li><strong>High tolerances</strong> (&gt;1e-2): <strong><code>Rosenbrock23</code></strong> - efficient low-order method</li><li><strong>Medium tolerances</strong> (1e-8 to 1e-2): <strong><code>Rodas5P</code></strong> - most efficient choice, or <strong><code>Rodas4P</code></strong> for higher reliability</li><li><strong>Low tolerances</strong> (&lt;1e-8): <strong><code>Rodas5Pe</code></strong> or higher-order alternatives</li></ul><h3 id="Method-families"><a class="docs-heading-anchor" href="#Method-families">Method families</a><a id="Method-families-1"></a><a class="docs-heading-anchor-permalink" href="#Method-families" title="Permalink"></a></h3><ul><li><strong><code>Rodas5P</code></strong>: <strong>Recommended</strong> - Most efficient 5th-order method for general use</li><li><strong><code>Rodas4P</code></strong>: More reliable 4th-order alternative</li><li><strong><code>Rosenbrock23</code></strong>: Good for high tolerance problems</li><li><strong><code>Rodas5</code></strong>: Standard 5th-order method without embedded pair optimization</li></ul><h2 id="Performance-Guidelines"><a class="docs-heading-anchor" href="#Performance-Guidelines">Performance Guidelines</a><a id="Performance-Guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Guidelines" title="Permalink"></a></h2><h3 id="When-mass-matrix-Rosenbrock-methods-excel"><a class="docs-heading-anchor" href="#When-mass-matrix-Rosenbrock-methods-excel">When mass matrix Rosenbrock methods excel</a><a id="When-mass-matrix-Rosenbrock-methods-excel-1"></a><a class="docs-heading-anchor-permalink" href="#When-mass-matrix-Rosenbrock-methods-excel" title="Permalink"></a></h3><ul><li><strong>Small to medium DAE systems</strong> (&lt; 1000 equations)</li><li><strong>Moderately stiff problems</strong> where full BDF methods are overkill</li><li><strong>Problems with efficient Jacobian computation</strong> or finite difference approximation</li><li><strong>Index-1 DAEs with well-conditioned mass matrices</strong></li><li><strong>Semi-explicit index-1 problems</strong> from spatial discretizations</li></ul><h3 id="System-size-considerations"><a class="docs-heading-anchor" href="#System-size-considerations">System size considerations</a><a id="System-size-considerations-1"></a><a class="docs-heading-anchor-permalink" href="#System-size-considerations" title="Permalink"></a></h3><ul><li><strong>Small systems</strong> (&lt; 100): Rosenbrock methods often outperform multistep methods</li><li><strong>Medium systems</strong> (100-1000): Good performance with proper linear algebra</li><li><strong>Large systems</strong> (&gt; 1000): Consider BDF methods instead</li></ul><h2 id="Important-DAE-Considerations"><a class="docs-heading-anchor" href="#Important-DAE-Considerations">Important DAE Considerations</a><a id="Important-DAE-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Important-DAE-Considerations" title="Permalink"></a></h2><h3 id="Initial-conditions"><a class="docs-heading-anchor" href="#Initial-conditions">Initial conditions</a><a id="Initial-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-conditions" title="Permalink"></a></h3><ul><li><strong>Must be consistent</strong> with algebraic constraints</li><li><strong>Consistent initialization</strong> may require nonlinear solver</li><li><strong>Index-1 assumption</strong> for reliable performance</li></ul><h3 id="Mass-matrix-requirements"><a class="docs-heading-anchor" href="#Mass-matrix-requirements">Mass matrix requirements</a><a id="Mass-matrix-requirements-1"></a><a class="docs-heading-anchor-permalink" href="#Mass-matrix-requirements" title="Permalink"></a></h3><ul><li><strong>Index-1 DAE structure</strong> for optimal performance</li><li><strong>Non-singular leading submatrix</strong> for differential variables</li><li><strong>Well-conditioned constraint equations</strong></li></ul><h2 id="Alternative-Approaches"><a class="docs-heading-anchor" href="#Alternative-Approaches">Alternative Approaches</a><a id="Alternative-Approaches-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-Approaches" title="Permalink"></a></h2><p>Consider these alternatives:</p><ul><li><strong>Mass matrix BDF methods</strong> for larger or highly stiff DAE systems</li><li><strong>Implicit Runge-Kutta methods</strong> for higher accuracy requirements</li><li><strong>Standard Rosenbrock methods</strong> for regular ODEs without constraints</li><li><strong>IMEX methods</strong> if natural explicit/implicit splitting exists</li></ul><h2 id="Example-Usage"><a class="docs-heading-anchor" href="#Example-Usage">Example Usage</a><a id="Example-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Example-Usage" title="Permalink"></a></h2><pre><code class="language-julia hljs">using LinearAlgebra: Diagonal
function rober(du, u, p, t)
    y₁, y₂, y₃ = u
    k₁, k₂, k₃ = p
    du[1] = -k₁ * y₁ + k₃ * y₂ * y₃
    du[2] = k₁ * y₁ - k₃ * y₂ * y₃ - k₂ * y₂^2
    du[3] = y₁ + y₂ + y₃ - 1
    nothing
end
M = Diagonal([1.0, 1.0, 0])  # Singular mass matrix
f = ODEFunction(rober, mass_matrix = M)
prob_mm = ODEProblem(f, [1.0, 0.0, 0.0], (0.0, 1e5), (0.04, 3e7, 1e4))
sol = solve(prob_mm, Rodas5(), reltol = 1e-8, abstol = 1e-8)</code></pre><h2>Installation</h2><p>To be able to access the solvers in <code>OrdinaryDiffEqRosenbrock</code>, you must first install them use the Julia package manager:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;OrdinaryDiffEqRosenbrock&quot;)</code></pre><p>This will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.</p><h2>Example usage</h2><pre><code class="language-julia hljs">using OrdinaryDiffEqRosenbrock

function lorenz!(du, u, p, t)
    du[1] = 10.0 * (u[2] - u[1])
    du[2] = u[1] * (28.0 - u[3]) - u[2]
    du[3] = u[1] * u[2] - (8 / 3) * u[3]
end
u0 = [1.0; 0.0; 0.0]
tspan = (0.0, 100.0)
prob = ODEProblem(lorenz!, u0, tspan)
sol = solve(prob, Rodas5P())</code></pre><h2 id="Full-list-of-solvers"><a class="docs-heading-anchor" href="#Full-list-of-solvers">Full list of solvers</a><a id="Full-list-of-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Full-list-of-solvers" title="Permalink"></a></h2><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Rosenbrock23-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Rosenbrock23-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Rosenbrock23</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Rosenbrock23(; chunk_size = Val{0}(),
               standardtag = Val{true}(),
               autodiff = AutoForwardDiff(),
               concrete_jac = nothing,
               diff_type = Val{:forward}(),
               linsolve = nothing,
               precs = DEFAULT_PRECS,
               step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  An Order 2/3 L-Stable Rosenbrock-W method which is good for very stiff equations with oscillations at low tolerances. 2nd order stiff-aware interpolation.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Rosenbrock23(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Shampine L.F. and Reichelt M., (1997) The MATLAB ODE Suite, SIAM Journal of Scientific Computing, 18 (1), pp. 1-22.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L22-L95">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Rosenbrock32-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Rosenbrock32-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Rosenbrock32</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Rosenbrock32(; chunk_size = Val{0}(),
               standardtag = Val{true}(),
               autodiff = AutoForwardDiff(),
               concrete_jac = nothing,
               diff_type = Val{:forward}(),
               linsolve = nothing,
               precs = DEFAULT_PRECS,
               step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  An Order 3/2 A-Stable Rosenbrock-W method which is good for mildly stiff equations without oscillations at low tolerances. Note that this method is prone to instability in the presence of oscillations, so use with caution. 2nd order stiff-aware interpolation.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Rosenbrock32(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Shampine L.F. and Reichelt M., (1997) The MATLAB ODE Suite, SIAM Journal of Scientific Computing, 18 (1), pp. 1-22.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L22-L95">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.ROS3P-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.ROS3P-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.ROS3P</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROS3P(; - `standardtag`: Specifies whether to use package-specific tags instead of the
            ForwardDiff default function-specific tags. For more information, see
            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
            Defaults to `Val{true}()`.
        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
            to specify whether to use automatic differentiation via
            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
            `nothing`, which means it will be chosen true/false depending on circumstances
            of the solver, such as whether a Krylov subspace method is used for `linsolve`.
        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
          `ROS3P(linsolve = KLUFactorization()`).
           When `nothing` is passed, uses `DefaultLinearSolver`.
        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
          can be used as a left or right preconditioner.
          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
          function where the arguments are defined as:
            - `W`: the current Jacobian of the nonlinear system. Specified as either
                ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                representation of the operator. Users can construct the W-matrix on demand
                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                the `jac_prototype`.
            - `du`: the current ODE derivative
            - `u`: the current ODE state
            - `p`: the ODE parameters
            - `t`: the current ODE time
            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                the last call to `precs`. It is recommended that this is checked to only
                update the preconditioner when `newW == true`.
            - `Plprev`: the previous `Pl`.
            - `Prprev`: the previous `Pr`.
            - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                Solver-dependent and subject to change.
          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
          To specify one-sided preconditioning, simply return `nothing` for the preconditioner
          which is not used. Additionally, `precs` must supply the dispatch:
          ```julia
          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
          ```
          which is used in the solver setup phase to construct the integrator
          type with the preconditioners `(Pl,Pr)`.
          The default is `precs=DEFAULT_PRECS` where the default preconditioner function
          is defined as:
          ```julia
          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
          ```
        step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method. Keeps high accuracy on discretizations of nonlinear parabolic PDEs.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Lang, J. &amp; Verwer, ROS3P—An Accurate Third-Order Rosenbrock Solver Designed for Parabolic Problems J. BIT Numerical Mathematics (2001) 41: 731. doi:10.1023/A:1021900219772</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L22-L95">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Rodas3-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Rodas3-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Rodas3</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Rodas3(; - `standardtag`: Specifies whether to use package-specific tags instead of the
             ForwardDiff default function-specific tags. For more information, see
             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
             Defaults to `Val{true}()`.
         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
             to specify whether to use automatic differentiation via
             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
             `nothing`, which means it will be chosen true/false depending on circumstances
             of the solver, such as whether a Krylov subspace method is used for `linsolve`.
         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
           `Rodas3(linsolve = KLUFactorization()`).
            When `nothing` is passed, uses `DefaultLinearSolver`.
         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
           can be used as a left or right preconditioner.
           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
           function where the arguments are defined as:
             - `W`: the current Jacobian of the nonlinear system. Specified as either
                 ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                 representation of the operator. Users can construct the W-matrix on demand
                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                 the `jac_prototype`.
             - `du`: the current ODE derivative
             - `u`: the current ODE state
             - `p`: the ODE parameters
             - `t`: the current ODE time
             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                 the last call to `precs`. It is recommended that this is checked to only
                 update the preconditioner when `newW == true`.
             - `Plprev`: the previous `Pl`.
             - `Prprev`: the previous `Pr`.
             - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                 Solver-dependent and subject to change.
           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
           To specify one-sided preconditioning, simply return `nothing` for the preconditioner
           which is not used. Additionally, `precs` must supply the dispatch:
           ```julia
           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
           ```
           which is used in the solver setup phase to construct the integrator
           type with the preconditioners `(Pl,Pr)`.
           The default is `precs=DEFAULT_PRECS` where the default preconditioner function
           is defined as:
           ```julia
           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
           ```
         step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Sandu, Verwer, Van Loon, Carmichael, Potra, Dabdub, Seinfeld, Benchmarking stiff ode solvers for atmospheric chemistry problems-I.  implicit vs explicit, Atmospheric Environment, 31(19), 3151-3166, 1997.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L22-L95">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Rodas23W-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Rodas23W-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Rodas23W</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Rodas23W(; chunk_size = Val{0}(),
           standardtag = Val{true}(),
           autodiff = AutoForwardDiff(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  An Order 2/3 L-Stable Rosenbrock-W method for stiff ODEs and DAEs in mass matrix form. 2nd order stiff-aware interpolation and additional error test for interpolation.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Rodas23W(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Steinebach G., Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024. Proceedings of the JuliaCon Conferences. https://proceedings.juliacon.org/papers/eb04326e1de8fa819a3595b376508a40</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L22-L96">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Rodas3P-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Rodas3P-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Rodas3P</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Rodas3P(; - `standardtag`: Specifies whether to use package-specific tags instead of the
              ForwardDiff default function-specific tags. For more information, see
              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
              Defaults to `Val{true}()`.
          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
              to specify whether to use automatic differentiation via
              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
              `nothing`, which means it will be chosen true/false depending on circumstances
              of the solver, such as whether a Krylov subspace method is used for `linsolve`.
          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
            `Rodas3P(linsolve = KLUFactorization()`).
             When `nothing` is passed, uses `DefaultLinearSolver`.
          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
            can be used as a left or right preconditioner.
            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
            function where the arguments are defined as:
              - `W`: the current Jacobian of the nonlinear system. Specified as either
                  ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                  representation of the operator. Users can construct the W-matrix on demand
                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                  the `jac_prototype`.
              - `du`: the current ODE derivative
              - `u`: the current ODE state
              - `p`: the ODE parameters
              - `t`: the current ODE time
              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                  the last call to `precs`. It is recommended that this is checked to only
                  update the preconditioner when `newW == true`.
              - `Plprev`: the previous `Pl`.
              - `Prprev`: the previous `Pr`.
              - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                  Solver-dependent and subject to change.
            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
            To specify one-sided preconditioning, simply return `nothing` for the preconditioner
            which is not used. Additionally, `precs` must supply the dispatch:
            ```julia
            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
            ```
            which is used in the solver setup phase to construct the integrator
            type with the preconditioners `(Pl,Pr)`.
            The default is `precs=DEFAULT_PRECS` where the default preconditioner function
            is defined as:
            ```julia
            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
            ```
          step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant and additional error test for interpolation. Keeps accuracy on discretizations of linear parabolic PDEs.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Steinebach G., Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024. Proceedings of the JuliaCon Conferences. https://proceedings.juliacon.org/papers/eb04326e1de8fa819a3595b376508a40</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L22-L97">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Rodas4-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Rodas4-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Rodas4</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Rodas4(; - `standardtag`: Specifies whether to use package-specific tags instead of the
             ForwardDiff default function-specific tags. For more information, see
             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
             Defaults to `Val{true}()`.
         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
             to specify whether to use automatic differentiation via
             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
             `nothing`, which means it will be chosen true/false depending on circumstances
             of the solver, such as whether a Krylov subspace method is used for `linsolve`.
         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
           `Rodas4(linsolve = KLUFactorization()`).
            When `nothing` is passed, uses `DefaultLinearSolver`.
         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
           can be used as a left or right preconditioner.
           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
           function where the arguments are defined as:
             - `W`: the current Jacobian of the nonlinear system. Specified as either
                 ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                 representation of the operator. Users can construct the W-matrix on demand
                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                 the `jac_prototype`.
             - `du`: the current ODE derivative
             - `u`: the current ODE state
             - `p`: the ODE parameters
             - `t`: the current ODE time
             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                 the last call to `precs`. It is recommended that this is checked to only
                 update the preconditioner when `newW == true`.
             - `Plprev`: the previous `Pl`.
             - `Prprev`: the previous `Pr`.
             - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                 Solver-dependent and subject to change.
           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
           To specify one-sided preconditioning, simply return `nothing` for the preconditioner
           which is not used. Additionally, `precs` must supply the dispatch:
           ```julia
           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
           ```
           which is used in the solver setup phase to construct the integrator
           type with the preconditioners `(Pl,Pr)`.
           The default is `precs=DEFAULT_PRECS` where the default preconditioner function
           is defined as:
           ```julia
           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
           ```
         step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>E. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L22-L95">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Rodas42-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Rodas42-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Rodas42</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Rodas42(; - `standardtag`: Specifies whether to use package-specific tags instead of the
              ForwardDiff default function-specific tags. For more information, see
              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
              Defaults to `Val{true}()`.
          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
              to specify whether to use automatic differentiation via
              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
              `nothing`, which means it will be chosen true/false depending on circumstances
              of the solver, such as whether a Krylov subspace method is used for `linsolve`.
          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
            `Rodas42(linsolve = KLUFactorization()`).
             When `nothing` is passed, uses `DefaultLinearSolver`.
          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
            can be used as a left or right preconditioner.
            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
            function where the arguments are defined as:
              - `W`: the current Jacobian of the nonlinear system. Specified as either
                  ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                  representation of the operator. Users can construct the W-matrix on demand
                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                  the `jac_prototype`.
              - `du`: the current ODE derivative
              - `u`: the current ODE state
              - `p`: the ODE parameters
              - `t`: the current ODE time
              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                  the last call to `precs`. It is recommended that this is checked to only
                  update the preconditioner when `newW == true`.
              - `Plprev`: the previous `Pl`.
              - `Prprev`: the previous `Pr`.
              - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                  Solver-dependent and subject to change.
            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
            To specify one-sided preconditioning, simply return `nothing` for the preconditioner
            which is not used. Additionally, `precs` must supply the dispatch:
            ```julia
            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
            ```
            which is used in the solver setup phase to construct the integrator
            type with the preconditioners `(Pl,Pr)`.
            The default is `precs=DEFAULT_PRECS` where the default preconditioner function
            is defined as:
            ```julia
            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
            ```
          step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>E. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L22-L95">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Rodas4P-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Rodas4P-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Rodas4P</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Rodas4P(; - `standardtag`: Specifies whether to use package-specific tags instead of the
              ForwardDiff default function-specific tags. For more information, see
              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
              Defaults to `Val{true}()`.
          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
              to specify whether to use automatic differentiation via
              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
              `nothing`, which means it will be chosen true/false depending on circumstances
              of the solver, such as whether a Krylov subspace method is used for `linsolve`.
          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
            `Rodas4P(linsolve = KLUFactorization()`).
             When `nothing` is passed, uses `DefaultLinearSolver`.
          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
            can be used as a left or right preconditioner.
            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
            function where the arguments are defined as:
              - `W`: the current Jacobian of the nonlinear system. Specified as either
                  ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                  representation of the operator. Users can construct the W-matrix on demand
                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                  the `jac_prototype`.
              - `du`: the current ODE derivative
              - `u`: the current ODE state
              - `p`: the ODE parameters
              - `t`: the current ODE time
              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                  the last call to `precs`. It is recommended that this is checked to only
                  update the preconditioner when `newW == true`.
              - `Plprev`: the previous `Pl`.
              - `Prprev`: the previous `Pr`.
              - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                  Solver-dependent and subject to change.
            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
            To specify one-sided preconditioning, simply return `nothing` for the preconditioner
            which is not used. Additionally, `precs` must supply the dispatch:
            ```julia
            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
            ```
            which is used in the solver setup phase to construct the integrator
            type with the preconditioners `(Pl,Pr)`.
            The default is `precs=DEFAULT_PRECS` where the default preconditioner function
            is defined as:
            ```julia
            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
            ```
          step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems (as opposed to lower if not corrected).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Steinebach, G., Rentrop, P., An adaptive method of lines approach for modelling flow and transport in rivers.  Adaptive method of lines , Wouver, A. Vande, Sauces, Ph., Schiesser, W.E. (ed.),S. 181-205,Chapman &amp; Hall/CRC, 2001,</li><li>Steinebach, G., Order-reduction of ROW-methods for DAEs and method of lines  applications.  Preprint-Nr. 1741, FB Mathematik, TH Darmstadt, 1995.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L22-L99">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Rodas4P2-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Rodas4P2-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Rodas4P2</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Rodas4P2(; chunk_size = Val{0}(),
           standardtag = Val{true}(),
           autodiff = AutoForwardDiff(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems. It is an improvement of Rodas4P and in case of inexact Jacobians a second order W method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Rodas4P2(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Steinebach G., Improvement of Rosenbrock-Wanner Method RODASP, In: Reis T., Grundel S., Schöps S. (eds)  Progress in Differential-Algebraic Equations II. Differential-Algebraic Equations Forum. Springer, Cham., 165-184, 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L22-L97">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Rodas5-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Rodas5-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Rodas5</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Rodas5(; - `standardtag`: Specifies whether to use package-specific tags instead of the
             ForwardDiff default function-specific tags. For more information, see
             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
             Defaults to `Val{true}()`.
         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
             to specify whether to use automatic differentiation via
             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
             `nothing`, which means it will be chosen true/false depending on circumstances
             of the solver, such as whether a Krylov subspace method is used for `linsolve`.
         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
           `Rodas5(linsolve = KLUFactorization()`).
            When `nothing` is passed, uses `DefaultLinearSolver`.
         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
           can be used as a left or right preconditioner.
           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
           function where the arguments are defined as:
             - `W`: the current Jacobian of the nonlinear system. Specified as either
                 ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                 representation of the operator. Users can construct the W-matrix on demand
                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                 the `jac_prototype`.
             - `du`: the current ODE derivative
             - `u`: the current ODE state
             - `p`: the ODE parameters
             - `t`: the current ODE time
             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                 the last call to `precs`. It is recommended that this is checked to only
                 update the preconditioner when `newW == true`.
             - `Plprev`: the previous `Pl`.
             - `Prprev`: the previous `Pr`.
             - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                 Solver-dependent and subject to change.
           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
           To specify one-sided preconditioning, simply return `nothing` for the preconditioner
           which is not used. Additionally, `precs` must supply the dispatch:
           ```julia
           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
           ```
           which is used in the solver setup phase to construct the integrator
           type with the preconditioners `(Pl,Pr)`.
           The default is `precs=DEFAULT_PRECS` where the default preconditioner function
           is defined as:
           ```julia
           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
           ```
         step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  A 5th order A-stable stiffly stable Rosenbrock method with a stiff-aware 4th order interpolant.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Di Marzo G. RODAS5(4) – Méthodes de Rosenbrock d&#39;ordre 5(4) adaptées aux problèmes différentiels-algébriques. MSc mathematics thesis, Faculty of Science, University of Geneva, Switzerland.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L22-L96">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Rodas5P-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Rodas5P-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Rodas5P</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Rodas5P(; chunk_size = Val{0}(),
          standardtag = Val{true}(),
          autodiff = AutoForwardDiff(),
          concrete_jac = nothing,
          diff_type = Val{:forward}(),
          linsolve = nothing,
          precs = DEFAULT_PRECS,
          step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 5th order A-stable stiffly stable Rosenbrock method with a stiff-aware 4th order interpolant. Has improved stability in the adaptive time stepping embedding.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Rodas5P(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Steinebach G. Construction of Rosenbrock–Wanner method Rodas5P and numerical benchmarks within the Julia Differential Equations package. In: BIT Numerical Mathematics, 63(2), 2023. doi:10.1007/s10543-023-00967-x</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L22-L97">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Rodas5Pe-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Rodas5Pe-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Rodas5Pe</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Rodas5Pe(; chunk_size = Val{0}(),
           standardtag = Val{true}(),
           autodiff = AutoForwardDiff(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  Variant of Rodas5P with modified embedded scheme.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Rodas5Pe(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Steinebach G. Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024. Proceedings of the JuliaCon Conferences. https://proceedings.juliacon.org/papers/eb04326e1de8fa819a3595b376508a40</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L22-L96">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Rodas5Pr-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Rodas5Pr-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Rodas5Pr</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Rodas5Pr(; chunk_size = Val{0}(),
           standardtag = Val{true}(),
           autodiff = AutoForwardDiff(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  Variant of Rodas5P with additional residual control.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Rodas5Pr(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Steinebach G. Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024. Proceedings of the JuliaCon Conferences. https://proceedings.juliacon.org/papers/eb04326e1de8fa819a3595b376508a40</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L22-L96">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.RosenbrockW6S4OS-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.RosenbrockW6S4OS-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.RosenbrockW6S4OS</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RosenbrockW6S4OS(; chunk_size = Val{0}(),
                   standardtag = Val{true}(),
                   autodiff = AutoForwardDiff(),
                   concrete_jac = nothing,
                   diff_type = Val{:forward}(),
                   linsolve = nothing,
                   precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method (fixed step only).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>RosenbrockW6S4OS(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><p>https://doi.org/10.1016/j.cam.2009.09.017</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L53-L125">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.ROS2-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.ROS2-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.ROS2</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROS2(; - `standardtag`: Specifies whether to use package-specific tags instead of the
           ForwardDiff default function-specific tags. For more information, see
           [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
           Defaults to `Val{true}()`.
       - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
           to specify whether to use automatic differentiation via
           [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
           differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
           Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
           `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
           To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
           `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
       - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
           `nothing`, which means it will be chosen true/false depending on circumstances
           of the solver, such as whether a Krylov subspace method is used for `linsolve`.
       - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
         For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
         `ROS2(linsolve = KLUFactorization()`).
          When `nothing` is passed, uses `DefaultLinearSolver`.
       - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
         can be used as a left or right preconditioner.
         Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
         function where the arguments are defined as:
           - `W`: the current Jacobian of the nonlinear system. Specified as either
               ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
               commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
               representation of the operator. Users can construct the W-matrix on demand
               by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
               the `jac_prototype`.
           - `du`: the current ODE derivative
           - `u`: the current ODE state
           - `p`: the ODE parameters
           - `t`: the current ODE time
           - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
               the last call to `precs`. It is recommended that this is checked to only
               update the preconditioner when `newW == true`.
           - `Plprev`: the previous `Pl`.
           - `Prprev`: the previous `Pr`.
           - `solverdata`: Optional extra data the solvers can give to the `precs` function.
               Solver-dependent and subject to change.
         The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
         To specify one-sided preconditioning, simply return `nothing` for the preconditioner
         which is not used. Additionally, `precs` must supply the dispatch:
         ```julia
         Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
         ```
         which is used in the solver setup phase to construct the integrator
         type with the preconditioners `(Pl,Pr)`.
         The default is `precs=DEFAULT_PRECS` where the default preconditioner function
         is defined as:
         ```julia
         DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
         ```)</code></pre><p>Rosenbrock-Wanner Method.  A 2nd order L-stable Rosenbrock method with 2 internal stages.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>J. G. Verwer et al. (1999): A second-order Rosenbrock method applied to photochemical dispersion problems https://doi.org/10.1137/S1064827597326651</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L187">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.ROS2PR-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.ROS2PR-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.ROS2PR</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROS2PR(; - `standardtag`: Specifies whether to use package-specific tags instead of the
             ForwardDiff default function-specific tags. For more information, see
             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
             Defaults to `Val{true}()`.
         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
             to specify whether to use automatic differentiation via
             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
             `nothing`, which means it will be chosen true/false depending on circumstances
             of the solver, such as whether a Krylov subspace method is used for `linsolve`.
         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
           `ROS2PR(linsolve = KLUFactorization()`).
            When `nothing` is passed, uses `DefaultLinearSolver`.
         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
           can be used as a left or right preconditioner.
           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
           function where the arguments are defined as:
             - `W`: the current Jacobian of the nonlinear system. Specified as either
                 ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                 representation of the operator. Users can construct the W-matrix on demand
                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                 the `jac_prototype`.
             - `du`: the current ODE derivative
             - `u`: the current ODE state
             - `p`: the ODE parameters
             - `t`: the current ODE time
             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                 the last call to `precs`. It is recommended that this is checked to only
                 update the preconditioner when `newW == true`.
             - `Plprev`: the previous `Pl`.
             - `Prprev`: the previous `Pr`.
             - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                 Solver-dependent and subject to change.
           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
           To specify one-sided preconditioning, simply return `nothing` for the preconditioner
           which is not used. Additionally, `precs` must supply the dispatch:
           ```julia
           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
           ```
           which is used in the solver setup phase to construct the integrator
           type with the preconditioners `(Pl,Pr)`.
           The default is `precs=DEFAULT_PRECS` where the default preconditioner function
           is defined as:
           ```julia
           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
           ```)</code></pre><p>Rosenbrock-Wanner Method.  2nd order stiffly accurate Rosenbrock method with 3 internal stages with (Rinf=0). For problems with medium stiffness the convergence behaviour is very poor and it is recommended to use <a href="../../semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS2S"><code>ROS2S</code></a> instead.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L190">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.ROS2S-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.ROS2S-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.ROS2S</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROS2S(; chunk_size = Val{0}(),
        standardtag = Val{true}(),
        autodiff = AutoForwardDiff(),
        concrete_jac = nothing,
        diff_type = Val{:forward}(),
        linsolve = nothing,
        precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  2nd order stiffly accurate Rosenbrock-Wanner W-method with 3 internal stages with B_PR consistent of order 2 with (Rinf=0).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ROS2S(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L188">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.ROS3-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.ROS3-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.ROS3</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROS3(; - `standardtag`: Specifies whether to use package-specific tags instead of the
           ForwardDiff default function-specific tags. For more information, see
           [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
           Defaults to `Val{true}()`.
       - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
           to specify whether to use automatic differentiation via
           [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
           differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
           Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
           `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
           To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
           `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
       - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
           `nothing`, which means it will be chosen true/false depending on circumstances
           of the solver, such as whether a Krylov subspace method is used for `linsolve`.
       - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
         For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
         `ROS3(linsolve = KLUFactorization()`).
          When `nothing` is passed, uses `DefaultLinearSolver`.
       - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
         can be used as a left or right preconditioner.
         Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
         function where the arguments are defined as:
           - `W`: the current Jacobian of the nonlinear system. Specified as either
               ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
               commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
               representation of the operator. Users can construct the W-matrix on demand
               by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
               the `jac_prototype`.
           - `du`: the current ODE derivative
           - `u`: the current ODE state
           - `p`: the ODE parameters
           - `t`: the current ODE time
           - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
               the last call to `precs`. It is recommended that this is checked to only
               update the preconditioner when `newW == true`.
           - `Plprev`: the previous `Pl`.
           - `Prprev`: the previous `Pr`.
           - `solverdata`: Optional extra data the solvers can give to the `precs` function.
               Solver-dependent and subject to change.
         The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
         To specify one-sided preconditioning, simply return `nothing` for the preconditioner
         which is not used. Additionally, `precs` must supply the dispatch:
         ```julia
         Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
         ```
         which is used in the solver setup phase to construct the integrator
         type with the preconditioners `(Pl,Pr)`.
         The default is `precs=DEFAULT_PRECS` where the default preconditioner function
         is defined as:
         ```julia
         DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
         ```)</code></pre><p>Rosenbrock-Wanner Method.  3rd order L-stable Rosenbrock method with 3 internal stages with an embedded strongly A-stable 2nd order method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>E. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L188">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.ROS3PR-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.ROS3PR-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.ROS3PR</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROS3PR(; - `standardtag`: Specifies whether to use package-specific tags instead of the
             ForwardDiff default function-specific tags. For more information, see
             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
             Defaults to `Val{true}()`.
         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
             to specify whether to use automatic differentiation via
             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
             `nothing`, which means it will be chosen true/false depending on circumstances
             of the solver, such as whether a Krylov subspace method is used for `linsolve`.
         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
           `ROS3PR(linsolve = KLUFactorization()`).
            When `nothing` is passed, uses `DefaultLinearSolver`.
         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
           can be used as a left or right preconditioner.
           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
           function where the arguments are defined as:
             - `W`: the current Jacobian of the nonlinear system. Specified as either
                 ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                 representation of the operator. Users can construct the W-matrix on demand
                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                 the `jac_prototype`.
             - `du`: the current ODE derivative
             - `u`: the current ODE state
             - `p`: the ODE parameters
             - `t`: the current ODE time
             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                 the last call to `precs`. It is recommended that this is checked to only
                 update the preconditioner when `newW == true`.
             - `Plprev`: the previous `Pl`.
             - `Prprev`: the previous `Pr`.
             - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                 Solver-dependent and subject to change.
           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
           To specify one-sided preconditioning, simply return `nothing` for the preconditioner
           which is not used. Additionally, `precs` must supply the dispatch:
           ```julia
           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
           ```
           which is used in the solver setup phase to construct the integrator
           type with the preconditioners `(Pl,Pr)`.
           The default is `precs=DEFAULT_PRECS` where the default preconditioner function
           is defined as:
           ```julia
           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
           ```)</code></pre><p>Rosenbrock-Wanner Method.  3nd order stiffly accurate Rosenbrock method with 3 internal stages with B_PR consistent of order 3, which is strongly A-stable with Rinf~=-0.73.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L188">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Scholz4_7-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Scholz4_7-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Scholz4_7</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Scholz4_7(; - `standardtag`: Specifies whether to use package-specific tags instead of the
                ForwardDiff default function-specific tags. For more information, see
                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
                Defaults to `Val{true}()`.
            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
                to specify whether to use automatic differentiation via
                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
                `nothing`, which means it will be chosen true/false depending on circumstances
                of the solver, such as whether a Krylov subspace method is used for `linsolve`.
            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
              `Scholz4_7(linsolve = KLUFactorization()`).
               When `nothing` is passed, uses `DefaultLinearSolver`.
            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
              can be used as a left or right preconditioner.
              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
              function where the arguments are defined as:
                - `W`: the current Jacobian of the nonlinear system. Specified as either
                    ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                    representation of the operator. Users can construct the W-matrix on demand
                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                    the `jac_prototype`.
                - `du`: the current ODE derivative
                - `u`: the current ODE state
                - `p`: the ODE parameters
                - `t`: the current ODE time
                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                    the last call to `precs`. It is recommended that this is checked to only
                    update the preconditioner when `newW == true`.
                - `Plprev`: the previous `Pl`.
                - `Prprev`: the previous `Pr`.
                - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                    Solver-dependent and subject to change.
              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
              To specify one-sided preconditioning, simply return `nothing` for the preconditioner
              which is not used. Additionally, `precs` must supply the dispatch:
              ```julia
              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
              ```
              which is used in the solver setup phase to construct the integrator
              type with the preconditioners `(Pl,Pr)`.
              The default is `precs=DEFAULT_PRECS` where the default preconditioner function
              is defined as:
              ```julia
              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
              ```)</code></pre><p>Rosenbrock-Wanner Method.  3nd order stiffly accurate Rosenbrock method with 3 internal stages with B_PR consistent of order 3, which is strongly A-stable with Rinf~=-0.73. Convergence with order 4 for the stiff case, but has a poor accuracy.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L189">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.ROS34PW1a-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.ROS34PW1a-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.ROS34PW1a</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROS34PW1a(; chunk_size = Val{0}(),
            standardtag = Val{true}(),
            autodiff = AutoForwardDiff(),
            concrete_jac = nothing,
            diff_type = Val{:forward}(),
            linsolve = nothing,
            precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ROS34PW1a(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim and Angermann, L (2005): New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1. BIT Numerical Mathematics, 45, 761–787.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L187">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.ROS34PW1b-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.ROS34PW1b-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.ROS34PW1b</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROS34PW1b(; chunk_size = Val{0}(),
            standardtag = Val{true}(),
            autodiff = AutoForwardDiff(),
            concrete_jac = nothing,
            diff_type = Val{:forward}(),
            linsolve = nothing,
            precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ROS34PW1b(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim and Angermann, L (2005): New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1. BIT Numerical Mathematics, 45, 761–787.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L187">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.ROS34PW2-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.ROS34PW2-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.ROS34PW2</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROS34PW2(; chunk_size = Val{0}(),
           standardtag = Val{true}(),
           autodiff = AutoForwardDiff(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 4th order stiffy accurate Rosenbrock-W method for PDAEs.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ROS34PW2(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim and Angermann, L (2005): New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1. BIT Numerical Mathematics, 45, 761–787.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L187">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.ROS34PW3-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.ROS34PW3-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.ROS34PW3</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROS34PW3(; chunk_size = Val{0}(),
           standardtag = Val{true}(),
           autodiff = AutoForwardDiff(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 4th order strongly A-stable (Rinf~0.63) Rosenbrock-W method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ROS34PW3(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim and Angermann, L (2005): New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1. BIT Numerical Mathematics, 45, 761–787.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L187">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.ROS34PRw-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.ROS34PRw-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.ROS34PRw</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROS34PRw(; chunk_size = Val{0}(),
           standardtag = Val{true}(),
           autodiff = AutoForwardDiff(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  3rd order stiffly accurate Rosenbrock-Wanner W-method with 4 internal stages, B_PR consistent of order 2. The order of convergence decreases if medium stiff problems are considered.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ROS34PRw(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><ul><li>Joachim Rang, Improved traditional Rosenbrock–Wanner methods for stiff ODEs and DAEs, Journal of Computational and Applied Mathematics, https://doi.org/10.1016/j.cam.2015.03.010</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L190">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.ROS3PRL-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.ROS3PRL-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.ROS3PRL</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROS3PRL(; - `standardtag`: Specifies whether to use package-specific tags instead of the
              ForwardDiff default function-specific tags. For more information, see
              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
              Defaults to `Val{true}()`.
          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
              to specify whether to use automatic differentiation via
              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
              `nothing`, which means it will be chosen true/false depending on circumstances
              of the solver, such as whether a Krylov subspace method is used for `linsolve`.
          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
            `ROS3PRL(linsolve = KLUFactorization()`).
             When `nothing` is passed, uses `DefaultLinearSolver`.
          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
            can be used as a left or right preconditioner.
            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
            function where the arguments are defined as:
              - `W`: the current Jacobian of the nonlinear system. Specified as either
                  ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                  representation of the operator. Users can construct the W-matrix on demand
                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                  the `jac_prototype`.
              - `du`: the current ODE derivative
              - `u`: the current ODE state
              - `p`: the ODE parameters
              - `t`: the current ODE time
              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                  the last call to `precs`. It is recommended that this is checked to only
                  update the preconditioner when `newW == true`.
              - `Plprev`: the previous `Pl`.
              - `Prprev`: the previous `Pr`.
              - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                  Solver-dependent and subject to change.
            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
            To specify one-sided preconditioning, simply return `nothing` for the preconditioner
            which is not used. Additionally, `precs` must supply the dispatch:
            ```julia
            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
            ```
            which is used in the solver setup phase to construct the integrator
            type with the preconditioners `(Pl,Pr)`.
            The default is `precs=DEFAULT_PRECS` where the default preconditioner function
            is defined as:
            ```julia
            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
            ```)</code></pre><p>Rosenbrock-Wanner Method.  3rd order stiffly accurate Rosenbrock method with 4 internal stages, B_PR consistent of order 2 with Rinf=0. The order of convergence decreases if medium stiff problems are considered, but it has good results for very stiff cases.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L190">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.ROS3PRL2-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.ROS3PRL2-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.ROS3PRL2</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROS3PRL2(; - `standardtag`: Specifies whether to use package-specific tags instead of the
               ForwardDiff default function-specific tags. For more information, see
               [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
               Defaults to `Val{true}()`.
           - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
               to specify whether to use automatic differentiation via
               [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
               differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
               Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
               `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
               To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
               `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
           - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
               `nothing`, which means it will be chosen true/false depending on circumstances
               of the solver, such as whether a Krylov subspace method is used for `linsolve`.
           - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
             For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
             `ROS3PRL2(linsolve = KLUFactorization()`).
              When `nothing` is passed, uses `DefaultLinearSolver`.
           - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
             can be used as a left or right preconditioner.
             Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
             function where the arguments are defined as:
               - `W`: the current Jacobian of the nonlinear system. Specified as either
                   ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                   commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                   representation of the operator. Users can construct the W-matrix on demand
                   by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                   the `jac_prototype`.
               - `du`: the current ODE derivative
               - `u`: the current ODE state
               - `p`: the ODE parameters
               - `t`: the current ODE time
               - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                   the last call to `precs`. It is recommended that this is checked to only
                   update the preconditioner when `newW == true`.
               - `Plprev`: the previous `Pl`.
               - `Prprev`: the previous `Pr`.
               - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                   Solver-dependent and subject to change.
             The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
             To specify one-sided preconditioning, simply return `nothing` for the preconditioner
             which is not used. Additionally, `precs` must supply the dispatch:
             ```julia
             Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
             ```
             which is used in the solver setup phase to construct the integrator
             type with the preconditioners `(Pl,Pr)`.
             The default is `precs=DEFAULT_PRECS` where the default preconditioner function
             is defined as:
             ```julia
             DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
             ```)</code></pre><p>Rosenbrock-Wanner Method.  3rd order stiffly accurate Rosenbrock method with 4 internal stages, B_PR consistent of order 3. The order of convergence does NOT decreases if medium stiff problems are considered as it does for <a href="../../semiimplicit/Rosenbrock/#OrdinaryDiffEqRosenbrock.ROS3PRL"><code>ROS3PRL</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L190">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.ROK4a-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.ROK4a-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.ROK4a</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">ROK4a(; chunk_size = Val{0}(),
        standardtag = Val{true}(),
        autodiff = AutoForwardDiff(),
        concrete_jac = nothing,
        diff_type = Val{:forward}(),
        linsolve = nothing,
        precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  4rd order L-stable Rosenbrock-Krylov method with 4 internal stages, with a 3rd order embedded method which is strongly A-stable with Rinf~=0.55. (when using exact Jacobians)</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ROK4a(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><ul><li>Tranquilli, Paul and Sandu, Adrian (2014): Rosenbrock–Krylov Methods for Large Systems of Differential Equations https://doi.org/10.1137/130923336</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L189">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.RosShamp4-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.RosShamp4-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.RosShamp4</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">RosShamp4(; - `standardtag`: Specifies whether to use package-specific tags instead of the
                ForwardDiff default function-specific tags. For more information, see
                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
                Defaults to `Val{true}()`.
            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
                to specify whether to use automatic differentiation via
                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
                `nothing`, which means it will be chosen true/false depending on circumstances
                of the solver, such as whether a Krylov subspace method is used for `linsolve`.
            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
              `RosShamp4(linsolve = KLUFactorization()`).
               When `nothing` is passed, uses `DefaultLinearSolver`.
            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
              can be used as a left or right preconditioner.
              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
              function where the arguments are defined as:
                - `W`: the current Jacobian of the nonlinear system. Specified as either
                    ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                    representation of the operator. Users can construct the W-matrix on demand
                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                    the `jac_prototype`.
                - `du`: the current ODE derivative
                - `u`: the current ODE state
                - `p`: the ODE parameters
                - `t`: the current ODE time
                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                    the last call to `precs`. It is recommended that this is checked to only
                    update the preconditioner when `newW == true`.
                - `Plprev`: the previous `Pl`.
                - `Prprev`: the previous `Pr`.
                - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                    Solver-dependent and subject to change.
              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
              To specify one-sided preconditioning, simply return `nothing` for the preconditioner
              which is not used. Additionally, `precs` must supply the dispatch:
              ```julia
              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
              ```
              which is used in the solver setup phase to construct the integrator
              type with the preconditioners `(Pl,Pr)`.
              The default is `precs=DEFAULT_PRECS` where the default preconditioner function
              is defined as:
              ```julia
              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
              ```)</code></pre><p>Rosenbrock-Wanner Method.  An A-stable 4th order Rosenbrock method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>L. F. Shampine, Implementation of Rosenbrock Methods, ACM Transactions on Mathematical Software (TOMS), 8: 2, 93-113. doi:10.1145/355993.355994</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L187">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Veldd4-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Veldd4-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Veldd4</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Veldd4(; - `standardtag`: Specifies whether to use package-specific tags instead of the
             ForwardDiff default function-specific tags. For more information, see
             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
             Defaults to `Val{true}()`.
         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
             to specify whether to use automatic differentiation via
             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
             `nothing`, which means it will be chosen true/false depending on circumstances
             of the solver, such as whether a Krylov subspace method is used for `linsolve`.
         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
           `Veldd4(linsolve = KLUFactorization()`).
            When `nothing` is passed, uses `DefaultLinearSolver`.
         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
           can be used as a left or right preconditioner.
           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
           function where the arguments are defined as:
             - `W`: the current Jacobian of the nonlinear system. Specified as either
                 ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                 representation of the operator. Users can construct the W-matrix on demand
                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                 the `jac_prototype`.
             - `du`: the current ODE derivative
             - `u`: the current ODE state
             - `p`: the ODE parameters
             - `t`: the current ODE time
             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                 the last call to `precs`. It is recommended that this is checked to only
                 update the preconditioner when `newW == true`.
             - `Plprev`: the previous `Pl`.
             - `Prprev`: the previous `Pr`.
             - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                 Solver-dependent and subject to change.
           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
           To specify one-sided preconditioning, simply return `nothing` for the preconditioner
           which is not used. Additionally, `precs` must supply the dispatch:
           ```julia
           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
           ```
           which is used in the solver setup phase to construct the integrator
           type with the preconditioners `(Pl,Pr)`.
           The default is `precs=DEFAULT_PRECS` where the default preconditioner function
           is defined as:
           ```julia
           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
           ```)</code></pre><p>Rosenbrock-Wanner Method.  A 4th order D-stable Rosenbrock method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>van Veldhuizen, D-stability and Kaps-Rentrop-methods, M. Computing (1984) 32: 229. doi:10.1007/BF02243574</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L187">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Velds4-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Velds4-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Velds4</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Velds4(; chunk_size = Val{0}(),
         standardtag = Val{true}(),
         autodiff = AutoForwardDiff(),
         concrete_jac = nothing,
         diff_type = Val{:forward}(),
         linsolve = nothing,
         precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 4th order A-stable Rosenbrock method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Velds4(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><ul><li>van Veldhuizen, D-stability and Kaps-Rentrop-methods, M. Computing (1984) 32: 229. doi:10.1007/BF02243574</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L187">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.GRK4T-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.GRK4T-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.GRK4T</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GRK4T(; - `standardtag`: Specifies whether to use package-specific tags instead of the
            ForwardDiff default function-specific tags. For more information, see
            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
            Defaults to `Val{true}()`.
        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
            to specify whether to use automatic differentiation via
            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
            `nothing`, which means it will be chosen true/false depending on circumstances
            of the solver, such as whether a Krylov subspace method is used for `linsolve`.
        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
          `GRK4T(linsolve = KLUFactorization()`).
           When `nothing` is passed, uses `DefaultLinearSolver`.
        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
          can be used as a left or right preconditioner.
          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
          function where the arguments are defined as:
            - `W`: the current Jacobian of the nonlinear system. Specified as either
                ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                representation of the operator. Users can construct the W-matrix on demand
                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                the `jac_prototype`.
            - `du`: the current ODE derivative
            - `u`: the current ODE state
            - `p`: the ODE parameters
            - `t`: the current ODE time
            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                the last call to `precs`. It is recommended that this is checked to only
                update the preconditioner when `newW == true`.
            - `Plprev`: the previous `Pl`.
            - `Prprev`: the previous `Pr`.
            - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                Solver-dependent and subject to change.
          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
          To specify one-sided preconditioning, simply return `nothing` for the preconditioner
          which is not used. Additionally, `precs` must supply the dispatch:
          ```julia
          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
          ```
          which is used in the solver setup phase to construct the integrator
          type with the preconditioners `(Pl,Pr)`.
          The default is `precs=DEFAULT_PRECS` where the default preconditioner function
          is defined as:
          ```julia
          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
          ```)</code></pre><p>Rosenbrock-Wanner Method.  An efficient 4th order Rosenbrock method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>Kaps, P. &amp; Rentrop, Generalized Runge-Kutta methods of order four with stepsize control for stiff ordinary differential equations. P. Numer. Math. (1979) 33: 55. doi:10.1007/BF01396495</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L187">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.GRK4A-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.GRK4A-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.GRK4A</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">GRK4A(; - `standardtag`: Specifies whether to use package-specific tags instead of the
            ForwardDiff default function-specific tags. For more information, see
            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
            Defaults to `Val{true}()`.
        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
            to specify whether to use automatic differentiation via
            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
            `nothing`, which means it will be chosen true/false depending on circumstances
            of the solver, such as whether a Krylov subspace method is used for `linsolve`.
        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
          `GRK4A(linsolve = KLUFactorization()`).
           When `nothing` is passed, uses `DefaultLinearSolver`.
        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
          can be used as a left or right preconditioner.
          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
          function where the arguments are defined as:
            - `W`: the current Jacobian of the nonlinear system. Specified as either
                ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                representation of the operator. Users can construct the W-matrix on demand
                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                the `jac_prototype`.
            - `du`: the current ODE derivative
            - `u`: the current ODE state
            - `p`: the ODE parameters
            - `t`: the current ODE time
            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                the last call to `precs`. It is recommended that this is checked to only
                update the preconditioner when `newW == true`.
            - `Plprev`: the previous `Pl`.
            - `Prprev`: the previous `Pr`.
            - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                Solver-dependent and subject to change.
          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
          To specify one-sided preconditioning, simply return `nothing` for the preconditioner
          which is not used. Additionally, `precs` must supply the dispatch:
          ```julia
          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
          ```
          which is used in the solver setup phase to construct the integrator
          type with the preconditioners `(Pl,Pr)`.
          The default is `precs=DEFAULT_PRECS` where the default preconditioner function
          is defined as:
          ```julia
          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
          ```)</code></pre><p>Rosenbrock-Wanner Method.  An A-stable 4th order Rosenbrock method. Essentially &quot;anti-L-stable&quot; but efficient.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>Kaps, P. &amp; Rentrop, Generalized Runge-Kutta methods of order four with stepsize control for stiff ordinary differential equations. P. Numer. Math. (1979) 33: 55. doi:10.1007/BF01396495</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L187">source</a></section></details></article><article><details class="docstring"><summary id="OrdinaryDiffEqRosenbrock.Ros4LStab-massmatrixdae-Rosenbrock"><a class="docstring-binding" href="#OrdinaryDiffEqRosenbrock.Ros4LStab-massmatrixdae-Rosenbrock"><code>OrdinaryDiffEqRosenbrock.Ros4LStab</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">Ros4LStab(; - `standardtag`: Specifies whether to use package-specific tags instead of the
                ForwardDiff default function-specific tags. For more information, see
                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
                Defaults to `Val{true}()`.
            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
                to specify whether to use automatic differentiation via
                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
                `nothing`, which means it will be chosen true/false depending on circumstances
                of the solver, such as whether a Krylov subspace method is used for `linsolve`.
            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
              `Ros4LStab(linsolve = KLUFactorization()`).
               When `nothing` is passed, uses `DefaultLinearSolver`.
            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
              can be used as a left or right preconditioner.
              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
              function where the arguments are defined as:
                - `W`: the current Jacobian of the nonlinear system. Specified as either
                    ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                    representation of the operator. Users can construct the W-matrix on demand
                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                    the `jac_prototype`.
                - `du`: the current ODE derivative
                - `u`: the current ODE state
                - `p`: the ODE parameters
                - `t`: the current ODE time
                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                    the last call to `precs`. It is recommended that this is checked to only
                    update the preconditioner when `newW == true`.
                - `Plprev`: the previous `Pl`.
                - `Prprev`: the previous `Pr`.
                - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                    Solver-dependent and subject to change.
              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
              To specify one-sided preconditioning, simply return `nothing` for the preconditioner
              which is not used. Additionally, `precs` must supply the dispatch:
              ```julia
              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
              ```
              which is used in the solver setup phase to construct the integrator
              type with the preconditioners `(Pl,Pr)`.
              The default is `precs=DEFAULT_PRECS` where the default preconditioner function
              is defined as:
              ```julia
              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
              ```)</code></pre><p>Rosenbrock-Wanner Method.  A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>E. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/6cc685b11fb5aafbb6ec9f576aa7ba824e0e6b93/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L116-L187">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../semilinear/Linear/">« OrdinaryDiffEqLinear</a><a class="docs-footer-nextpage" href="../BDF/">OrdinaryDiffEqBDF »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Monday 2 February 2026 07:33">Monday 2 February 2026</span>. Using Julia version 1.12.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
