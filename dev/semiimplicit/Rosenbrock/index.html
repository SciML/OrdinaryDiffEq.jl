<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>OrdinaryDiffEqRosenbrock · OrdinaryDiffEq.jl</title><meta name="title" content="OrdinaryDiffEqRosenbrock · OrdinaryDiffEq.jl"/><meta property="og:title" content="OrdinaryDiffEqRosenbrock · OrdinaryDiffEq.jl"/><meta property="twitter:title" content="OrdinaryDiffEqRosenbrock · OrdinaryDiffEq.jl"/><meta name="description" content="Documentation for OrdinaryDiffEq.jl."/><meta property="og:description" content="Documentation for OrdinaryDiffEq.jl."/><meta property="twitter:description" content="Documentation for OrdinaryDiffEq.jl."/><meta property="og:url" content="https://ordinarydiffeq.sciml.ai/stable/semiimplicit/Rosenbrock/"/><meta property="twitter:url" content="https://ordinarydiffeq.sciml.ai/stable/semiimplicit/Rosenbrock/"/><link rel="canonical" href="https://ordinarydiffeq.sciml.ai/stable/semiimplicit/Rosenbrock/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="OrdinaryDiffEq.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">OrdinaryDiffEq.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">OrdinaryDiffEq.jl: ODE solvers and utilities</a></li><li><a class="tocitem" href="../../usage/">Usage</a></li><li><span class="tocitem">Explicit Solvers</span><ul><li><a class="tocitem" href="../../explicit/Tsit5/">OrdinaryDiffEqTsit5</a></li><li><a class="tocitem" href="../../explicit/Verner/">OrdinaryDiffEqVerner</a></li><li><a class="tocitem" href="../../explicit/AdamsBashforthMoulton/">OrdinaryDiffEqAdamsBashforthMoulton</a></li><li><a class="tocitem" href="../../explicit/LowStorageRK/">OrdinaryDiffEqLowStorageRK</a></li><li><a class="tocitem" href="../../explicit/SSPRK/">OrdinaryDiffEqSSPRK</a></li><li><a class="tocitem" href="../../explicit/LowOrderRK/">OrdinaryDiffEqLowOrderRK</a></li><li><a class="tocitem" href="../../explicit/HighOrderRK/">OrdinaryDiffEqHighOrderRK</a></li><li><a class="tocitem" href="../../explicit/Feagin/">OrdinaryDiffEqFeagin</a></li><li><a class="tocitem" href="../../explicit/PRK/">OrdinaryDiffEqPRK</a></li><li><a class="tocitem" href="../../explicit/QPRK/">OrdinaryDiffEqQPRK</a></li><li><a class="tocitem" href="../../explicit/Extrapolation/">OrdinaryDiffEqExtrapolation</a></li></ul></li><li><span class="tocitem">Semi-Implicit Solvers</span><ul><li class="is-active"><a class="tocitem" href>OrdinaryDiffEqRosenbrock</a><ul class="internal"><li><a class="tocitem" href="#Full-list-of-solvers"><span>Full list of solvers</span></a></li></ul></li><li><a class="tocitem" href="../StabilizedRK/">OrdinaryDiffEqStabilizedRK</a></li><li><a class="tocitem" href="../ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li></ul></li><li><span class="tocitem">Implicit Solvers</span><ul><li><a class="tocitem" href="../../implicit/SDIRK/">OrdinaryDiffEqSDIRK</a></li><li><a class="tocitem" href="../../implicit/FIRK/">OrdinaryDiffEqFIRK</a></li><li><a class="tocitem" href="../../implicit/BDF/">OrdinaryDiffEqBDF</a></li><li><a class="tocitem" href="../../implicit/Extrapolation/">OrdinaryDiffEqExtrapolation</a></li><li><a class="tocitem" href="../../implicit/PDIRK/">OrdinaryDiffEqPDIRK</a></li><li><a class="tocitem" href="../../implicit/Nordsieck/">OrdinaryDiffEqNordsieck</a></li></ul></li><li><span class="tocitem">IMEX Solvers</span><ul><li><a class="tocitem" href="../../imex/IMEXMultistep/">OrdinaryDiffEqIMEXMultistep</a></li><li><a class="tocitem" href="../../imex/StabilizedIRK/">OrdinaryDiffEqStabilizedIRK</a></li><li><a class="tocitem" href="../../imex/IMEXBDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><span class="tocitem">Dynamical ODE Explicit Solvers</span><ul><li><a class="tocitem" href="../../dynamicalodeexplicit/RKN/">OrdinaryDiffEqRKN</a></li><li><a class="tocitem" href="../../dynamicalodeexplicit/SymplecticRK/">OrdinaryDiffEqSymplecticRK</a></li></ul></li><li><span class="tocitem">Semilinear ODE Solvers</span><ul><li><a class="tocitem" href="../../semilinear/ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li><li><a class="tocitem" href="../../semilinear/Linear/">OrdinaryDiffEqLinear</a></li></ul></li><li><span class="tocitem">Mass Matrix DAE Solvers</span><ul><li><a class="tocitem" href="../../massmatrixdae/Rosenbrock/">OrdinaryDiffEqRosenbrock</a></li><li><a class="tocitem" href="../../massmatrixdae/BDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><span class="tocitem">Fully Implicit DAE Solvers</span><ul><li><a class="tocitem" href="../../fullyimplicitdae/BDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><span class="tocitem">Misc Solvers</span><ul><li><a class="tocitem" href="../../misc/">-</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Semi-Implicit Solvers</a></li><li class="is-active"><a href>OrdinaryDiffEqRosenbrock</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>OrdinaryDiffEqRosenbrock</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/OrdinaryDiffEq.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/master/docs/src/semiimplicit/Rosenbrock.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="OrdinaryDiffEqRosenbrock"><a class="docs-heading-anchor" href="#OrdinaryDiffEqRosenbrock">OrdinaryDiffEqRosenbrock</a><a id="OrdinaryDiffEqRosenbrock-1"></a><a class="docs-heading-anchor-permalink" href="#OrdinaryDiffEqRosenbrock" title="Permalink"></a></h1><p>Methods for small and medium sized stiff systems of differential equations. At high tolerances, <code>&gt;1e-2</code>, <code>Rosenbrock23</code> is a good choice. At medium tolerances <code>&gt;1e-8</code> it is recommended you use <code>Rodas5P</code> or <code>Rodas4P</code>, the former is more efficient, but the latter is more reliable. For larger systems look at multistep methods.</p><h2>Installation</h2><p>To be able to access the solvers in <code>OrdinaryDiffEqRosenbrock</code>, you must first install them use the Julia package manager:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;OrdinaryDiffEqRosenbrock&quot;)</code></pre><p>This will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.</p><h2>Example usage</h2><pre><code class="language-julia hljs">using OrdinaryDiffEqRosenbrock

function lorenz!(du, u, p, t)
    du[1] = 10.0 * (u[2] - u[1])
    du[2] = u[1] * (28.0 - u[3]) - u[2]
    du[3] = u[1] * u[2] - (8 / 3) * u[3]
end
u0 = [1.0; 0.0; 0.0]
tspan = (0.0, 100.0)
prob = ODEProblem(lorenz!, u0, tspan)
sol = solve(prob, Rodas5P())</code></pre><h2 id="Full-list-of-solvers"><a class="docs-heading-anchor" href="#Full-list-of-solvers">Full list of solvers</a><a id="Full-list-of-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Full-list-of-solvers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Rosenbrock23" href="#OrdinaryDiffEqRosenbrock.Rosenbrock23"><code>OrdinaryDiffEqRosenbrock.Rosenbrock23</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rosenbrock23(; chunk_size = Val{0}(),
               standardtag = Val{true}(),
               autodiff = AutoForwardDiff(),
               concrete_jac = nothing,
               diff_type = Val{:forward}(),
               linsolve = nothing,
               precs = DEFAULT_PRECS,
               step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  An Order 2/3 L-Stable Rosenbrock-W method which is good for very stiff equations with oscillations at low tolerances. 2nd order stiff-aware interpolation.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Rosenbrock23(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Shampine L.F. and Reichelt M., (1997) The MATLAB ODE Suite, SIAM Journal of</li></ul><p>Scientific Computing, 18 (1), pp. 1-22.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L916-L991">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Rosenbrock32" href="#OrdinaryDiffEqRosenbrock.Rosenbrock32"><code>OrdinaryDiffEqRosenbrock.Rosenbrock32</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rosenbrock32(; chunk_size = Val{0}(),
               standardtag = Val{true}(),
               autodiff = AutoForwardDiff(),
               concrete_jac = nothing,
               diff_type = Val{:forward}(),
               linsolve = nothing,
               precs = DEFAULT_PRECS,
               step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  An Order 3/2 A-Stable Rosenbrock-W method which is good for mildly stiff equations without oscillations at low tolerances. Note that this method is prone to instability in the presence of oscillations, so use with caution. 2nd order stiff-aware interpolation.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Rosenbrock32(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Shampine L.F. and Reichelt M., (1997) The MATLAB ODE Suite, SIAM Journal of</li></ul><p>Scientific Computing, 18 (1), pp. 1-22.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L927-L1002">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.ROS3P" href="#OrdinaryDiffEqRosenbrock.ROS3P"><code>OrdinaryDiffEqRosenbrock.ROS3P</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROS3P(; - `standardtag`: Specifies whether to use package-specific tags instead of the
            ForwardDiff default function-specific tags. For more information, see
            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
            Defaults to `Val{true}()`.
        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
            to specify whether to use automatic differentiation via
            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
            `nothing`, which means it will be chosen true/false depending on circumstances
            of the solver, such as whether a Krylov subspace method is used for `linsolve`.
        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
          `ROS3P(linsolve = KLUFactorization()`).
           When `nothing` is passed, uses `DefaultLinearSolver`.
        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
          can be used as a left or right preconditioner.
          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
          function where the arguments are defined as:
            - `W`: the current Jacobian of the nonlinear system. Specified as either
                ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                representation of the operator. Users can construct the W-matrix on demand
                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                the `jac_prototype`.
            - `du`: the current ODE derivative
            - `u`: the current ODE state
            - `p`: the ODE parameters
            - `t`: the current ODE time
            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                the last call to `precs`. It is recommended that this is checked to only
                update the preconditioner when `newW == true`.
            - `Plprev`: the previous `Pl`.
            - `Prprev`: the previous `Pr`.
            - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                Solver-dependent and subject to change.
          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
          To specify one-sided preconditioning, simply return `nothing` for the preconditioner
          which is not used. Additionally, `precs` must supply the dispatch:
          ```julia
          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
          ```
          which is used in the solver setup phase to construct the integrator
          type with the preconditioners `(Pl,Pr)`.
          The default is `precs=DEFAULT_PRECS` where the default preconditioner function
          is defined as:
          ```julia
          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
          ```
        step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method. Keeps high accuracy on discretizations of nonlinear parabolic PDEs.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Lang, J. &amp; Verwer, ROS3P—An Accurate Third-Order Rosenbrock Solver Designed for Parabolic Problems J. BIT Numerical Mathematics (2001) 41: 731. doi:10.1023/A:1021900219772</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L938-L1013">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Rodas3" href="#OrdinaryDiffEqRosenbrock.Rodas3"><code>OrdinaryDiffEqRosenbrock.Rodas3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rodas3(; - `standardtag`: Specifies whether to use package-specific tags instead of the
             ForwardDiff default function-specific tags. For more information, see
             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
             Defaults to `Val{true}()`.
         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
             to specify whether to use automatic differentiation via
             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
             `nothing`, which means it will be chosen true/false depending on circumstances
             of the solver, such as whether a Krylov subspace method is used for `linsolve`.
         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
           `Rodas3(linsolve = KLUFactorization()`).
            When `nothing` is passed, uses `DefaultLinearSolver`.
         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
           can be used as a left or right preconditioner.
           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
           function where the arguments are defined as:
             - `W`: the current Jacobian of the nonlinear system. Specified as either
                 ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                 representation of the operator. Users can construct the W-matrix on demand
                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                 the `jac_prototype`.
             - `du`: the current ODE derivative
             - `u`: the current ODE state
             - `p`: the ODE parameters
             - `t`: the current ODE time
             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                 the last call to `precs`. It is recommended that this is checked to only
                 update the preconditioner when `newW == true`.
             - `Plprev`: the previous `Pl`.
             - `Prprev`: the previous `Pr`.
             - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                 Solver-dependent and subject to change.
           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
           To specify one-sided preconditioning, simply return `nothing` for the preconditioner
           which is not used. Additionally, `precs` must supply the dispatch:
           ```julia
           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
           ```
           which is used in the solver setup phase to construct the integrator
           type with the preconditioners `(Pl,Pr)`.
           The default is `precs=DEFAULT_PRECS` where the default preconditioner function
           is defined as:
           ```julia
           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
           ```
         step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Sandu, Verwer, Van Loon, Carmichael, Potra, Dabdub, Seinfeld, Benchmarking stiff ode solvers for atmospheric chemistry problems-I.    implicit vs explicit, Atmospheric Environment, 31(19), 3151-3166, 1997.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1035-L1110">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Rodas23W" href="#OrdinaryDiffEqRosenbrock.Rodas23W"><code>OrdinaryDiffEqRosenbrock.Rodas23W</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rodas23W(; chunk_size = Val{0}(),
           standardtag = Val{true}(),
           autodiff = AutoForwardDiff(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  An Order 2/3 L-Stable Rosenbrock-W method for stiff ODEs and DAEs in mass matrix form. 2nd order stiff-aware interpolation and additional error test for interpolation.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Rodas23W(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Steinebach G., Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024 https://github.com/hbrs-cse/RosenbrockMethods/blob/main/paper/JuliaPaper.pdf</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L949-L1025">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Rodas3P" href="#OrdinaryDiffEqRosenbrock.Rodas3P"><code>OrdinaryDiffEqRosenbrock.Rodas3P</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rodas3P(; - `standardtag`: Specifies whether to use package-specific tags instead of the
              ForwardDiff default function-specific tags. For more information, see
              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
              Defaults to `Val{true}()`.
          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
              to specify whether to use automatic differentiation via
              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
              `nothing`, which means it will be chosen true/false depending on circumstances
              of the solver, such as whether a Krylov subspace method is used for `linsolve`.
          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
            `Rodas3P(linsolve = KLUFactorization()`).
             When `nothing` is passed, uses `DefaultLinearSolver`.
          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
            can be used as a left or right preconditioner.
            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
            function where the arguments are defined as:
              - `W`: the current Jacobian of the nonlinear system. Specified as either
                  ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                  representation of the operator. Users can construct the W-matrix on demand
                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                  the `jac_prototype`.
              - `du`: the current ODE derivative
              - `u`: the current ODE state
              - `p`: the ODE parameters
              - `t`: the current ODE time
              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                  the last call to `precs`. It is recommended that this is checked to only
                  update the preconditioner when `newW == true`.
              - `Plprev`: the previous `Pl`.
              - `Prprev`: the previous `Pr`.
              - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                  Solver-dependent and subject to change.
            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
            To specify one-sided preconditioning, simply return `nothing` for the preconditioner
            which is not used. Additionally, `precs` must supply the dispatch:
            ```julia
            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
            ```
            which is used in the solver setup phase to construct the integrator
            type with the preconditioners `(Pl,Pr)`.
            The default is `precs=DEFAULT_PRECS` where the default preconditioner function
            is defined as:
            ```julia
            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
            ```
          step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  3rd order A-stable and stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant and additional error test for interpolation. Keeps accuracy on discretizations of linear parabolic PDEs.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Steinebach G., Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024 https://github.com/hbrs-cse/RosenbrockMethods/blob/main/paper/JuliaPaper.pdf</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1046-L1123">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Rodas4" href="#OrdinaryDiffEqRosenbrock.Rodas4"><code>OrdinaryDiffEqRosenbrock.Rodas4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rodas4(; - `standardtag`: Specifies whether to use package-specific tags instead of the
             ForwardDiff default function-specific tags. For more information, see
             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
             Defaults to `Val{true}()`.
         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
             to specify whether to use automatic differentiation via
             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
             `nothing`, which means it will be chosen true/false depending on circumstances
             of the solver, such as whether a Krylov subspace method is used for `linsolve`.
         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
           `Rodas4(linsolve = KLUFactorization()`).
            When `nothing` is passed, uses `DefaultLinearSolver`.
         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
           can be used as a left or right preconditioner.
           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
           function where the arguments are defined as:
             - `W`: the current Jacobian of the nonlinear system. Specified as either
                 ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                 representation of the operator. Users can construct the W-matrix on demand
                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                 the `jac_prototype`.
             - `du`: the current ODE derivative
             - `u`: the current ODE state
             - `p`: the ODE parameters
             - `t`: the current ODE time
             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                 the last call to `precs`. It is recommended that this is checked to only
                 update the preconditioner when `newW == true`.
             - `Plprev`: the previous `Pl`.
             - `Prprev`: the previous `Pr`.
             - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                 Solver-dependent and subject to change.
           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
           To specify one-sided preconditioning, simply return `nothing` for the preconditioner
           which is not used. Additionally, `precs` must supply the dispatch:
           ```julia
           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
           ```
           which is used in the solver setup phase to construct the integrator
           type with the preconditioners `(Pl,Pr)`.
           The default is `precs=DEFAULT_PRECS` where the default preconditioner function
           is defined as:
           ```julia
           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
           ```
         step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  A 4th order L-stable Rosenbrock method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>E. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1059-L1134">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Rodas42" href="#OrdinaryDiffEqRosenbrock.Rodas42"><code>OrdinaryDiffEqRosenbrock.Rodas42</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rodas42(; - `standardtag`: Specifies whether to use package-specific tags instead of the
              ForwardDiff default function-specific tags. For more information, see
              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
              Defaults to `Val{true}()`.
          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
              to specify whether to use automatic differentiation via
              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
              `nothing`, which means it will be chosen true/false depending on circumstances
              of the solver, such as whether a Krylov subspace method is used for `linsolve`.
          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
            `Rodas42(linsolve = KLUFactorization()`).
             When `nothing` is passed, uses `DefaultLinearSolver`.
          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
            can be used as a left or right preconditioner.
            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
            function where the arguments are defined as:
              - `W`: the current Jacobian of the nonlinear system. Specified as either
                  ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                  representation of the operator. Users can construct the W-matrix on demand
                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                  the `jac_prototype`.
              - `du`: the current ODE derivative
              - `u`: the current ODE state
              - `p`: the ODE parameters
              - `t`: the current ODE time
              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                  the last call to `precs`. It is recommended that this is checked to only
                  update the preconditioner when `newW == true`.
              - `Plprev`: the previous `Pl`.
              - `Prprev`: the previous `Pr`.
              - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                  Solver-dependent and subject to change.
            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
            To specify one-sided preconditioning, simply return `nothing` for the preconditioner
            which is not used. Additionally, `precs` must supply the dispatch:
            ```julia
            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
            ```
            which is used in the solver setup phase to construct the integrator
            type with the preconditioners `(Pl,Pr)`.
            The default is `precs=DEFAULT_PRECS` where the default preconditioner function
            is defined as:
            ```julia
            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
            ```
          step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>E. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1082-L1157">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Rodas4P" href="#OrdinaryDiffEqRosenbrock.Rodas4P"><code>OrdinaryDiffEqRosenbrock.Rodas4P</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rodas4P(; - `standardtag`: Specifies whether to use package-specific tags instead of the
              ForwardDiff default function-specific tags. For more information, see
              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
              Defaults to `Val{true}()`.
          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
              to specify whether to use automatic differentiation via
              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
              `nothing`, which means it will be chosen true/false depending on circumstances
              of the solver, such as whether a Krylov subspace method is used for `linsolve`.
          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
            `Rodas4P(linsolve = KLUFactorization()`).
             When `nothing` is passed, uses `DefaultLinearSolver`.
          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
            can be used as a left or right preconditioner.
            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
            function where the arguments are defined as:
              - `W`: the current Jacobian of the nonlinear system. Specified as either
                  ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                  representation of the operator. Users can construct the W-matrix on demand
                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                  the `jac_prototype`.
              - `du`: the current ODE derivative
              - `u`: the current ODE state
              - `p`: the ODE parameters
              - `t`: the current ODE time
              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                  the last call to `precs`. It is recommended that this is checked to only
                  update the preconditioner when `newW == true`.
              - `Plprev`: the previous `Pl`.
              - `Prprev`: the previous `Pr`.
              - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                  Solver-dependent and subject to change.
            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
            To specify one-sided preconditioning, simply return `nothing` for the preconditioner
            which is not used. Additionally, `precs` must supply the dispatch:
            ```julia
            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
            ```
            which is used in the solver setup phase to construct the integrator
            type with the preconditioners `(Pl,Pr)`.
            The default is `precs=DEFAULT_PRECS` where the default preconditioner function
            is defined as:
            ```julia
            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
            ```
          step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems (as opposed to lower if not corrected).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Steinebach, G., Rentrop, P., An adaptive method of lines approach for modelling flow and transport in rivers.    Adaptive method of lines , Wouver, A. Vande, Sauces, Ph., Schiesser, W.E. (ed.),S. 181-205,Chapman &amp; Hall/CRC, 2001,</li><li>Steinebach, G., Oder-reduction of ROW-methods for DAEs and method of lines  applications.    Preprint-Nr. 1741, FB Mathematik, TH Darmstadt, 1995.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1093-L1172">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Rodas4P2" href="#OrdinaryDiffEqRosenbrock.Rodas4P2"><code>OrdinaryDiffEqRosenbrock.Rodas4P2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rodas4P2(; chunk_size = Val{0}(),
           standardtag = Val{true}(),
           autodiff = AutoForwardDiff(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant. 4th order on linear parabolic problems and 3rd order accurate on nonlinear parabolic problems. It is an improvement of Roadas4P and in case of inexact Jacobians a second order W method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Rodas4P2(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Steinebach G., Improvement of Rosenbrock-Wanner Method RODASP, In: Reis T., Grundel S., Schöps S. (eds)    Progress in Differential-Algebraic Equations II. Differential-Algebraic Equations Forum. Springer, Cham., 165-184, 2020.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1108-L1185">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Rodas5" href="#OrdinaryDiffEqRosenbrock.Rodas5"><code>OrdinaryDiffEqRosenbrock.Rodas5</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rodas5(; - `standardtag`: Specifies whether to use package-specific tags instead of the
             ForwardDiff default function-specific tags. For more information, see
             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
             Defaults to `Val{true}()`.
         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
             to specify whether to use automatic differentiation via
             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
             `nothing`, which means it will be chosen true/false depending on circumstances
             of the solver, such as whether a Krylov subspace method is used for `linsolve`.
         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
           `Rodas5(linsolve = KLUFactorization()`).
            When `nothing` is passed, uses `DefaultLinearSolver`.
         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
           can be used as a left or right preconditioner.
           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
           function where the arguments are defined as:
             - `W`: the current Jacobian of the nonlinear system. Specified as either
                 ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                 representation of the operator. Users can construct the W-matrix on demand
                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                 the `jac_prototype`.
             - `du`: the current ODE derivative
             - `u`: the current ODE state
             - `p`: the ODE parameters
             - `t`: the current ODE time
             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                 the last call to `precs`. It is recommended that this is checked to only
                 update the preconditioner when `newW == true`.
             - `Plprev`: the previous `Pl`.
             - `Prprev`: the previous `Pr`.
             - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                 Solver-dependent and subject to change.
           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
           To specify one-sided preconditioning, simply return `nothing` for the preconditioner
           which is not used. Additionally, `precs` must supply the dispatch:
           ```julia
           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
           ```
           which is used in the solver setup phase to construct the integrator
           type with the preconditioners `(Pl,Pr)`.
           The default is `precs=DEFAULT_PRECS` where the default preconditioner function
           is defined as:
           ```julia
           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
           ```
         step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  A 5th order A-stable stiffly stable Rosenbrock method with a stiff-aware 4th order interpolant.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Di Marzo G. RODAS5(4) – Méthodes de Rosenbrock d’ordre 5(4) adaptées aux problemes différentiels-algébriques. MSc mathematics thesis, Faculty of Science, University of Geneva, Switzerland.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1121-L1197">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Rodas5P" href="#OrdinaryDiffEqRosenbrock.Rodas5P"><code>OrdinaryDiffEqRosenbrock.Rodas5P</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rodas5P(; chunk_size = Val{0}(),
          standardtag = Val{true}(),
          autodiff = AutoForwardDiff(),
          concrete_jac = nothing,
          diff_type = Val{:forward}(),
          linsolve = nothing,
          precs = DEFAULT_PRECS,
          step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 5th order A-stable stiffly stable Rosenbrock method with a stiff-aware 4th order interpolant. Has improved stability in the adaptive time stepping embedding.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Rodas5P(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Steinebach G. Construction of Rosenbrock–Wanner method Rodas5P and numerical benchmarks within the Julia Differential Equations package. In: BIT Numerical Mathematics, 63(2), 2023</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1133-L1210">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Rodas5Pe" href="#OrdinaryDiffEqRosenbrock.Rodas5Pe"><code>OrdinaryDiffEqRosenbrock.Rodas5Pe</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rodas5Pe(; chunk_size = Val{0}(),
           standardtag = Val{true}(),
           autodiff = AutoForwardDiff(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  Variant of Ropdas5P with modified embedded scheme.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Rodas5Pe(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Steinebach G. Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024 https://github.com/hbrs-cse/RosenbrockMethods/blob/main/paper/JuliaPaper.pdf</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1158-L1234">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Rodas5Pr" href="#OrdinaryDiffEqRosenbrock.Rodas5Pr"><code>OrdinaryDiffEqRosenbrock.Rodas5Pr</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Rodas5Pr(; chunk_size = Val{0}(),
           standardtag = Val{true}(),
           autodiff = AutoForwardDiff(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  Variant of Ropdas5P with additional residual control.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Rodas5Pr(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Steinebach G. Rosenbrock methods within OrdinaryDiffEq.jl - Overview, recent developments and applications - Preprint 2024 https://github.com/hbrs-cse/RosenbrockMethods/blob/main/paper/JuliaPaper.pdf</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1146-L1222">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.RosenbrockW6S4OS" href="#OrdinaryDiffEqRosenbrock.RosenbrockW6S4OS"><code>OrdinaryDiffEqRosenbrock.RosenbrockW6S4OS</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RosenbrockW6S4OS(; chunk_size = Val{0}(),
                   standardtag = Val{true}(),
                   autodiff = AutoForwardDiff(),
                   concrete_jac = nothing,
                   diff_type = Val{:forward}(),
                   linsolve = nothing,
                   precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method (fixed step only).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>RosenbrockW6S4OS(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><p>https://doi.org/10.1016/j.cam.2009.09.017</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/algorithms.jl#L149-L221">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.ROS2" href="#OrdinaryDiffEqRosenbrock.ROS2"><code>OrdinaryDiffEqRosenbrock.ROS2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROS2(; - `standardtag`: Specifies whether to use package-specific tags instead of the
           ForwardDiff default function-specific tags. For more information, see
           [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
           Defaults to `Val{true}()`.
       - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
           to specify whether to use automatic differentiation via
           [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
           differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
           Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
           `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
           To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
           `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
       - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
           `nothing`, which means it will be chosen true/false depending on circumstances
           of the solver, such as whether a Krylov subspace method is used for `linsolve`.
       - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
         For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
         `ROS2(linsolve = KLUFactorization()`).
          When `nothing` is passed, uses `DefaultLinearSolver`.
       - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
         can be used as a left or right preconditioner.
         Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
         function where the arguments are defined as:
           - `W`: the current Jacobian of the nonlinear system. Specified as either
               ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
               commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
               representation of the operator. Users can construct the W-matrix on demand
               by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
               the `jac_prototype`.
           - `du`: the current ODE derivative
           - `u`: the current ODE state
           - `p`: the ODE parameters
           - `t`: the current ODE time
           - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
               the last call to `precs`. It is recommended that this is checked to only
               update the preconditioner when `newW == true`.
           - `Plprev`: the previous `Pl`.
           - `Prprev`: the previous `Pr`.
           - `solverdata`: Optional extra data the solvers can give to the `precs` function.
               Solver-dependent and subject to change.
         The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
         To specify one-sided preconditioning, simply return `nothing` for the preconditioner
         which is not used. Additionally, `precs` must supply the dispatch:
         ```julia
         Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
         ```
         which is used in the solver setup phase to construct the integrator
         type with the preconditioners `(Pl,Pr)`.
         The default is `precs=DEFAULT_PRECS` where the default preconditioner function
         is defined as:
         ```julia
         DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
         ```)</code></pre><p>Rosenbrock-Wanner Method.  A 2nd order L-stable Rosenbrock method with 2 internal stages.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>J. G. Verwer et al. (1999): A second-order Rosenbrock method applied to photochemical dispersion problems https://doi.org/10.1137/S1064827597326651</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1253-L1326">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.ROS2PR" href="#OrdinaryDiffEqRosenbrock.ROS2PR"><code>OrdinaryDiffEqRosenbrock.ROS2PR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROS2PR(; - `standardtag`: Specifies whether to use package-specific tags instead of the
             ForwardDiff default function-specific tags. For more information, see
             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
             Defaults to `Val{true}()`.
         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
             to specify whether to use automatic differentiation via
             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
             `nothing`, which means it will be chosen true/false depending on circumstances
             of the solver, such as whether a Krylov subspace method is used for `linsolve`.
         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
           `ROS2PR(linsolve = KLUFactorization()`).
            When `nothing` is passed, uses `DefaultLinearSolver`.
         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
           can be used as a left or right preconditioner.
           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
           function where the arguments are defined as:
             - `W`: the current Jacobian of the nonlinear system. Specified as either
                 ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                 representation of the operator. Users can construct the W-matrix on demand
                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                 the `jac_prototype`.
             - `du`: the current ODE derivative
             - `u`: the current ODE state
             - `p`: the ODE parameters
             - `t`: the current ODE time
             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                 the last call to `precs`. It is recommended that this is checked to only
                 update the preconditioner when `newW == true`.
             - `Plprev`: the previous `Pl`.
             - `Prprev`: the previous `Pr`.
             - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                 Solver-dependent and subject to change.
           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
           To specify one-sided preconditioning, simply return `nothing` for the preconditioner
           which is not used. Additionally, `precs` must supply the dispatch:
           ```julia
           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
           ```
           which is used in the solver setup phase to construct the integrator
           type with the preconditioners `(Pl,Pr)`.
           The default is `precs=DEFAULT_PRECS` where the default preconditioner function
           is defined as:
           ```julia
           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
           ```)</code></pre><p>Rosenbrock-Wanner Method.  2nd order stiffly accurate Rosenbrock method with 3 internal stages with (Rinf=0). For problems with medium stiffness the convergence behaviour is very poor and it is recommended to use <a href="#OrdinaryDiffEqRosenbrock.ROS2S"><code>ROS2S</code></a> instead.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1288-L1364">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.ROS2S" href="#OrdinaryDiffEqRosenbrock.ROS2S"><code>OrdinaryDiffEqRosenbrock.ROS2S</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROS2S(; chunk_size = Val{0}(),
        standardtag = Val{true}(),
        autodiff = AutoForwardDiff(),
        concrete_jac = nothing,
        diff_type = Val{:forward}(),
        linsolve = nothing,
        precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  2nd order stiffly accurate Rosenbrock-Wanner W-method with 3 internal stages with B_PR consistent of order 2 with (Rinf=0).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ROS2S(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1327-L1401">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.ROS3" href="#OrdinaryDiffEqRosenbrock.ROS3"><code>OrdinaryDiffEqRosenbrock.ROS3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROS3(; - `standardtag`: Specifies whether to use package-specific tags instead of the
           ForwardDiff default function-specific tags. For more information, see
           [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
           Defaults to `Val{true}()`.
       - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
           to specify whether to use automatic differentiation via
           [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
           differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
           Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
           `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
           To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
           `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
       - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
           `nothing`, which means it will be chosen true/false depending on circumstances
           of the solver, such as whether a Krylov subspace method is used for `linsolve`.
       - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
         For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
         `ROS3(linsolve = KLUFactorization()`).
          When `nothing` is passed, uses `DefaultLinearSolver`.
       - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
         can be used as a left or right preconditioner.
         Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
         function where the arguments are defined as:
           - `W`: the current Jacobian of the nonlinear system. Specified as either
               ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
               commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
               representation of the operator. Users can construct the W-matrix on demand
               by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
               the `jac_prototype`.
           - `du`: the current ODE derivative
           - `u`: the current ODE state
           - `p`: the ODE parameters
           - `t`: the current ODE time
           - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
               the last call to `precs`. It is recommended that this is checked to only
               update the preconditioner when `newW == true`.
           - `Plprev`: the previous `Pl`.
           - `Prprev`: the previous `Pr`.
           - `solverdata`: Optional extra data the solvers can give to the `precs` function.
               Solver-dependent and subject to change.
         The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
         To specify one-sided preconditioning, simply return `nothing` for the preconditioner
         which is not used. Additionally, `precs` must supply the dispatch:
         ```julia
         Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
         ```
         which is used in the solver setup phase to construct the integrator
         type with the preconditioners `(Pl,Pr)`.
         The default is `precs=DEFAULT_PRECS` where the default preconditioner function
         is defined as:
         ```julia
         DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
         ```)</code></pre><p>Rosenbrock-Wanner Method.  3rd order L-stable Rosenbrock method with 3 internal stages with an embedded strongly A-stable 2nd order method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>E. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1361-L1435">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.ROS3PR" href="#OrdinaryDiffEqRosenbrock.ROS3PR"><code>OrdinaryDiffEqRosenbrock.ROS3PR</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROS3PR(; - `standardtag`: Specifies whether to use package-specific tags instead of the
             ForwardDiff default function-specific tags. For more information, see
             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
             Defaults to `Val{true}()`.
         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
             to specify whether to use automatic differentiation via
             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
             `nothing`, which means it will be chosen true/false depending on circumstances
             of the solver, such as whether a Krylov subspace method is used for `linsolve`.
         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
           `ROS3PR(linsolve = KLUFactorization()`).
            When `nothing` is passed, uses `DefaultLinearSolver`.
         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
           can be used as a left or right preconditioner.
           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
           function where the arguments are defined as:
             - `W`: the current Jacobian of the nonlinear system. Specified as either
                 ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                 representation of the operator. Users can construct the W-matrix on demand
                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                 the `jac_prototype`.
             - `du`: the current ODE derivative
             - `u`: the current ODE state
             - `p`: the ODE parameters
             - `t`: the current ODE time
             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                 the last call to `precs`. It is recommended that this is checked to only
                 update the preconditioner when `newW == true`.
             - `Plprev`: the previous `Pl`.
             - `Prprev`: the previous `Pr`.
             - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                 Solver-dependent and subject to change.
           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
           To specify one-sided preconditioning, simply return `nothing` for the preconditioner
           which is not used. Additionally, `precs` must supply the dispatch:
           ```julia
           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
           ```
           which is used in the solver setup phase to construct the integrator
           type with the preconditioners `(Pl,Pr)`.
           The default is `precs=DEFAULT_PRECS` where the default preconditioner function
           is defined as:
           ```julia
           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
           ```)</code></pre><p>Rosenbrock-Wanner Method.  3nd order stiffly accurate Rosenbrock method with 3 internal stages with B_PR consistent of order 3, which is strongly A-stable with Rinf~=-0.73.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1395-L1469">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Scholz4_7" href="#OrdinaryDiffEqRosenbrock.Scholz4_7"><code>OrdinaryDiffEqRosenbrock.Scholz4_7</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Scholz4_7(; - `standardtag`: Specifies whether to use package-specific tags instead of the
                ForwardDiff default function-specific tags. For more information, see
                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
                Defaults to `Val{true}()`.
            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
                to specify whether to use automatic differentiation via
                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
                `nothing`, which means it will be chosen true/false depending on circumstances
                of the solver, such as whether a Krylov subspace method is used for `linsolve`.
            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
              `Scholz4_7(linsolve = KLUFactorization()`).
               When `nothing` is passed, uses `DefaultLinearSolver`.
            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
              can be used as a left or right preconditioner.
              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
              function where the arguments are defined as:
                - `W`: the current Jacobian of the nonlinear system. Specified as either
                    ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                    representation of the operator. Users can construct the W-matrix on demand
                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                    the `jac_prototype`.
                - `du`: the current ODE derivative
                - `u`: the current ODE state
                - `p`: the ODE parameters
                - `t`: the current ODE time
                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                    the last call to `precs`. It is recommended that this is checked to only
                    update the preconditioner when `newW == true`.
                - `Plprev`: the previous `Pl`.
                - `Prprev`: the previous `Pr`.
                - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                    Solver-dependent and subject to change.
              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
              To specify one-sided preconditioning, simply return `nothing` for the preconditioner
              which is not used. Additionally, `precs` must supply the dispatch:
              ```julia
              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
              ```
              which is used in the solver setup phase to construct the integrator
              type with the preconditioners `(Pl,Pr)`.
              The default is `precs=DEFAULT_PRECS` where the default preconditioner function
              is defined as:
              ```julia
              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
              ```)</code></pre><p>Rosenbrock-Wanner Method.  3nd order stiffly accurate Rosenbrock method with 3 internal stages with B_PR consistent of order 3, which is strongly A-stable with Rinf~=-0.73. Convergence with order 4 for the stiff case, but has a poor accuracy.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1431-L1506">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.ROS34PW1a" href="#OrdinaryDiffEqRosenbrock.ROS34PW1a"><code>OrdinaryDiffEqRosenbrock.ROS34PW1a</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROS34PW1a(; chunk_size = Val{0}(),
            standardtag = Val{true}(),
            autodiff = AutoForwardDiff(),
            concrete_jac = nothing,
            diff_type = Val{:forward}(),
            linsolve = nothing,
            precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ROS34PW1a(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><p>@article{rang2005new,   title={New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1},   author={Rang, Joachim and Angermann, L},   journal={BIT Numerical Mathematics},   volume={45},   pages={761–787},   year={2005},   publisher={Springer}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L961-L1040">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.ROS34PW1b" href="#OrdinaryDiffEqRosenbrock.ROS34PW1b"><code>OrdinaryDiffEqRosenbrock.ROS34PW1b</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROS34PW1b(; chunk_size = Val{0}(),
            standardtag = Val{true}(),
            autodiff = AutoForwardDiff(),
            concrete_jac = nothing,
            diff_type = Val{:forward}(),
            linsolve = nothing,
            precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 4th order L-stable Rosenbrock-W method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ROS34PW1b(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><p>@article{rang2005new,   title={New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1},   author={Rang, Joachim and Angermann, L},   journal={BIT Numerical Mathematics},   volume={45},   pages={761–787},   year={2005},   publisher={Springer}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L977-L1056">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.ROS34PW2" href="#OrdinaryDiffEqRosenbrock.ROS34PW2"><code>OrdinaryDiffEqRosenbrock.ROS34PW2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROS34PW2(; chunk_size = Val{0}(),
           standardtag = Val{true}(),
           autodiff = AutoForwardDiff(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 4th order stiffy accurate Rosenbrock-W method for PDAEs.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ROS34PW2(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><p>@article{rang2005new,   title={New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1},   author={Rang, Joachim and Angermann, L},   journal={BIT Numerical Mathematics},   volume={45},   pages={761–787},   year={2005},   publisher={Springer}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L993-L1072">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.ROS34PW3" href="#OrdinaryDiffEqRosenbrock.ROS34PW3"><code>OrdinaryDiffEqRosenbrock.ROS34PW3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROS34PW3(; chunk_size = Val{0}(),
           standardtag = Val{true}(),
           autodiff = AutoForwardDiff(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 4th order strongly A-stable (Rinf~0.63) Rosenbrock-W method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ROS34PW3(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><p>@article{rang2005new,   title={New Rosenbrock W-methods of order 3 for partial differential algebraic equations of index 1},   author={Rang, Joachim and Angermann, L},   journal={BIT Numerical Mathematics},   volume={45},   pages={761–787},   year={2005},   publisher={Springer}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1009-L1088">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.ROS34PRw" href="#OrdinaryDiffEqRosenbrock.ROS34PRw"><code>OrdinaryDiffEqRosenbrock.ROS34PRw</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROS34PRw(; chunk_size = Val{0}(),
           standardtag = Val{true}(),
           autodiff = AutoForwardDiff(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  3rd order stiffly accurate Rosenbrock-Wanner W-method with 4 internal stages, B_PR consistent of order 2. The order of convergence decreases if medium stiff problems are considered.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ROS34PRw(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><ul><li>Joachim Rang, Improved traditional Rosenbrock–Wanner methods for stiff ODEs and DAEs, Journal of Computational and Applied Mathematics, https://doi.org/10.1016/j.cam.2015.03.010</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1622-L1698">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.ROS3PRL" href="#OrdinaryDiffEqRosenbrock.ROS3PRL"><code>OrdinaryDiffEqRosenbrock.ROS3PRL</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROS3PRL(; - `standardtag`: Specifies whether to use package-specific tags instead of the
              ForwardDiff default function-specific tags. For more information, see
              [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
              Defaults to `Val{true}()`.
          - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
              to specify whether to use automatic differentiation via
              [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
              differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
              Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
              `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
              To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
              `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
          - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
              `nothing`, which means it will be chosen true/false depending on circumstances
              of the solver, such as whether a Krylov subspace method is used for `linsolve`.
          - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
            For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
            `ROS3PRL(linsolve = KLUFactorization()`).
             When `nothing` is passed, uses `DefaultLinearSolver`.
          - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
            can be used as a left or right preconditioner.
            Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
            function where the arguments are defined as:
              - `W`: the current Jacobian of the nonlinear system. Specified as either
                  ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                  commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                  representation of the operator. Users can construct the W-matrix on demand
                  by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                  the `jac_prototype`.
              - `du`: the current ODE derivative
              - `u`: the current ODE state
              - `p`: the ODE parameters
              - `t`: the current ODE time
              - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                  the last call to `precs`. It is recommended that this is checked to only
                  update the preconditioner when `newW == true`.
              - `Plprev`: the previous `Pl`.
              - `Prprev`: the previous `Pr`.
              - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                  Solver-dependent and subject to change.
            The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
            To specify one-sided preconditioning, simply return `nothing` for the preconditioner
            which is not used. Additionally, `precs` must supply the dispatch:
            ```julia
            Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
            ```
            which is used in the solver setup phase to construct the integrator
            type with the preconditioners `(Pl,Pr)`.
            The default is `precs=DEFAULT_PRECS` where the default preconditioner function
            is defined as:
            ```julia
            DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
            ```)</code></pre><p>Rosenbrock-Wanner Method.  3rd order stiffly accurate Rosenbrock method with 4 internal stages, B_PR consistent of order 2 with Rinf=0. The order of convergence decreases if medium stiff problems are considered, but it has good results for very stiff cases.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1661-L1737">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.ROS3PRL2" href="#OrdinaryDiffEqRosenbrock.ROS3PRL2"><code>OrdinaryDiffEqRosenbrock.ROS3PRL2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROS3PRL2(; - `standardtag`: Specifies whether to use package-specific tags instead of the
               ForwardDiff default function-specific tags. For more information, see
               [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
               Defaults to `Val{true}()`.
           - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
               to specify whether to use automatic differentiation via
               [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
               differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
               Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
               `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
               To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
               `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
           - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
               `nothing`, which means it will be chosen true/false depending on circumstances
               of the solver, such as whether a Krylov subspace method is used for `linsolve`.
           - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
             For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
             `ROS3PRL2(linsolve = KLUFactorization()`).
              When `nothing` is passed, uses `DefaultLinearSolver`.
           - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
             can be used as a left or right preconditioner.
             Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
             function where the arguments are defined as:
               - `W`: the current Jacobian of the nonlinear system. Specified as either
                   ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                   commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                   representation of the operator. Users can construct the W-matrix on demand
                   by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                   the `jac_prototype`.
               - `du`: the current ODE derivative
               - `u`: the current ODE state
               - `p`: the ODE parameters
               - `t`: the current ODE time
               - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                   the last call to `precs`. It is recommended that this is checked to only
                   update the preconditioner when `newW == true`.
               - `Plprev`: the previous `Pl`.
               - `Prprev`: the previous `Pr`.
               - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                   Solver-dependent and subject to change.
             The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
             To specify one-sided preconditioning, simply return `nothing` for the preconditioner
             which is not used. Additionally, `precs` must supply the dispatch:
             ```julia
             Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
             ```
             which is used in the solver setup phase to construct the integrator
             type with the preconditioners `(Pl,Pr)`.
             The default is `precs=DEFAULT_PRECS` where the default preconditioner function
             is defined as:
             ```julia
             DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
             ```)</code></pre><p>Rosenbrock-Wanner Method.  3rd order stiffly accurate Rosenbrock method with 4 internal stages, B_PR consistent of order 3. The order of convergence does NOT decreases if medium stiff problems are considered as it does for <a href="#OrdinaryDiffEqRosenbrock.ROS3PRL"><code>ROS3PRL</code></a>.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>Rang, Joachim (2014): The Prothero and Robinson example: Convergence studies for Runge-Kutta and Rosenbrock-Wanner methods. https://doi.org/10.24355/dbbs.084-201408121139-0</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1701-L1777">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.ROK4a" href="#OrdinaryDiffEqRosenbrock.ROK4a"><code>OrdinaryDiffEqRosenbrock.ROK4a</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ROK4a(; chunk_size = Val{0}(),
        standardtag = Val{true}(),
        autodiff = AutoForwardDiff(),
        concrete_jac = nothing,
        diff_type = Val{:forward}(),
        linsolve = nothing,
        precs = DEFAULT_PRECS)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  4rd order L-stable Rosenbrock-Krylov method with 4 internal stages, with a 3rd order embedded method which is strongly A-stable with Rinf~=0.55. (when using exact Jacobians)</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ROK4a(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li></ul><p><strong>References</strong></p><ul><li>Tranquilli, Paul and Sandu, Adrian (2014): Rosenbrock–Krylov Methods for Large Systems of Differential Equations https://doi.org/10.1137/130923336</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1739-L1814">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.RosShamp4" href="#OrdinaryDiffEqRosenbrock.RosShamp4"><code>OrdinaryDiffEqRosenbrock.RosShamp4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">RosShamp4(; - `standardtag`: Specifies whether to use package-specific tags instead of the
                ForwardDiff default function-specific tags. For more information, see
                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
                Defaults to `Val{true}()`.
            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
                to specify whether to use automatic differentiation via
                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
                `nothing`, which means it will be chosen true/false depending on circumstances
                of the solver, such as whether a Krylov subspace method is used for `linsolve`.
            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
              `RosShamp4(linsolve = KLUFactorization()`).
               When `nothing` is passed, uses `DefaultLinearSolver`.
            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
              can be used as a left or right preconditioner.
              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
              function where the arguments are defined as:
                - `W`: the current Jacobian of the nonlinear system. Specified as either
                    ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                    representation of the operator. Users can construct the W-matrix on demand
                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                    the `jac_prototype`.
                - `du`: the current ODE derivative
                - `u`: the current ODE state
                - `p`: the ODE parameters
                - `t`: the current ODE time
                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                    the last call to `precs`. It is recommended that this is checked to only
                    update the preconditioner when `newW == true`.
                - `Plprev`: the previous `Pl`.
                - `Prprev`: the previous `Pr`.
                - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                    Solver-dependent and subject to change.
              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
              To specify one-sided preconditioning, simply return `nothing` for the preconditioner
              which is not used. Additionally, `precs` must supply the dispatch:
              ```julia
              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
              ```
              which is used in the solver setup phase to construct the integrator
              type with the preconditioners `(Pl,Pr)`.
              The default is `precs=DEFAULT_PRECS` where the default preconditioner function
              is defined as:
              ```julia
              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
              ```)</code></pre><p>Rosenbrock-Wanner Method.  An A-stable 4th order Rosenbrock method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li></ul><p><strong>References</strong></p><ul><li>L. F. Shampine, Implementation of Rosenbrock Methods, ACM Transactions on Mathematical Software (TOMS), 8: 2, 93-113. doi:10.1145/355993.355994</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1025-L1098">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Veldd4" href="#OrdinaryDiffEqRosenbrock.Veldd4"><code>OrdinaryDiffEqRosenbrock.Veldd4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Veldd4(; - `standardtag`: Specifies whether to use package-specific tags instead of the
             ForwardDiff default function-specific tags. For more information, see
             [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
             Defaults to `Val{true}()`.
         - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
             to specify whether to use automatic differentiation via
             [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
             differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
             Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
             `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
             To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
             `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
         - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
             `nothing`, which means it will be chosen true/false depending on circumstances
             of the solver, such as whether a Krylov subspace method is used for `linsolve`.
         - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
           For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
           `Veldd4(linsolve = KLUFactorization()`).
            When `nothing` is passed, uses `DefaultLinearSolver`.
         - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
           can be used as a left or right preconditioner.
           Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
           function where the arguments are defined as:
             - `W`: the current Jacobian of the nonlinear system. Specified as either
                 ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                 commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                 representation of the operator. Users can construct the W-matrix on demand
                 by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                 the `jac_prototype`.
             - `du`: the current ODE derivative
             - `u`: the current ODE state
             - `p`: the ODE parameters
             - `t`: the current ODE time
             - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                 the last call to `precs`. It is recommended that this is checked to only
                 update the preconditioner when `newW == true`.
             - `Plprev`: the previous `Pl`.
             - `Prprev`: the previous `Pr`.
             - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                 Solver-dependent and subject to change.
           The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
           To specify one-sided preconditioning, simply return `nothing` for the preconditioner
           which is not used. Additionally, `precs` must supply the dispatch:
           ```julia
           Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
           ```
           which is used in the solver setup phase to construct the integrator
           type with the preconditioners `(Pl,Pr)`.
           The default is `precs=DEFAULT_PRECS` where the default preconditioner function
           is defined as:
           ```julia
           DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
           ```
         step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  A 4th order D-stable Rosenbrock method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>van Veldhuizen, D-stability and Kaps-Rentrop-methods, M. Computing (1984) 32: 229. doi:10.1007/BF02243574</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1192-L1267">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Velds4" href="#OrdinaryDiffEqRosenbrock.Velds4"><code>OrdinaryDiffEqRosenbrock.Velds4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Velds4(; chunk_size = Val{0}(),
         standardtag = Val{true}(),
         autodiff = AutoForwardDiff(),
         concrete_jac = nothing,
         diff_type = Val{:forward}(),
         linsolve = nothing,
         precs = DEFAULT_PRECS,
         step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner-W(olfbrandt) Method.  A 4th order A-stable Rosenbrock method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Velds4(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>van Veldhuizen, D-stability and Kaps-Rentrop-methods, M. Computing (1984) 32: 229. doi:10.1007/BF02243574</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1203-L1278">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.GRK4T" href="#OrdinaryDiffEqRosenbrock.GRK4T"><code>OrdinaryDiffEqRosenbrock.GRK4T</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GRK4T(; - `standardtag`: Specifies whether to use package-specific tags instead of the
            ForwardDiff default function-specific tags. For more information, see
            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
            Defaults to `Val{true}()`.
        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
            to specify whether to use automatic differentiation via
            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
            `nothing`, which means it will be chosen true/false depending on circumstances
            of the solver, such as whether a Krylov subspace method is used for `linsolve`.
        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
          `GRK4T(linsolve = KLUFactorization()`).
           When `nothing` is passed, uses `DefaultLinearSolver`.
        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
          can be used as a left or right preconditioner.
          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
          function where the arguments are defined as:
            - `W`: the current Jacobian of the nonlinear system. Specified as either
                ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                representation of the operator. Users can construct the W-matrix on demand
                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                the `jac_prototype`.
            - `du`: the current ODE derivative
            - `u`: the current ODE state
            - `p`: the ODE parameters
            - `t`: the current ODE time
            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                the last call to `precs`. It is recommended that this is checked to only
                update the preconditioner when `newW == true`.
            - `Plprev`: the previous `Pl`.
            - `Prprev`: the previous `Pr`.
            - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                Solver-dependent and subject to change.
          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
          To specify one-sided preconditioning, simply return `nothing` for the preconditioner
          which is not used. Additionally, `precs` must supply the dispatch:
          ```julia
          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
          ```
          which is used in the solver setup phase to construct the integrator
          type with the preconditioners `(Pl,Pr)`.
          The default is `precs=DEFAULT_PRECS` where the default preconditioner function
          is defined as:
          ```julia
          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
          ```
        step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  An efficient 4th order Rosenbrock method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Kaps, P. &amp; Rentrop, Generalized Runge-Kutta methods of order four with stepsize control for stiff ordinary differential equations. P. Numer. Math. (1979) 33: 55. doi:10.1007/BF01396495</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1170-L1245">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.GRK4A" href="#OrdinaryDiffEqRosenbrock.GRK4A"><code>OrdinaryDiffEqRosenbrock.GRK4A</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">GRK4A(; - `standardtag`: Specifies whether to use package-specific tags instead of the
            ForwardDiff default function-specific tags. For more information, see
            [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
            Defaults to `Val{true}()`.
        - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
            to specify whether to use automatic differentiation via
            [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
            differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
            Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
            `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
            To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
            `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
        - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
            `nothing`, which means it will be chosen true/false depending on circumstances
            of the solver, such as whether a Krylov subspace method is used for `linsolve`.
        - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
          For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
          `GRK4A(linsolve = KLUFactorization()`).
           When `nothing` is passed, uses `DefaultLinearSolver`.
        - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
          can be used as a left or right preconditioner.
          Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
          function where the arguments are defined as:
            - `W`: the current Jacobian of the nonlinear system. Specified as either
                ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                representation of the operator. Users can construct the W-matrix on demand
                by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                the `jac_prototype`.
            - `du`: the current ODE derivative
            - `u`: the current ODE state
            - `p`: the ODE parameters
            - `t`: the current ODE time
            - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                the last call to `precs`. It is recommended that this is checked to only
                update the preconditioner when `newW == true`.
            - `Plprev`: the previous `Pl`.
            - `Prprev`: the previous `Pr`.
            - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                Solver-dependent and subject to change.
          The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
          To specify one-sided preconditioning, simply return `nothing` for the preconditioner
          which is not used. Additionally, `precs` must supply the dispatch:
          ```julia
          Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
          ```
          which is used in the solver setup phase to construct the integrator
          type with the preconditioners `(Pl,Pr)`.
          The default is `precs=DEFAULT_PRECS` where the default preconditioner function
          is defined as:
          ```julia
          DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
          ```
        step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  An A-stable 4th order Rosenbrock method. Essentially &quot;anti-L-stable&quot; but efficient.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>Kaps, P. &amp; Rentrop, Generalized Runge-Kutta methods of order four with stepsize control for stiff ordinary differential equations. P. Numer. Math. (1979) 33: 55. doi:10.1007/BF01396495</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1181-L1256">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqRosenbrock.Ros4LStab" href="#OrdinaryDiffEqRosenbrock.Ros4LStab"><code>OrdinaryDiffEqRosenbrock.Ros4LStab</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Ros4LStab(; - `standardtag`: Specifies whether to use package-specific tags instead of the
                ForwardDiff default function-specific tags. For more information, see
                [this blog post](https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/).
                Defaults to `Val{true}()`.
            - `autodiff`: Uses [ADTypes.jl](https://sciml.github.io/ADTypes.jl/stable/) 
                to specify whether to use automatic differentiation via
                [ForwardDiff.jl](https://github.com/JuliaDiff/ForwardDiff.jl) or finite
                differencing via [FiniteDiff.jl](https://github.com/JuliaDiff/FiniteDiff.jl). 
                Defaults to `AutoForwardDiff()` for automatic differentiation, which by default uses
                `chunksize = 0`, and thus uses the internal ForwardDiff.jl algorithm for the choice.
                To use `FiniteDiff.jl`, the `AutoFiniteDiff()` ADType can be used, which has a keyword argument
                `fdtype` with default value `Val{:forward}()`, and alternatives `Val{:central}()` and `Val{:complex}()`.
            - `concrete_jac`: Specifies whether a Jacobian should be constructed. Defaults to
                `nothing`, which means it will be chosen true/false depending on circumstances
                of the solver, such as whether a Krylov subspace method is used for `linsolve`.
            - `linsolve`: Any [LinearSolve.jl](https://github.com/SciML/LinearSolve.jl) compatible linear solver.
              For example, to use [KLU.jl](https://github.com/JuliaSparse/KLU.jl), specify
              `Ros4LStab(linsolve = KLUFactorization()`).
               When `nothing` is passed, uses `DefaultLinearSolver`.
            - `precs`: Any [LinearSolve.jl-compatible preconditioner](https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/)
              can be used as a left or right preconditioner.
              Preconditioners are specified by the `Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)`
              function where the arguments are defined as:
                - `W`: the current Jacobian of the nonlinear system. Specified as either
                    ``I - \gamma J`` or ``I/\gamma - J`` depending on the algorithm. This will
                    commonly be a `WOperator` type defined by OrdinaryDiffEq.jl. It is a lazy
                    representation of the operator. Users can construct the W-matrix on demand
                    by calling `convert(AbstractMatrix,W)` to receive an `AbstractMatrix` matching
                    the `jac_prototype`.
                - `du`: the current ODE derivative
                - `u`: the current ODE state
                - `p`: the ODE parameters
                - `t`: the current ODE time
                - `newW`: a `Bool` which specifies whether the `W` matrix has been updated since
                    the last call to `precs`. It is recommended that this is checked to only
                    update the preconditioner when `newW == true`.
                - `Plprev`: the previous `Pl`.
                - `Prprev`: the previous `Pr`.
                - `solverdata`: Optional extra data the solvers can give to the `precs` function.
                    Solver-dependent and subject to change.
              The return is a tuple `(Pl,Pr)` of the LinearSolve.jl-compatible preconditioners.
              To specify one-sided preconditioning, simply return `nothing` for the preconditioner
              which is not used. Additionally, `precs` must supply the dispatch:
              ```julia
              Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)
              ```
              which is used in the solver setup phase to construct the integrator
              type with the preconditioners `(Pl,Pr)`.
              The default is `precs=DEFAULT_PRECS` where the default preconditioner function
              is defined as:
              ```julia
              DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing
              ```
            step_limiter! = OrdinaryDiffEq.trivial_limiter!)</code></pre><p>Rosenbrock-Wanner Method.  A 4th order A-stable stiffly stable Rosenbrock method with a stiff-aware 3rd order interpolant</p><p><strong>Keyword Arguments</strong></p><ul><li><code>chunk_size</code>: TBD</li><li><code>standardtag</code>: TBD</li><li><code>autodiff</code>: boolean to control if the Jacobian should be computed via AD or not</li><li><code>concrete_jac</code>: function of the form <code>jac!(J, u, p, t)</code></li><li><code>diff_type</code>: TBD</li><li><code>linsolve</code>: custom solver for the inner linear systems</li><li><code>precs</code>: custom preconditioner for the inner linear solver</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><ul><li>E. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and differential-algebraic problems. Computational mathematics (2nd revised ed.), Springer (1996)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/c8ef296e20fbbacf1f15bf7febd1397f96bcfc3d/lib/OrdinaryDiffEqRosenbrock/src/generic_rosenbrock.jl#L1070-L1145">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../explicit/Extrapolation/">« OrdinaryDiffEqExtrapolation</a><a class="docs-footer-nextpage" href="../StabilizedRK/">OrdinaryDiffEqStabilizedRK »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Tuesday 15 July 2025 19:40">Tuesday 15 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
