<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>OrdinaryDiffEqSDIRK · OrdinaryDiffEq.jl</title><meta name="title" content="OrdinaryDiffEqSDIRK · OrdinaryDiffEq.jl"/><meta property="og:title" content="OrdinaryDiffEqSDIRK · OrdinaryDiffEq.jl"/><meta property="twitter:title" content="OrdinaryDiffEqSDIRK · OrdinaryDiffEq.jl"/><meta name="description" content="Documentation for OrdinaryDiffEq.jl."/><meta property="og:description" content="Documentation for OrdinaryDiffEq.jl."/><meta property="twitter:description" content="Documentation for OrdinaryDiffEq.jl."/><meta property="og:url" content="https://ordinarydiffeq.sciml.ai/stable/implicit/SDIRK/"/><meta property="twitter:url" content="https://ordinarydiffeq.sciml.ai/stable/implicit/SDIRK/"/><link rel="canonical" href="https://ordinarydiffeq.sciml.ai/stable/implicit/SDIRK/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="OrdinaryDiffEq.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">OrdinaryDiffEq.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">OrdinaryDiffEq.jl: ODE solvers and utilities</a></li><li><a class="tocitem" href="../../usage/">Usage</a></li><li><span class="tocitem">Explicit Solvers</span><ul><li><a class="tocitem" href="../../explicit/Tsit5/">OrdinaryDiffEqTsit5</a></li><li><a class="tocitem" href="../../explicit/Verner/">OrdinaryDiffEqVerner</a></li><li><a class="tocitem" href="../../explicit/AdamsBashforthMoulton/">OrdinaryDiffEqAdamsBashforthMoulton</a></li><li><a class="tocitem" href="../../explicit/LowStorageRK/">OrdinaryDiffEqLowStorageRK</a></li><li><a class="tocitem" href="../../explicit/SSPRK/">OrdinaryDiffEqSSPRK</a></li><li><a class="tocitem" href="../../explicit/LowOrderRK/">OrdinaryDiffEqLowOrderRK</a></li><li><a class="tocitem" href="../../explicit/HighOrderRK/">OrdinaryDiffEqHighOrderRK</a></li><li><a class="tocitem" href="../../explicit/Feagin/">OrdinaryDiffEqFeagin</a></li><li><a class="tocitem" href="../../explicit/PRK/">OrdinaryDiffEqPRK</a></li><li><a class="tocitem" href="../../explicit/QPRK/">OrdinaryDiffEqQPRK</a></li><li><a class="tocitem" href="../../explicit/TaylorSeries/">OrdinaryDiffEqTaylorSeries</a></li><li><a class="tocitem" href="../../explicit/Extrapolation/">OrdinaryDiffEqExtrapolation</a></li></ul></li><li><span class="tocitem">Semi-Implicit Solvers</span><ul><li><a class="tocitem" href="../../semiimplicit/Rosenbrock/">OrdinaryDiffEqRosenbrock</a></li><li><a class="tocitem" href="../../semiimplicit/StabilizedRK/">OrdinaryDiffEqStabilizedRK</a></li><li><a class="tocitem" href="../../semiimplicit/ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li></ul></li><li><span class="tocitem">Implicit Solvers</span><ul><li class="is-active"><a class="tocitem" href>OrdinaryDiffEqSDIRK</a><ul class="internal"><li><a class="tocitem" href="#Key-Properties"><span>Key Properties</span></a></li><li><a class="tocitem" href="#When-to-Use-SDIRK-Methods"><span>When to Use SDIRK Methods</span></a></li><li><a class="tocitem" href="#Solver-Selection-Guide"><span>Solver Selection Guide</span></a></li><li><a class="tocitem" href="#Full-list-of-solvers"><span>Full list of solvers</span></a></li></ul></li><li><a class="tocitem" href="../FIRK/">OrdinaryDiffEqFIRK</a></li><li><a class="tocitem" href="../BDF/">OrdinaryDiffEqBDF</a></li><li><a class="tocitem" href="../Extrapolation/">OrdinaryDiffEqExtrapolation</a></li><li><a class="tocitem" href="../PDIRK/">OrdinaryDiffEqPDIRK</a></li><li><a class="tocitem" href="../Nordsieck/">OrdinaryDiffEqNordsieck</a></li></ul></li><li><span class="tocitem">IMEX Solvers</span><ul><li><a class="tocitem" href="../../imex/IMEXMultistep/">OrdinaryDiffEqIMEXMultistep</a></li><li><a class="tocitem" href="../../imex/StabilizedIRK/">OrdinaryDiffEqStabilizedIRK</a></li><li><a class="tocitem" href="../../imex/IMEXBDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><span class="tocitem">Dynamical ODE Explicit Solvers</span><ul><li><a class="tocitem" href="../../dynamicalodeexplicit/RKN/">OrdinaryDiffEqRKN</a></li><li><a class="tocitem" href="../../dynamicalodeexplicit/SymplecticRK/">OrdinaryDiffEqSymplecticRK</a></li></ul></li><li><span class="tocitem">Semilinear ODE Solvers</span><ul><li><a class="tocitem" href="../../semilinear/ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li><li><a class="tocitem" href="../../semilinear/Linear/">OrdinaryDiffEqLinear</a></li></ul></li><li><span class="tocitem">Mass Matrix DAE Solvers</span><ul><li><a class="tocitem" href="../../massmatrixdae/Rosenbrock/">OrdinaryDiffEqRosenbrock</a></li><li><a class="tocitem" href="../../massmatrixdae/BDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><span class="tocitem">Fully Implicit DAE Solvers</span><ul><li><a class="tocitem" href="../../fullyimplicitdae/BDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><span class="tocitem">Misc Solvers</span><ul><li><a class="tocitem" href="../../misc/">Miscellaneous Solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Implicit Solvers</a></li><li class="is-active"><a href>OrdinaryDiffEqSDIRK</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>OrdinaryDiffEqSDIRK</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/OrdinaryDiffEq.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/master/docs/src/implicit/SDIRK.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="OrdinaryDiffEqSDIRK"><a class="docs-heading-anchor" href="#OrdinaryDiffEqSDIRK">OrdinaryDiffEqSDIRK</a><a id="OrdinaryDiffEqSDIRK-1"></a><a class="docs-heading-anchor-permalink" href="#OrdinaryDiffEqSDIRK" title="Permalink"></a></h1><p>Singly Diagonally Implicit Runge-Kutta (SDIRK) methods are a family of implicit Runge-Kutta methods designed for solving stiff ordinary differential equations. These methods are particularly effective for problems where explicit methods become unstable due to stiffness.</p><h2 id="Key-Properties"><a class="docs-heading-anchor" href="#Key-Properties">Key Properties</a><a id="Key-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Properties" title="Permalink"></a></h2><p>SDIRK methods have several important characteristics:</p><ul><li><strong>A-stable and L-stable</strong>: Can handle highly stiff problems without numerical instability</li><li><strong>Stiffly accurate</strong>: Many SDIRK methods provide additional numerical stability for stiff problems</li><li><strong>Diagonally implicit structure</strong>: The implicit system only requires solving a sequence of nonlinear equations rather than a large coupled system</li><li><strong>Good for moderate to large systems</strong>: More efficient than fully implicit RK methods for many problems</li></ul><h2 id="When-to-Use-SDIRK-Methods"><a class="docs-heading-anchor" href="#When-to-Use-SDIRK-Methods">When to Use SDIRK Methods</a><a id="When-to-Use-SDIRK-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-SDIRK-Methods" title="Permalink"></a></h2><p>SDIRK methods are recommended for:</p><ul><li><strong>Stiff differential equations</strong> where explicit methods fail or require very small timesteps</li><li><strong>Problems requiring good stability properties</strong> at moderate to high tolerances</li><li><strong>Systems where Rosenbrock methods</strong> (which require Jacobians) are not suitable or available</li><li><strong>IMEX problems</strong> using the KenCarp family, which can split stiff and non-stiff terms</li></ul><h2 id="Solver-Selection-Guide"><a class="docs-heading-anchor" href="#Solver-Selection-Guide">Solver Selection Guide</a><a id="Solver-Selection-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-Selection-Guide" title="Permalink"></a></h2><h3 id="High-tolerance-(1e-2)"><a class="docs-heading-anchor" href="#High-tolerance-(1e-2)">High tolerance (&gt;1e-2)</a><a id="High-tolerance-(1e-2)-1"></a><a class="docs-heading-anchor-permalink" href="#High-tolerance-(1e-2)" title="Permalink"></a></h3><ul><li><strong><code>TRBDF2</code></strong>: Second-order A-B-L-S-stable method, good for oscillatory problems</li></ul><h3 id="Medium-tolerance-(1e-8-to-1e-2)"><a class="docs-heading-anchor" href="#Medium-tolerance-(1e-8-to-1e-2)">Medium tolerance (1e-8 to 1e-2)</a><a id="Medium-tolerance-(1e-8-to-1e-2)-1"></a><a class="docs-heading-anchor-permalink" href="#Medium-tolerance-(1e-8-to-1e-2)" title="Permalink"></a></h3><ul><li><strong><code>KenCarp4</code></strong>: Fourth-order method with excellent stability, good all-around choice</li><li><strong><code>KenCarp47</code></strong>: Seventh-stage fourth-order method, enhanced stability</li><li><strong><code>Kvaerno4</code></strong> or <strong><code>Kvaerno5</code></strong>: High-order stiffly accurate methods</li></ul><h3 id="Low-tolerance-(1e-8)"><a class="docs-heading-anchor" href="#Low-tolerance-(1e-8)">Low tolerance (&lt;1e-8)</a><a id="Low-tolerance-(1e-8)-1"></a><a class="docs-heading-anchor-permalink" href="#Low-tolerance-(1e-8)" title="Permalink"></a></h3><ul><li><strong><code>Kvaerno5</code></strong>: Fifth-order stiffly accurate method for high accuracy</li><li><strong><code>KenCarp5</code></strong>: Fifth-order method with splitting capabilities</li></ul><h3 id="Special-Cases"><a class="docs-heading-anchor" href="#Special-Cases">Special Cases</a><a id="Special-Cases-1"></a><a class="docs-heading-anchor-permalink" href="#Special-Cases" title="Permalink"></a></h3><ul><li><strong><code>ImplicitEuler</code></strong>: First-order method, only recommended for problems with discontinuities or when <code>f</code> is not differentiable</li><li><strong><code>Trapezoid</code></strong>: Second-order symmetric method, reversible but not symplectic. Good for eliminating damping often seen with L-stable methods</li><li><strong><code>ImplicitMidpoint</code></strong>: Second-order A-stable symplectic method for energy-preserving systems</li><li><strong><code>SSPSDIRK2</code></strong>: Strong stability preserving variant for problems requiring monotonicity preservation</li></ul><h2>Installation</h2><p>To be able to access the solvers in <code>OrdinaryDiffEqSDIRK</code>, you must first install them use the Julia package manager:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;OrdinaryDiffEqSDIRK&quot;)</code></pre><p>This will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.</p><h2>Example usage</h2><pre><code class="language-julia hljs">using OrdinaryDiffEqSDIRK

function lorenz!(du, u, p, t)
    du[1] = 10.0 * (u[2] - u[1])
    du[2] = u[1] * (28.0 - u[3]) - u[2]
    du[3] = u[1] * u[2] - (8 / 3) * u[3]
end
u0 = [1.0; 0.0; 0.0]
tspan = (0.0, 100.0)
prob = ODEProblem(lorenz!, u0, tspan)
sol = solve(prob, KenCarp4())</code></pre><h2 id="Full-list-of-solvers"><a class="docs-heading-anchor" href="#Full-list-of-solvers">Full list of solvers</a><a id="Full-list-of-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Full-list-of-solvers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.ImplicitEuler" href="#OrdinaryDiffEqSDIRK.ImplicitEuler"><code>OrdinaryDiffEqSDIRK.ImplicitEuler</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ImplicitEuler(; chunk_size = Val{0}(),
                autodiff = AutoForwardDiff(),
                standardtag = Val{true}(),
                concrete_jac = nothing,
                diff_type = Val{:forward}(),
                linsolve = nothing,
                precs = DEFAULT_PRECS,
                nlsolve = NLNewton(),
                extrapolant = :constant,
                controller = :PI,
                step_limiter! = trivial_limiter!)</code></pre><p>SDIRK Method. A 1st order implicit solver. A-B-L-stable. Adaptive timestepping through a divided differences estimate. Strong-stability preserving (SSP). Good for highly stiff equations.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ImplicitEuler(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>extrapolant</code>: TBD</li></ul></li><li><code>controller</code>: TBD</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><p>@book{wanner1996solving,     title={Solving ordinary differential equations II},     author={Wanner, Gerhard and Hairer, Ernst},     volume={375},     year={1996},     publisher={Springer Berlin Heidelberg New York}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L80-L163">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.ImplicitMidpoint" href="#OrdinaryDiffEqSDIRK.ImplicitMidpoint"><code>OrdinaryDiffEqSDIRK.ImplicitMidpoint</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ImplicitMidpoint(; chunk_size = Val{0}(),
                   autodiff = AutoForwardDiff(),
                   standardtag = Val{true}(),
                   concrete_jac = nothing,
                   diff_type = Val{:forward}(),
                   linsolve = nothing,
                   precs = DEFAULT_PRECS,
                   nlsolve = NLNewton(),
                   extrapolant = :linear,
                   step_limiter! = trivial_limiter!)</code></pre><p>SDIRK Method. A second order A-stable symplectic and symmetric implicit solver. Excellent for Hamiltonian systems and highly stiff equations.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ImplicitMidpoint(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>extrapolant</code>: TBD</li></ul></li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><p>@book{wanner1996solving,     title={Solving ordinary differential equations II},     author={Wanner, Gerhard and Hairer, Ernst},     volume={375},     year={1996},     publisher={Springer Berlin Heidelberg New York}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L123-L204">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.Trapezoid" href="#OrdinaryDiffEqSDIRK.Trapezoid"><code>OrdinaryDiffEqSDIRK.Trapezoid</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Trapezoid(; chunk_size = Val{0}(),
            autodiff = AutoForwardDiff(),
            standardtag = Val{true}(),
            concrete_jac = nothing,
            diff_type = Val{:forward}(),
            linsolve = nothing,
            precs = DEFAULT_PRECS,
            nlsolve = NLNewton(),
            extrapolant = :linear,
            controller = :PI,
            step_limiter! = trivial_limiter!)</code></pre><p>SDIRK Method. A second order A-stable symmetric ESDIRK method. &#39;Almost symplectic&#39; without numerical dampening.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Trapezoid(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>extrapolant</code>: TBD</li></ul></li><li><code>controller</code>: TBD</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><p>Andre Vladimirescu. 1994. The Spice Book. John Wiley &amp; Sons, Inc., New York, NY, USA.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L165-L243">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.TRBDF2" href="#OrdinaryDiffEqSDIRK.TRBDF2"><code>OrdinaryDiffEqSDIRK.TRBDF2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TRBDF2(; chunk_size = Val{0}(),
         autodiff = AutoForwardDiff(),
         standardtag = Val{true}(),
         concrete_jac = nothing,
         diff_type = Val{:forward}(),
         linsolve = nothing,
         precs = DEFAULT_PRECS,
         nlsolve = NLNewton(),
         smooth_est = true,
         extrapolant = :linear,
         controller = :PI,
         step_limiter! = trivial_limiter!)</code></pre><p>SDIRK Method. A second order A-B-L-S-stable one-step ESDIRK method. Includes stiffness-robust error estimates for accurate adaptive timestepping, smoothed derivatives for highly stiff and oscillatory problems. Good for high tolerances (&gt;1e-2) on stiff problems.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>TRBDF2(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>smooth_est</code>: TBD</li></ul></li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><p>@article{hosea1996analysis,     title={Analysis and implementation of TR-BDF2},     author={Hosea, ME and Shampine, LF},     journal={Applied Numerical Mathematics},     volume={20},     number={1-2},     pages={21–37},     year={1996},     publisher={Elsevier}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L209-L297">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.SDIRK2" href="#OrdinaryDiffEqSDIRK.SDIRK2"><code>OrdinaryDiffEqSDIRK.SDIRK2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDIRK2(; chunk_size = Val{0}(),
         autodiff = AutoForwardDiff(),
         standardtag = Val{true}(),
         concrete_jac = nothing,
         diff_type = Val{:forward}(),
         linsolve = nothing,
         precs = DEFAULT_PRECS,
         nlsolve = NLNewton(),
         smooth_est = true,
         extrapolant = :linear,
         controller = :PI,
         step_limiter! = trivial_limiter!)</code></pre><p>SDIRK Method. SDIRK2: SDIRK Method An A-B-L stable 2nd order SDIRK method</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>SDIRK2(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>smooth_est</code>: TBD</li></ul></li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><p>@article{hindmarsh2005sundials,     title={{SUNDIALS}: Suite of nonlinear and differential/algebraic equation solvers},     author={Hindmarsh, Alan C and Brown, Peter N and Grant, Keith E and Lee, Steven L and Serban, Radu and Shumaker, Dan E and Woodward, Carol S},     journal={ACM Transactions on Mathematical Software (TOMS)},     volume={31},     number={3},     pages={363–396},     year={2005},     publisher={ACM}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L260-L348">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.SDIRK22" href="#OrdinaryDiffEqSDIRK.SDIRK22"><code>OrdinaryDiffEqSDIRK.SDIRK22</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SDIRK22(; chunk_size = Val{0}(),
          autodiff = AutoForwardDiff(),
          standardtag = Val{true}(),
          concrete_jac = nothing,
          diff_type = Val{:forward}(),
          linsolve = nothing,
          precs = DEFAULT_PRECS,
          nlsolve = NLNewton(),
          smooth_est = true,
          extrapolant = :linear,
          controller = :PI,
          step_limiter! = trivial_limiter!)</code></pre><p>SDIRK Method. Description TBD</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>SDIRK22(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>smooth_est</code>: TBD</li></ul></li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><p>@techreport{kennedy2016diagonally,     title={Diagonally implicit Runge-Kutta methods for ordinary differential equations. A review},     author={Kennedy, Christopher A and Carpenter, Mark H},     year={2016}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L312-L395">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.SSPSDIRK2" href="#OrdinaryDiffEqSDIRK.SSPSDIRK2"><code>OrdinaryDiffEqSDIRK.SSPSDIRK2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SSPSDIRK2(; chunk_size = Val{0}(),
            autodiff = AutoForwardDiff(),
            standardtag = Val{true}(),
            concrete_jac = nothing,
            diff_type = Val{:forward}(),
            linsolve = nothing,
            precs = DEFAULT_PRECS,
            nlsolve = NLNewton(),
            smooth_est = true,
            extrapolant = :constant,
            controller = :PI)</code></pre><p>SDIRK Method. SSPSDIRK is an SSP-optimized SDIRK method, so it&#39;s an implicit SDIRK method for handling stiffness but if the <code>dt</code> is below the SSP <code>coefficient * dt</code>, then the SSP property of the SSP integrators (the other page) is satisified. As such this is a method which is expected to be good on advection-dominated cases where an explicit SSP integrator would be used, but where reaction equations are sufficient stiff to justify implicit integration.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>SSPSDIRK2(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>smooth_est</code>: TBD</li></ul></li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li></ul><p><strong>References</strong></p><p>@article{ketcheson2009optimal,     title={Optimal implicit strong stability preserving Runge–Kutta methods},     author={Ketcheson, David I and Macdonald, Colin B and Gottlieb, Sigal},     journal={Applied Numerical Mathematics},     volume={59},     number={2},     pages={373–392},     year={2009},     publisher={Elsevier}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L360-L450">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.Kvaerno3" href="#OrdinaryDiffEqSDIRK.Kvaerno3"><code>OrdinaryDiffEqSDIRK.Kvaerno3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Kvaerno3(; chunk_size = Val{0}(),
           autodiff = AutoForwardDiff(),
           standardtag = Val{true}(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           nlsolve = NLNewton(),
           smooth_est = true,
           extrapolant = :linear,
           controller = :PI,
           step_limiter! = trivial_limiter!)</code></pre><p>SDIRK Method. An A-L stable stiffly-accurate 3rd order ESDIRK method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Kvaerno3(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>smooth_est</code>: TBD</li></ul></li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><p>@article{kvaerno2004singly,     title={Singly diagonally implicit Runge–Kutta methods with an explicit first stage},     author={Kv{\ae}rn{\o}, Anne},     journal={BIT Numerical Mathematics},     volume={44},     number={3},     pages={489–502},     year={2004},     publisher={Springer}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L411-L499">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.KenCarp3" href="#OrdinaryDiffEqSDIRK.KenCarp3"><code>OrdinaryDiffEqSDIRK.KenCarp3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KenCarp3(; chunk_size = Val{0}(),
           autodiff = AutoForwardDiff(),
           standardtag = Val{true}(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           nlsolve = NLNewton(),
           smooth_est = true,
           extrapolant = :linear,
           controller = :PI,
           step_limiter! = trivial_limiter!)</code></pre><p>SDIRK Method. An A-L stable stiffly-accurate 3rd order ESDIRK method with splitting.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>KenCarp3(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>smooth_est</code>: TBD</li></ul></li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><p>@book{kennedy2001additive,     title={Additive Runge-Kutta schemes for convection-diffusion-reaction equations},     author={Kennedy, Christopher Alan},     year={2001},     publisher={National Aeronautics and Space Administration, Langley Research Center}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L459-L543">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.CFNLIRK3" href="#OrdinaryDiffEqSDIRK.CFNLIRK3"><code>OrdinaryDiffEqSDIRK.CFNLIRK3</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">CFNLIRK3(; chunk_size = Val{0}(),
           autodiff = AutoForwardDiff(),
           standardtag = Val{true}(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           nlsolve = NLNewton(),
           extrapolant = :linear)</code></pre><p>SDIRK Method. Third order method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>CFNLIRK3(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>extrapolant</code>: TBD</li></ul></li></ul><p><strong>References</strong></p><p>@article{calvo2001linearly,     title={Linearly implicit Runge–Kutta methods for advection–reaction–diffusion equations},     author={Calvo, MP and De Frutos, J and Novo, J},     journal={Applied Numerical Mathematics},     volume={37},     number={4},     pages={535–549},     year={2001},     publisher={Elsevier}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L504-L586">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.Cash4" href="#OrdinaryDiffEqSDIRK.Cash4"><code>OrdinaryDiffEqSDIRK.Cash4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Cash4(; chunk_size = Val{0}(),
        autodiff = AutoForwardDiff(),
        standardtag = Val{true}(),
        concrete_jac = nothing,
        diff_type = Val{:forward}(),
        linsolve = nothing,
        precs = DEFAULT_PRECS,
        nlsolve = NLNewton(),
        smooth_est = true,
        extrapolant = :linear,
        controller = :PI,
        embedding = 3)</code></pre><p>SDIRK Method. An A-L stable 4th order SDIRK method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Cash4(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>smooth_est</code>: TBD</li></ul></li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li><li><code>embedding</code>: TBD</li></ul><p><strong>References</strong></p><p>@article{hindmarsh2005sundials,     title={{SUNDIALS}: Suite of nonlinear and differential/algebraic equation solvers},     author={Hindmarsh, Alan C and Brown, Peter N and Grant, Keith E and Lee, Steven L and Serban, Radu and Shumaker, Dan E and Woodward, Carol S},     journal={ACM Transactions on Mathematical Software (TOMS)},     volume={31},     number={3},     pages={363–396},     year={2005},     publisher={ACM}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L545-L633">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.SFSDIRK4" href="#OrdinaryDiffEqSDIRK.SFSDIRK4"><code>OrdinaryDiffEqSDIRK.SFSDIRK4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SFSDIRK4(; chunk_size = Val{0}(),
           autodiff = AutoForwardDiff(),
           standardtag = Val{true}(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           nlsolve = NLNewton(),
           extrapolant = :linear)</code></pre><p>SDIRK Method. Method of order 4.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>SFSDIRK4(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>extrapolant</code>: TBD</li></ul></li></ul><p><strong>References</strong></p><p>@article{ferracina2008strong,     title={Strong stability of singly-diagonally-implicit Runge–Kutta methods},     author={Ferracina, Luca and Spijker, MN},     journal={Applied Numerical Mathematics},     volume={58},     number={11},     pages={1675–1686},     year={2008},     publisher={Elsevier}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L600-L682">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.SFSDIRK5" href="#OrdinaryDiffEqSDIRK.SFSDIRK5"><code>OrdinaryDiffEqSDIRK.SFSDIRK5</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SFSDIRK5(; chunk_size = Val{0}(),
           autodiff = AutoForwardDiff(),
           standardtag = Val{true}(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           nlsolve = NLNewton(),
           extrapolant = :linear)</code></pre><p>SDIRK Method. Method of order 5.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>SFSDIRK5(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>extrapolant</code>: TBD</li></ul></li></ul><p><strong>References</strong></p><p>@article{ferracina2008strong,     title={Strong stability of singly-diagonally-implicit Runge–Kutta methods},     author={Ferracina, Luca and Spijker, MN},     journal={Applied Numerical Mathematics},     volume={58},     number={11},     pages={1675–1686},     year={2008},     publisher={Elsevier}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L641-L723">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.SFSDIRK6" href="#OrdinaryDiffEqSDIRK.SFSDIRK6"><code>OrdinaryDiffEqSDIRK.SFSDIRK6</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SFSDIRK6(; chunk_size = Val{0}(),
           autodiff = AutoForwardDiff(),
           standardtag = Val{true}(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           nlsolve = NLNewton(),
           extrapolant = :linear)</code></pre><p>SDIRK Method. Method of order 6.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>SFSDIRK6(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>extrapolant</code>: TBD</li></ul></li></ul><p><strong>References</strong></p><p>@article{ferracina2008strong,     title={Strong stability of singly-diagonally-implicit Runge–Kutta methods},     author={Ferracina, Luca and Spijker, MN},     journal={Applied Numerical Mathematics},     volume={58},     number={11},     pages={1675–1686},     year={2008},     publisher={Elsevier}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L683-L765">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.SFSDIRK7" href="#OrdinaryDiffEqSDIRK.SFSDIRK7"><code>OrdinaryDiffEqSDIRK.SFSDIRK7</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SFSDIRK7(; chunk_size = Val{0}(),
           autodiff = AutoForwardDiff(),
           standardtag = Val{true}(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           nlsolve = NLNewton(),
           extrapolant = :linear)</code></pre><p>SDIRK Method. Method of order 7.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>SFSDIRK7(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>extrapolant</code>: TBD</li></ul></li></ul><p><strong>References</strong></p><p>@article{ferracina2008strong,     title={Strong stability of singly-diagonally-implicit Runge–Kutta methods},     author={Ferracina, Luca and Spijker, MN},     journal={Applied Numerical Mathematics},     volume={58},     number={11},     pages={1675–1686},     year={2008},     publisher={Elsevier}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L725-L807">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.SFSDIRK8" href="#OrdinaryDiffEqSDIRK.SFSDIRK8"><code>OrdinaryDiffEqSDIRK.SFSDIRK8</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">SFSDIRK8(; chunk_size = Val{0}(),
           autodiff = AutoForwardDiff(),
           standardtag = Val{true}(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           nlsolve = NLNewton(),
           extrapolant = :linear)</code></pre><p>SDIRK Method. Method of order 8.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>SFSDIRK8(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>extrapolant</code>: TBD</li></ul></li></ul><p><strong>References</strong></p><p>@article{ferracina2008strong,     title={Strong stability of singly-diagonally-implicit Runge–Kutta methods},     author={Ferracina, Luca and Spijker, MN},     journal={Applied Numerical Mathematics},     volume={58},     number={11},     pages={1675–1686},     year={2008},     publisher={Elsevier}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L767-L849">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.Hairer4" href="#OrdinaryDiffEqSDIRK.Hairer4"><code>OrdinaryDiffEqSDIRK.Hairer4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hairer4(; chunk_size = Val{0}(),
          autodiff = AutoForwardDiff(),
          standardtag = Val{true}(),
          concrete_jac = nothing,
          diff_type = Val{:forward}(),
          linsolve = nothing,
          precs = DEFAULT_PRECS,
          nlsolve = NLNewton(),
          smooth_est = true,
          extrapolant = :linear,
          controller = :PI)</code></pre><p>SDIRK Method. An A-L stable 4th order SDIRK method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Hairer4(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>smooth_est</code>: TBD</li></ul></li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li></ul><p><strong>References</strong></p><p>E. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and     differential-algebraic problems. Computational mathematics (2nd revised ed.),     Springer (1996)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L809-L889">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.Hairer42" href="#OrdinaryDiffEqSDIRK.Hairer42"><code>OrdinaryDiffEqSDIRK.Hairer42</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Hairer42(; chunk_size = Val{0}(),
           autodiff = AutoForwardDiff(),
           standardtag = Val{true}(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           nlsolve = NLNewton(),
           smooth_est = true,
           extrapolant = :linear,
           controller = :PI)</code></pre><p>SDIRK Method. An A-L stable 4th order SDIRK method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Hairer42(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>smooth_est</code>: TBD</li></ul></li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li></ul><p><strong>References</strong></p><p>E. Hairer, G. Wanner, Solving ordinary differential equations II, stiff and     differential-algebraic problems. Computational mathematics (2nd revised ed.),     Springer (1996)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L848-L928">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.Kvaerno4" href="#OrdinaryDiffEqSDIRK.Kvaerno4"><code>OrdinaryDiffEqSDIRK.Kvaerno4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Kvaerno4(; chunk_size = Val{0}(),
           autodiff = AutoForwardDiff(),
           standardtag = Val{true}(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           nlsolve = NLNewton(),
           smooth_est = true,
           extrapolant = :linear,
           controller = :PI,
           step_limiter! = trivial_limiter!)</code></pre><p>SDIRK Method. An A-L stable stiffly-accurate 4th order ESDIRK method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Kvaerno4(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>smooth_est</code>: TBD</li></ul></li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li><li><code>step_limiter</code>: TBD</li></ul><p><strong>References</strong></p><p>@article{kvaerno2004singly,     title={Singly diagonally implicit Runge–Kutta methods with an explicit first stage},     author={Kv{\ae}rn{\o}, Anne},     journal={BIT Numerical Mathematics},     volume={44},     number={3},     pages={489–502},     year={2004},     publisher={Springer}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L887-L975">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.Kvaerno5" href="#OrdinaryDiffEqSDIRK.Kvaerno5"><code>OrdinaryDiffEqSDIRK.Kvaerno5</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">Kvaerno5(; chunk_size = Val{0}(),
           autodiff = AutoForwardDiff(),
           standardtag = Val{true}(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           nlsolve = NLNewton(),
           smooth_est = true,
           extrapolant = :linear,
           controller = :PI,
           step_limiter! = trivial_limiter!)</code></pre><p>SDIRK Method. An A-L stable stiffly-accurate 5th order ESDIRK method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>Kvaerno5(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>smooth_est</code>: TBD</li></ul></li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li><li><code>step_limiter</code>: TBD</li></ul><p><strong>References</strong></p><p>@article{kvaerno2004singly,     title={Singly diagonally implicit Runge–Kutta methods with an explicit first stage},     author={Kv{\ae}rn{\o}, Anne},     journal={BIT Numerical Mathematics},     volume={44},     number={3},     pages={489–502},     year={2004},     publisher={Springer}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L935-L1023">source</a></section></article><h3 id="IMEX-SDIRK"><a class="docs-heading-anchor" href="#IMEX-SDIRK">IMEX SDIRK</a><a id="IMEX-SDIRK-1"></a><a class="docs-heading-anchor-permalink" href="#IMEX-SDIRK" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.KenCarp4" href="#OrdinaryDiffEqSDIRK.KenCarp4"><code>OrdinaryDiffEqSDIRK.KenCarp4</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KenCarp4(; chunk_size = Val{0}(),
           autodiff = AutoForwardDiff(),
           standardtag = Val{true}(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           nlsolve = NLNewton(),
           smooth_est = true,
           extrapolant = :linear,
           controller = :PI,
           step_limiter! = trivial_limiter!)</code></pre><p>SDIRK Method. An A-L stable stiffly-accurate 4th order ESDIRK method with splitting. Includes splitting capabilities. Recommended for medium tolerance stiff problems (&gt;1e-8).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>KenCarp4(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>smooth_est</code>: TBD</li></ul></li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li><li><code>step_limiter</code>: TBD</li></ul><p><strong>References</strong></p><p>@book{kennedy2001additive,     title={Additive Runge-Kutta schemes for convection-diffusion-reaction equations},     author={Kennedy, Christopher Alan},     year={2001},     publisher={National Aeronautics and Space Administration, Langley Research Center}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L983-L1067">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.KenCarp47" href="#OrdinaryDiffEqSDIRK.KenCarp47"><code>OrdinaryDiffEqSDIRK.KenCarp47</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KenCarp47(; chunk_size = Val{0}(),
            autodiff = AutoForwardDiff(),
            standardtag = Val{true}(),
            concrete_jac = nothing,
            diff_type = Val{:forward}(),
            linsolve = nothing,
            precs = DEFAULT_PRECS,
            nlsolve = NLNewton(),
            smooth_est = true,
            extrapolant = :linear,
            controller = :PI)</code></pre><p>SDIRK Method. An A-L stable stiffly-accurate 4th order seven-stage ESDIRK method with splitting.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>KenCarp47(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>smooth_est</code>: TBD</li></ul></li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li></ul><p><strong>References</strong></p><p>@article{kennedy2019higher,     title={Higher-order additive Runge–Kutta schemes for ordinary differential equations},     author={Kennedy, Christopher A and Carpenter, Mark H},     journal={Applied Numerical Mathematics},     volume={136},     pages={183–205},     year={2019},     publisher={Elsevier}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L1030-L1115">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.KenCarp5" href="#OrdinaryDiffEqSDIRK.KenCarp5"><code>OrdinaryDiffEqSDIRK.KenCarp5</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KenCarp5(; chunk_size = Val{0}(),
           autodiff = AutoForwardDiff(),
           standardtag = Val{true}(),
           concrete_jac = nothing,
           diff_type = Val{:forward}(),
           linsolve = nothing,
           precs = DEFAULT_PRECS,
           nlsolve = NLNewton(),
           smooth_est = true,
           extrapolant = :linear,
           controller = :PI,
           step_limiter! = trivial_limiter!)</code></pre><p>SDIRK Method. An A-L stable stiffly-accurate 5th order ESDIRK method with splitting.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>KenCarp5(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>smooth_est</code>: TBD</li></ul></li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li><li><code>step_limiter</code>: TBD</li></ul><p><strong>References</strong></p><p>@book{kennedy2001additive,     title={Additive Runge-Kutta schemes for convection-diffusion-reaction equations},     author={Kennedy, Christopher Alan},     year={2001},     publisher={National Aeronautics and Space Administration, Langley Research Center}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L1075-L1159">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.KenCarp58" href="#OrdinaryDiffEqSDIRK.KenCarp58"><code>OrdinaryDiffEqSDIRK.KenCarp58</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">KenCarp58(; chunk_size = Val{0}(),
            autodiff = AutoForwardDiff(),
            standardtag = Val{true}(),
            concrete_jac = nothing,
            diff_type = Val{:forward}(),
            linsolve = nothing,
            precs = DEFAULT_PRECS,
            nlsolve = NLNewton(),
            smooth_est = true,
            extrapolant = :linear,
            controller = :PI)</code></pre><p>SDIRK Method. An A-L stable stiffly-accurate 5th order eight-stage ESDIRK method with splitting.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>KenCarp58(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>smooth_est</code>: TBD</li></ul></li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li></ul><p><strong>References</strong></p><p>@article{kennedy2019higher,     title={Higher-order additive Runge–Kutta schemes for ordinary differential equations},     author={Kennedy, Christopher A and Carpenter, Mark H},     journal={Applied Numerical Mathematics},     volume={136},     pages={183–205},     year={2019},     publisher={Elsevier}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L1120-L1205">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.ESDIRK54I8L2SA" href="#OrdinaryDiffEqSDIRK.ESDIRK54I8L2SA"><code>OrdinaryDiffEqSDIRK.ESDIRK54I8L2SA</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ESDIRK54I8L2SA(; chunk_size = Val{0}(),
                 autodiff = AutoForwardDiff(),
                 standardtag = Val{true}(),
                 concrete_jac = nothing,
                 diff_type = Val{:forward}(),
                 linsolve = nothing,
                 precs = DEFAULT_PRECS,
                 nlsolve = NLNewton(),
                 extrapolant = :linear,
                 controller = :PI)</code></pre><p>SDIRK Method. Optimized ESDIRK tableaus. Updates of the original KenCarp tableau expected to achieve lower error for the same steps in theory, but are still being fully evaluated in context.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ESDIRK54I8L2SA(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>extrapolant</code>: TBD</li></ul></li><li><code>controller</code>: TBD</li></ul><p><strong>References</strong></p><p>@article{Kennedy2019DiagonallyIR, title={Diagonally implicit Runge–Kutta methods for stiff ODEs}, author={Christopher A. Kennedy and Mark H. Carpenter}, journal={Applied Numerical Mathematics}, year={2019}, volume={146}, pages={221-244} }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L1166-L1251">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.ESDIRK436L2SA2" href="#OrdinaryDiffEqSDIRK.ESDIRK436L2SA2"><code>OrdinaryDiffEqSDIRK.ESDIRK436L2SA2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ESDIRK436L2SA2(; chunk_size = Val{0}(),
                 autodiff = AutoForwardDiff(),
                 standardtag = Val{true}(),
                 concrete_jac = nothing,
                 diff_type = Val{:forward}(),
                 linsolve = nothing,
                 precs = DEFAULT_PRECS,
                 nlsolve = NLNewton(),
                 extrapolant = :linear,
                 controller = :PI)</code></pre><p>SDIRK Method. Optimized ESDIRK tableaus. Updates of the original KenCarp tableau expected to achieve lower error for the same steps in theory, but are still being fully evaluated in context.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ESDIRK436L2SA2(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>extrapolant</code>: TBD</li></ul></li><li><code>controller</code>: TBD</li></ul><p><strong>References</strong></p><p>@article{Kennedy2019DiagonallyIR, title={Diagonally implicit Runge–Kutta methods for stiff ODEs}, author={Christopher A. Kennedy and Mark H. Carpenter}, journal={Applied Numerical Mathematics}, year={2019}, volume={146}, pages={221-244} }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L1209-L1294">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.ESDIRK437L2SA" href="#OrdinaryDiffEqSDIRK.ESDIRK437L2SA"><code>OrdinaryDiffEqSDIRK.ESDIRK437L2SA</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ESDIRK437L2SA(; chunk_size = Val{0}(),
                autodiff = AutoForwardDiff(),
                standardtag = Val{true}(),
                concrete_jac = nothing,
                diff_type = Val{:forward}(),
                linsolve = nothing,
                precs = DEFAULT_PRECS,
                nlsolve = NLNewton(),
                extrapolant = :linear,
                controller = :PI)</code></pre><p>SDIRK Method. Optimized ESDIRK tableaus. Updates of the original KenCarp tableau expected to achieve lower error for the same steps in theory, but are still being fully evaluated in context.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ESDIRK437L2SA(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>extrapolant</code>: TBD</li></ul></li><li><code>controller</code>: TBD</li></ul><p><strong>References</strong></p><p>@article{Kennedy2019DiagonallyIR, title={Diagonally implicit Runge–Kutta methods for stiff ODEs}, author={Christopher A. Kennedy and Mark H. Carpenter}, journal={Applied Numerical Mathematics}, year={2019}, volume={146}, pages={221-244} }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L1252-L1337">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.ESDIRK547L2SA2" href="#OrdinaryDiffEqSDIRK.ESDIRK547L2SA2"><code>OrdinaryDiffEqSDIRK.ESDIRK547L2SA2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ESDIRK547L2SA2(; chunk_size = Val{0}(),
                 autodiff = AutoForwardDiff(),
                 standardtag = Val{true}(),
                 concrete_jac = nothing,
                 diff_type = Val{:forward}(),
                 linsolve = nothing,
                 precs = DEFAULT_PRECS,
                 nlsolve = NLNewton(),
                 extrapolant = :linear,
                 controller = :PI)</code></pre><p>SDIRK Method. Optimized ESDIRK tableaus. Updates of the original KenCarp tableau expected to achieve lower error for the same steps in theory, but are still being fully evaluated in context.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ESDIRK547L2SA2(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>extrapolant</code>: TBD</li></ul></li><li><code>controller</code>: TBD</li></ul><p><strong>References</strong></p><p>@article{Kennedy2019DiagonallyIR, title={Diagonally implicit Runge–Kutta methods for stiff ODEs}, author={Christopher A. Kennedy and Mark H. Carpenter}, journal={Applied Numerical Mathematics}, year={2019}, volume={146}, pages={221-244} }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L1295-L1380">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqSDIRK.ESDIRK659L2SA" href="#OrdinaryDiffEqSDIRK.ESDIRK659L2SA"><code>OrdinaryDiffEqSDIRK.ESDIRK659L2SA</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ESDIRK659L2SA(; chunk_size = Val{0}(),
                autodiff = AutoForwardDiff(),
                standardtag = Val{true}(),
                concrete_jac = nothing,
                diff_type = Val{:forward}(),
                linsolve = nothing,
                precs = DEFAULT_PRECS,
                nlsolve = NLNewton(),
                extrapolant = :linear,
                controller = :PI)</code></pre><p>SDIRK Method. Optimized ESDIRK tableaus. Updates of the original KenCarp tableau expected to achieve lower error for the same steps in theory, but are still being fully evaluated in context. Currently has STABILITY ISSUES, causing it to fail the adaptive tests. Check issue https://github.com/SciML/OrdinaryDiffEq.jl/issues/1933 for more details.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ESDIRK659L2SA(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre></li><li><code>nlsolve</code>: TBD<ul><li><code>extrapolant</code>: TBD</li></ul></li><li><code>controller</code>: TBD</li></ul><p><strong>References</strong></p><p>@article{Kennedy2019DiagonallyIR, title={Diagonally implicit Runge–Kutta methods for stiff ODEs}, author={Christopher A. Kennedy and Mark H. Carpenter}, journal={Applied Numerical Mathematics}, year={2019}, volume={146}, pages={221-244} }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/136a305fb73920a4756e09cc7b14eeb42311a98c/lib/OrdinaryDiffEqSDIRK/src/algorithms.jl#L1338-L1425">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../semiimplicit/ExponentialRK/">« OrdinaryDiffEqExponentialRK</a><a class="docs-footer-nextpage" href="../FIRK/">OrdinaryDiffEqFIRK »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Friday 1 August 2025 20:36">Friday 1 August 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
