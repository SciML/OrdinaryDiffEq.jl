<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>OrdinaryDiffEqBDF · OrdinaryDiffEq.jl</title><meta name="title" content="OrdinaryDiffEqBDF · OrdinaryDiffEq.jl"/><meta property="og:title" content="OrdinaryDiffEqBDF · OrdinaryDiffEq.jl"/><meta property="twitter:title" content="OrdinaryDiffEqBDF · OrdinaryDiffEq.jl"/><meta name="description" content="Documentation for OrdinaryDiffEq.jl."/><meta property="og:description" content="Documentation for OrdinaryDiffEq.jl."/><meta property="twitter:description" content="Documentation for OrdinaryDiffEq.jl."/><meta property="og:url" content="https://ordinarydiffeq.sciml.ai/stable/massmatrixdae/BDF/"/><meta property="twitter:url" content="https://ordinarydiffeq.sciml.ai/stable/massmatrixdae/BDF/"/><link rel="canonical" href="https://ordinarydiffeq.sciml.ai/stable/massmatrixdae/BDF/"/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-90474609-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-90474609-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="OrdinaryDiffEq.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">OrdinaryDiffEq.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">OrdinaryDiffEq.jl: ODE solvers and utilities</a></li><li><a class="tocitem" href="../../usage/">Usage</a></li><li><span class="tocitem">Explicit Solvers</span><ul><li><a class="tocitem" href="../../explicit/Tsit5/">OrdinaryDiffEqTsit5</a></li><li><a class="tocitem" href="../../explicit/Verner/">OrdinaryDiffEqVerner</a></li><li><a class="tocitem" href="../../explicit/AdamsBashforthMoulton/">OrdinaryDiffEqAdamsBashforthMoulton</a></li><li><a class="tocitem" href="../../explicit/LowStorageRK/">OrdinaryDiffEqLowStorageRK</a></li><li><a class="tocitem" href="../../explicit/SSPRK/">OrdinaryDiffEqSSPRK</a></li><li><a class="tocitem" href="../../explicit/LowOrderRK/">OrdinaryDiffEqLowOrderRK</a></li><li><a class="tocitem" href="../../explicit/HighOrderRK/">OrdinaryDiffEqHighOrderRK</a></li><li><a class="tocitem" href="../../explicit/Feagin/">OrdinaryDiffEqFeagin</a></li><li><a class="tocitem" href="../../explicit/PRK/">OrdinaryDiffEqPRK</a></li><li><a class="tocitem" href="../../explicit/QPRK/">OrdinaryDiffEqQPRK</a></li><li><a class="tocitem" href="../../explicit/TaylorSeries/">OrdinaryDiffEqTaylorSeries</a></li><li><a class="tocitem" href="../../explicit/Extrapolation/">OrdinaryDiffEqExtrapolation</a></li></ul></li><li><span class="tocitem">Semi-Implicit Solvers</span><ul><li><a class="tocitem" href="../../semiimplicit/Rosenbrock/">OrdinaryDiffEqRosenbrock</a></li><li><a class="tocitem" href="../../semiimplicit/StabilizedRK/">OrdinaryDiffEqStabilizedRK</a></li><li><a class="tocitem" href="../../semiimplicit/ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li></ul></li><li><span class="tocitem">Implicit Solvers</span><ul><li><a class="tocitem" href="../../implicit/SDIRK/">OrdinaryDiffEqSDIRK</a></li><li><a class="tocitem" href="../../implicit/FIRK/">OrdinaryDiffEqFIRK</a></li><li><a class="tocitem" href="../../implicit/BDF/">OrdinaryDiffEqBDF</a></li><li><a class="tocitem" href="../../implicit/Extrapolation/">OrdinaryDiffEqExtrapolation</a></li><li><a class="tocitem" href="../../implicit/PDIRK/">OrdinaryDiffEqPDIRK</a></li><li><a class="tocitem" href="../../implicit/Nordsieck/">OrdinaryDiffEqNordsieck</a></li></ul></li><li><span class="tocitem">IMEX Solvers</span><ul><li><a class="tocitem" href="../../imex/IMEXMultistep/">OrdinaryDiffEqIMEXMultistep</a></li><li><a class="tocitem" href="../../imex/StabilizedIRK/">OrdinaryDiffEqStabilizedIRK</a></li><li><a class="tocitem" href="../../imex/IMEXBDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><span class="tocitem">Dynamical ODE Explicit Solvers</span><ul><li><a class="tocitem" href="../../dynamicalodeexplicit/RKN/">OrdinaryDiffEqRKN</a></li><li><a class="tocitem" href="../../dynamicalodeexplicit/SymplecticRK/">OrdinaryDiffEqSymplecticRK</a></li></ul></li><li><span class="tocitem">Semilinear ODE Solvers</span><ul><li><a class="tocitem" href="../../semilinear/ExponentialRK/">OrdinaryDiffEqExponentialRK</a></li><li><a class="tocitem" href="../../semilinear/Linear/">OrdinaryDiffEqLinear</a></li></ul></li><li><span class="tocitem">Mass Matrix DAE Solvers</span><ul><li><a class="tocitem" href="../Rosenbrock/">OrdinaryDiffEqRosenbrock</a></li><li class="is-active"><a class="tocitem" href>OrdinaryDiffEqBDF</a><ul class="internal"><li><a class="tocitem" href="#Key-Properties"><span>Key Properties</span></a></li><li><a class="tocitem" href="#When-to-Use-Mass-Matrix-BDF-Methods"><span>When to Use Mass Matrix BDF Methods</span></a></li><li><a class="tocitem" href="#Mathematical-Background"><span>Mathematical Background</span></a></li><li><a class="tocitem" href="#Problem-Formulation"><span>Problem Formulation</span></a></li><li><a class="tocitem" href="#Solver-Selection-Guide"><span>Solver Selection Guide</span></a></li><li><a class="tocitem" href="#Performance-Guidelines"><span>Performance Guidelines</span></a></li><li><a class="tocitem" href="#Important-Considerations"><span>Important Considerations</span></a></li><li><a class="tocitem" href="#Alternative-Approaches"><span>Alternative Approaches</span></a></li><li><a class="tocitem" href="#Full-list-of-solvers"><span>Full list of solvers</span></a></li></ul></li></ul></li><li><span class="tocitem">Fully Implicit DAE Solvers</span><ul><li><a class="tocitem" href="../../fullyimplicitdae/BDF/">OrdinaryDiffEqBDF</a></li></ul></li><li><span class="tocitem">Misc Solvers</span><ul><li><a class="tocitem" href="../../misc/">Miscellaneous Solvers</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Mass Matrix DAE Solvers</a></li><li class="is-active"><a href>OrdinaryDiffEqBDF</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>OrdinaryDiffEqBDF</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/SciML/OrdinaryDiffEq.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/master/docs/src/massmatrixdae/BDF.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="OrdinaryDiffEqBDF"><a class="docs-heading-anchor" href="#OrdinaryDiffEqBDF">OrdinaryDiffEqBDF</a><a id="OrdinaryDiffEqBDF-1"></a><a class="docs-heading-anchor-permalink" href="#OrdinaryDiffEqBDF" title="Permalink"></a></h1><p>BDF (Backward Differentiation Formula) methods for mass matrix differential-algebraic equations (DAEs) and stiff ODEs with singular mass matrices. These methods provide robust, high-order integration for systems with algebraic constraints and mixed differential-algebraic structure.</p><h2 id="Key-Properties"><a class="docs-heading-anchor" href="#Key-Properties">Key Properties</a><a id="Key-Properties-1"></a><a class="docs-heading-anchor-permalink" href="#Key-Properties" title="Permalink"></a></h2><p>Mass matrix BDF methods provide:</p><ul><li><strong>DAE capability</strong> for index-1 differential-algebraic equations</li><li><strong>Mass matrix support</strong> for singular and non-diagonal mass matrices</li><li><strong>High-order accuracy</strong> up to 5th order with good stability</li><li><strong>L-stable behavior</strong> for stiff problems with excellent damping</li><li><strong>Automatic differentiation</strong> for efficient Jacobian computation</li><li><strong>Variable order and stepsize</strong> adaptation for efficiency</li></ul><h2 id="When-to-Use-Mass-Matrix-BDF-Methods"><a class="docs-heading-anchor" href="#When-to-Use-Mass-Matrix-BDF-Methods">When to Use Mass Matrix BDF Methods</a><a id="When-to-Use-Mass-Matrix-BDF-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#When-to-Use-Mass-Matrix-BDF-Methods" title="Permalink"></a></h2><p>These methods are recommended for:</p><ul><li><strong>Differential-algebraic equations (DAEs)</strong> with index-1 structure</li><li><strong>Constrained mechanical systems</strong> with holonomic constraints</li><li><strong>Electrical circuit simulation</strong> with algebraic loop equations</li><li><strong>Chemical reaction networks</strong> with conservation constraints</li><li><strong>Multibody dynamics</strong> with kinematic constraints</li><li><strong>Semi-explicit DAEs</strong> arising from spatial discretizations</li></ul><h2 id="Mathematical-Background"><a class="docs-heading-anchor" href="#Mathematical-Background">Mathematical Background</a><a id="Mathematical-Background-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematical-Background" title="Permalink"></a></h2><p>Mass matrix DAEs have the form: <code>M du/dt = f(u,t)</code></p><p>where M is a potentially singular mass matrix. When M is singular, some equations become algebraic constraints rather than differential equations, leading to a DAE system.</p><h2 id="Problem-Formulation"><a class="docs-heading-anchor" href="#Problem-Formulation">Problem Formulation</a><a id="Problem-Formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Problem-Formulation" title="Permalink"></a></h2><p>Use <code>ODEFunction</code> with a <code>mass_matrix</code>:</p><pre><code class="language-julia hljs">using LinearAlgebra: Diagonal
function rober(du, u, p, t)
    y₁, y₂, y₃ = u
    k₁, k₂, k₃ = p
    du[1] = -k₁ * y₁ + k₃ * y₂ * y₃
    du[2] = k₁ * y₁ - k₃ * y₂ * y₃ - k₂ * y₂^2
    du[3] = y₁ + y₂ + y₃ - 1
    nothing
end
M = Diagonal([1.0, 1.0, 0])  # Singular mass matrix
f = ODEFunction(rober, mass_matrix = M)
prob_mm = ODEProblem(f, [1.0, 0.0, 0.0], (0.0, 1e5), (0.04, 3e7, 1e4))
sol = solve(prob_mm, FBDF(), reltol = 1e-8, abstol = 1e-8)</code></pre><h2 id="Solver-Selection-Guide"><a class="docs-heading-anchor" href="#Solver-Selection-Guide">Solver Selection Guide</a><a id="Solver-Selection-Guide-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-Selection-Guide" title="Permalink"></a></h2><h3 id="Recommended-Methods"><a class="docs-heading-anchor" href="#Recommended-Methods">Recommended Methods</a><a id="Recommended-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Recommended-Methods" title="Permalink"></a></h3><ul><li><strong><code>FBDF</code></strong>: <strong>Recommended</strong> - Fixed leading coefficient BDF with excellent stability</li><li><strong><code>QNDF</code></strong>: Quasi-constant stepsize Nordsieck BDF with good efficiency</li><li><strong><code>QBDF</code></strong>: Alternative quasi-constant stepsize BDF formulation</li></ul><h3 id="Specific-order-methods"><a class="docs-heading-anchor" href="#Specific-order-methods">Specific order methods</a><a id="Specific-order-methods-1"></a><a class="docs-heading-anchor-permalink" href="#Specific-order-methods" title="Permalink"></a></h3><ul><li><strong><code>QNDF1</code></strong>: First-order method for simple problems</li><li><strong><code>QNDF2</code></strong>: Second-order method balancing accuracy and stability</li><li><strong><code>QBDF1</code></strong>, <strong><code>QBDF2</code></strong>: Alternative second-order formulations</li><li><strong><code>ABDF2</code></strong>: Adams-type BDF for specific applications</li><li><strong><code>MEBDF2</code></strong>: Modified extended BDF for enhanced stability</li></ul><h2 id="Performance-Guidelines"><a class="docs-heading-anchor" href="#Performance-Guidelines">Performance Guidelines</a><a id="Performance-Guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Performance-Guidelines" title="Permalink"></a></h2><h3 id="When-mass-matrix-BDF-methods-excel"><a class="docs-heading-anchor" href="#When-mass-matrix-BDF-methods-excel">When mass matrix BDF methods excel</a><a id="When-mass-matrix-BDF-methods-excel-1"></a><a class="docs-heading-anchor-permalink" href="#When-mass-matrix-BDF-methods-excel" title="Permalink"></a></h3><ul><li><strong>Index-1 DAE systems</strong> with well-separated differential and algebraic variables</li><li><strong>Large stiff systems</strong> with algebraic constraints</li><li><strong>Problems with conservation laws</strong> naturally expressed as constraints</li><li><strong>Multiphysics simulations</strong> combining differential and algebraic equations</li><li><strong>Systems where constraints are essential</strong> to the physics</li></ul><h3 id="Mass-matrix-considerations"><a class="docs-heading-anchor" href="#Mass-matrix-considerations">Mass matrix considerations</a><a id="Mass-matrix-considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Mass-matrix-considerations" title="Permalink"></a></h3><ul><li><strong>Singular mass matrices</strong> require consistent initial conditions</li><li><strong>Index determination</strong> affects solver performance and stability</li><li><strong>Constraint violations</strong> may accumulate and require projection</li><li><strong>Well-conditioned problems</strong> generally perform better</li></ul><h2 id="Important-Considerations"><a class="docs-heading-anchor" href="#Important-Considerations">Important Considerations</a><a id="Important-Considerations-1"></a><a class="docs-heading-anchor-permalink" href="#Important-Considerations" title="Permalink"></a></h2><h3 id="Initial-conditions"><a class="docs-heading-anchor" href="#Initial-conditions">Initial conditions</a><a id="Initial-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Initial-conditions" title="Permalink"></a></h3><ul><li><strong>Must be consistent</strong> with algebraic constraints</li><li><strong>Use initialization procedures</strong> if constraints are not satisfied initially</li><li><strong>Index-1 assumption</strong> requires that constraints uniquely determine algebraic variables</li></ul><h3 id="Numerical-challenges"><a class="docs-heading-anchor" href="#Numerical-challenges">Numerical challenges</a><a id="Numerical-challenges-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-challenges" title="Permalink"></a></h3><ul><li><strong>Constraint drift</strong> may occur over long integrations</li><li><strong>Index higher than 1</strong> not directly supported</li><li><strong>Ill-conditioned mass matrices</strong> can cause numerical difficulties</li><li><strong>Discontinuities</strong> in constraints require special handling</li></ul><h2 id="Alternative-Approaches"><a class="docs-heading-anchor" href="#Alternative-Approaches">Alternative Approaches</a><a id="Alternative-Approaches-1"></a><a class="docs-heading-anchor-permalink" href="#Alternative-Approaches" title="Permalink"></a></h2><p>Consider these alternatives:</p><ul><li><strong>Implicit Runge-Kutta methods</strong> for higher accuracy requirements</li><li><strong>Rosenbrock methods</strong> for moderately stiff DAEs</li><li><strong>Projection methods</strong> for constraint preservation</li><li><strong>Index reduction techniques</strong> for higher-index DAEs</li></ul><h2>Installation</h2><p>To be able to access the solvers in <code>OrdinaryDiffEqBDF</code>, you must first install them use the Julia package manager:</p><pre><code class="language-julia hljs">using Pkg
Pkg.add(&quot;OrdinaryDiffEqBDF&quot;)</code></pre><p>This will only install the solvers listed at the bottom of this page. If you want to explore other solvers for your problem, you will need to install some of the other libraries listed in the navigation bar on the left.</p><h2>Example usage</h2><pre><code class="language-julia hljs">using OrdinaryDiffEqBDF

function lorenz!(du, u, p, t)
    du[1] = 10.0 * (u[2] - u[1])
    du[2] = u[1] * (28.0 - u[3]) - u[2]
    du[3] = u[1] * u[2] - (8 / 3) * u[3]
end
u0 = [1.0; 0.0; 0.0]
tspan = (0.0, 100.0)
prob = ODEProblem(lorenz!, u0, tspan)
sol = solve(prob, FBDF())</code></pre><h2 id="Full-list-of-solvers"><a class="docs-heading-anchor" href="#Full-list-of-solvers">Full list of solvers</a><a id="Full-list-of-solvers-1"></a><a class="docs-heading-anchor-permalink" href="#Full-list-of-solvers" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqBDF.ABDF2-massmatrixdae-BDF" href="#OrdinaryDiffEqBDF.ABDF2-massmatrixdae-BDF"><code>OrdinaryDiffEqBDF.ABDF2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ABDF2(; chunk_size = Val{0}(),
        autodiff = AutoForwardDiff(),
        standardtag = Val{true}(),
        concrete_jac = nothing,
        linsolve = nothing,
        precs = DEFAULT_PRECS,
        κ = nothing,
        tol = nothing,
        nlsolve = NLNewton(),
        smooth_est = true,
        extrapolant = :linear,
        controller = :Standard,
        step_limiter! = trivial_limiter!)</code></pre><p>Multistep Method. An adaptive order 2 L-stable fixed leading coefficient multistep BDF method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>ABDF2(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre>/n- <code>κ</code>: TBD</li><li><code>tol</code>: TBD</li><li><code>nlsolve</code>: TBD</li><li><code>smooth_est</code>: TBD</li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><p>E. Alberdi Celayaa, J. J. Anza Aguirrezabalab, P. Chatzipantelidisc. Implementation of an Adaptive BDF2 Formula and Comparison with The MATLAB Ode15s. Procedia Computer Science, 29, pp 1014-1026, 2014. doi: https://doi.org/10.1016/j.procs.2014.05.091</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/8a1baf238db417f7d25478ecdee55151bd4816a8/lib/OrdinaryDiffEqBDF/src/algorithms.jl#L76-L162">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqBDF.QNDF-massmatrixdae-BDF" href="#OrdinaryDiffEqBDF.QNDF-massmatrixdae-BDF"><code>OrdinaryDiffEqBDF.QNDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QNDF(; chunk_size = Val{0}(),
       autodiff = AutoForwardDiff(),
       standardtag = Val{true}(),
       concrete_jac = nothing,
       linsolve = nothing,
       precs = DEFAULT_PRECS,
       κ = nothing,
       tol = nothing,
       nlsolve = NLNewton(),
       extrapolant = :linear,
       kappa =  promote(-0.1850, -1 // 9, -0.0823, -0.0415, 0),
       controller = :Standard,
       step_limiter! = trivial_limiter!)</code></pre><p>Multistep Method. An adaptive order quasi-constant timestep NDF method. Similar to MATLAB&#39;s ode15s. Uses Shampine&#39;s accuracy-optimal coefficients. Performance improves with larger, more complex ODEs. Good for medium to highly stiff problems. Recommended for large systems (&gt;1000 ODEs).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>QNDF(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre>/n- <code>κ</code>: TBD</li><li><code>tol</code>: TBD</li><li><code>nlsolve</code>: TBD</li><li><code>extrapolant</code>: TBD</li><li><code>kappa</code>: TBD</li><li><code>controller</code>: TBD</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><p>@article{shampine1997matlab, title={The matlab ode suite}, author={Shampine, Lawrence F and Reichelt, Mark W}, journal={SIAM journal on scientific computing}, volume={18}, number={1}, pages={1–22}, year={1997}, publisher={SIAM} }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/8a1baf238db417f7d25478ecdee55151bd4816a8/lib/OrdinaryDiffEqBDF/src/algorithms.jl#L383-L475">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqBDF.QNDF1-massmatrixdae-BDF" href="#OrdinaryDiffEqBDF.QNDF1-massmatrixdae-BDF"><code>OrdinaryDiffEqBDF.QNDF1</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QNDF1(; chunk_size = Val{0}(),
        autodiff = AutoForwardDiff(),
        standardtag = Val{true}(),
        concrete_jac = nothing,
        linsolve = nothing,
        precs = DEFAULT_PRECS,
        nlsolve = NLNewton(),
        extrapolant = :linear,
        kappa = -0.1850,
        controller = :Standard,
        step_limiter! = trivial_limiter!)</code></pre><p>Multistep Method. An adaptive order 1 quasi-constant timestep L-stable numerical differentiation function method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>QNDF1(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre>/n- <code>nlsolve</code>: TBD</li><li><code>extrapolant</code>: TBD</li><li><code>kappa</code>: TBD</li><li><code>controller</code>: TBD</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><p>@article{shampine1997matlab, title={The matlab ode suite}, author={Shampine, Lawrence F and Reichelt, Mark W}, journal={SIAM journal on scientific computing}, volume={18}, number={1}, pages={1–22}, year={1997}, publisher={SIAM} }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/8a1baf238db417f7d25478ecdee55151bd4816a8/lib/OrdinaryDiffEqBDF/src/algorithms.jl#L263-L351">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqBDF.QNDF2-massmatrixdae-BDF" href="#OrdinaryDiffEqBDF.QNDF2-massmatrixdae-BDF"><code>OrdinaryDiffEqBDF.QNDF2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">QNDF2(; chunk_size = Val{0}(),
        autodiff = AutoForwardDiff(),
        standardtag = Val{true}(),
        concrete_jac = nothing,
        linsolve = nothing,
        precs = DEFAULT_PRECS,
        nlsolve = NLNewton(),
        extrapolant = :linear,
        kappa =  -1 // 9,
        controller = :Standard,
        step_limiter! = trivial_limiter!)</code></pre><p>Multistep Method. An adaptive order 2 quasi-constant timestep L-stable numerical differentiation function (NDF) method.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>QNDF2(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre>/n- <code>nlsolve</code>: TBD</li><li><code>extrapolant</code>: TBD</li><li><code>kappa</code>: TBD</li><li><code>controller</code>: TBD</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li></ul><p><strong>References</strong></p><p>@article{shampine1997matlab, title={The matlab ode suite}, author={Shampine, Lawrence F and Reichelt, Mark W}, journal={SIAM journal on scientific computing}, volume={18}, number={1}, pages={1–22}, year={1997}, publisher={SIAM} }</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/8a1baf238db417f7d25478ecdee55151bd4816a8/lib/OrdinaryDiffEqBDF/src/algorithms.jl#L323-L411">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqBDF.QBDF-massmatrixdae-BDF" href="#OrdinaryDiffEqBDF.QBDF-massmatrixdae-BDF"><code>OrdinaryDiffEqBDF.QBDF</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>QBDF: Multistep Method</p><p>An alias of <code>QNDF</code> with κ=0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/8a1baf238db417f7d25478ecdee55151bd4816a8/lib/OrdinaryDiffEqBDF/src/algorithms.jl#L568-L572">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqBDF.QBDF1-massmatrixdae-BDF" href="#OrdinaryDiffEqBDF.QBDF1-massmatrixdae-BDF"><code>OrdinaryDiffEqBDF.QBDF1</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>QBDF1: Multistep Method</p><p>An alias of <code>QNDF1</code> with κ=0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/8a1baf238db417f7d25478ecdee55151bd4816a8/lib/OrdinaryDiffEqBDF/src/algorithms.jl#L554-L558">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqBDF.QBDF2-massmatrixdae-BDF" href="#OrdinaryDiffEqBDF.QBDF2-massmatrixdae-BDF"><code>OrdinaryDiffEqBDF.QBDF2</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>QBDF2: Multistep Method</p><p>An alias of <code>QNDF2</code> with κ=0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/8a1baf238db417f7d25478ecdee55151bd4816a8/lib/OrdinaryDiffEqBDF/src/algorithms.jl#L561-L565">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqBDF.MEBDF2-massmatrixdae-BDF" href="#OrdinaryDiffEqBDF.MEBDF2-massmatrixdae-BDF"><code>OrdinaryDiffEqBDF.MEBDF2</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">MEBDF2(; chunk_size = Val{0}(),
         autodiff = AutoForwardDiff(),
         standardtag = Val{true}(),
         concrete_jac = nothing,
         linsolve = nothing,
         precs = DEFAULT_PRECS,
         nlsolve = NLNewton(),
         extrapolant = :constant)</code></pre><p>Multistep Method. The second order Modified Extended BDF method,     which has improved stability properties over the standard BDF.     Fixed timestep only.</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>MEBDF2(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre>/n- <code>nlsolve</code>: TBD</li><li><code>extrapolant</code>: TBD</li></ul><p><strong>References</strong></p><p>@article{cash2000modified, title={Modified extended backward differentiation formulae for the numerical solution of stiff initial value problems in ODEs and DAEs}, author={Cash, JR}, journal={Journal of Computational and Applied Mathematics}, volume={125}, number={1-2}, pages={117–130}, year={2000}, publisher={Elsevier}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/8a1baf238db417f7d25478ecdee55151bd4816a8/lib/OrdinaryDiffEqBDF/src/algorithms.jl#L449-L532">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OrdinaryDiffEqBDF.FBDF-massmatrixdae-BDF" href="#OrdinaryDiffEqBDF.FBDF-massmatrixdae-BDF"><code>OrdinaryDiffEqBDF.FBDF</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">FBDF(; chunk_size = Val{0}(),
       autodiff = AutoForwardDiff(),
       standardtag = Val{true}(),
       concrete_jac = nothing,
       linsolve = nothing,
       precs = DEFAULT_PRECS,
       κ = nothing,
       tol = nothing,
       nlsolve = NLNewton(),
       extrapolant = :linear,
       controller = :Standard,
       step_limiter! = trivial_limiter!,
       max_order::Val{MO} = Val{5}())</code></pre><p>Multistep Method. An adaptive order quasi-constant timestep NDF method. Fixed leading coefficient BDF. Utilizes Shampine&#39;s accuracy-optimal kappa values as defaults (has a keyword argument for a tuple of kappa coefficients).</p><p><strong>Keyword Arguments</strong></p><ul><li><code>autodiff</code>: Uses <a href="https://sciml.github.io/ADTypes.jl/stable/">ADTypes.jl</a>    to specify whether to use automatic differentiation via   <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a> or finite   differencing via <a href="https://github.com/JuliaDiff/FiniteDiff.jl">FiniteDiff.jl</a>.    Defaults to <code>AutoForwardDiff()</code> for automatic differentiation, which by default uses   <code>chunksize = 0</code>, and thus uses the internal ForwardDiff.jl algorithm for the choice.   To use <code>FiniteDiff.jl</code>, the <code>AutoFiniteDiff()</code> ADType can be used, which has a keyword argument   <code>fdtype</code> with default value <code>Val{:forward}()</code>, and alternatives <code>Val{:central}()</code> and <code>Val{:complex}()</code>.</li><li><code>standardtag</code>: Specifies whether to use package-specific tags instead of the   ForwardDiff default function-specific tags. For more information, see   <a href="https://www.stochasticlifestyle.com/improved-forwarddiff-jl-stacktraces-with-package-tags/">this blog post</a>.   Defaults to <code>Val{true}()</code>.</li><li><code>concrete_jac</code>: Specifies whether a Jacobian should be constructed. Defaults to   <code>nothing</code>, which means it will be chosen true/false depending on circumstances   of the solver, such as whether a Krylov subspace method is used for <code>linsolve</code>.</li><li><code>linsolve</code>: Any <a href="https://github.com/SciML/LinearSolve.jl">LinearSolve.jl</a> compatible linear solver. For example, to use <a href="https://github.com/JuliaSparse/KLU.jl">KLU.jl</a>, specify <code>FBDF(linsolve = KLUFactorization()</code>).  When <code>nothing</code> is passed, uses <code>DefaultLinearSolver</code>.</li><li><code>precs</code>: Any <a href="https://docs.sciml.ai/LinearSolve/stable/basics/Preconditioners/">LinearSolve.jl-compatible preconditioner</a> can be used as a left or right preconditioner. Preconditioners are specified by the <code>Pl,Pr = precs(W,du,u,p,t,newW,Plprev,Prprev,solverdata)</code> function where the arguments are defined as:<ul><li><code>W</code>: the current Jacobian of the nonlinear system. Specified as either   <span>$I - \gamma J$</span> or <span>$I/\gamma - J$</span> depending on the algorithm. This will   commonly be a <code>WOperator</code> type defined by OrdinaryDiffEq.jl. It is a lazy   representation of the operator. Users can construct the W-matrix on demand   by calling <code>convert(AbstractMatrix,W)</code> to receive an <code>AbstractMatrix</code> matching   the <code>jac_prototype</code>.</li><li><code>du</code>: the current ODE derivative</li><li><code>u</code>: the current ODE state</li><li><code>p</code>: the ODE parameters</li><li><code>t</code>: the current ODE time</li><li><code>newW</code>: a <code>Bool</code> which specifies whether the <code>W</code> matrix has been updated since   the last call to <code>precs</code>. It is recommended that this is checked to only   update the preconditioner when <code>newW == true</code>.</li><li><code>Plprev</code>: the previous <code>Pl</code>.</li><li><code>Prprev</code>: the previous <code>Pr</code>.</li><li><code>solverdata</code>: Optional extra data the solvers can give to the <code>precs</code> function.   Solver-dependent and subject to change.</li></ul>The return is a tuple <code>(Pl,Pr)</code> of the LinearSolve.jl-compatible preconditioners. To specify one-sided preconditioning, simply return <code>nothing</code> for the preconditioner which is not used. Additionally, <code>precs</code> must supply the dispatch:<pre><code class="language-julia hljs">Pl, Pr = precs(W, du, u, p, t, ::Nothing, ::Nothing, ::Nothing, solverdata)</code></pre>which is used in the solver setup phase to construct the integrator type with the preconditioners <code>(Pl,Pr)</code>. The default is <code>precs=DEFAULT_PRECS</code> where the default preconditioner function is defined as:<pre><code class="language-julia hljs">DEFAULT_PRECS(W, du, u, p, t, newW, Plprev, Prprev, solverdata) = nothing, nothing</code></pre>/n- <code>κ</code>: TBD</li><li><code>tol</code>: TBD</li><li><code>nlsolve</code>: TBD</li><li><code>extrapolant</code>: TBD</li><li><code>controller</code>: TBD</li><li><code>step_limiter!</code>: function of the form <code>limiter!(u, integrator, p, t)</code></li><li><code>max_order</code>: TBD</li></ul><p><strong>References</strong></p><p>@article{shampine2002solving, title={Solving 0= F (t, y (t), y′(t)) in Matlab}, author={Shampine, Lawrence F}, year={2002}, publisher={Walter de Gruyter GmbH \&amp; Co. KG}}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/SciML/OrdinaryDiffEq.jl/blob/8a1baf238db417f7d25478ecdee55151bd4816a8/lib/OrdinaryDiffEqBDF/src/algorithms.jl#L494-L583">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../Rosenbrock/">« OrdinaryDiffEqRosenbrock</a><a class="docs-footer-nextpage" href="../../fullyimplicitdae/BDF/">OrdinaryDiffEqBDF »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Wednesday 23 July 2025 11:29">Wednesday 23 July 2025</span>. Using Julia version 1.11.6.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
